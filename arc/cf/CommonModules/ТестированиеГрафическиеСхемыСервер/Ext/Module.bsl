# Область ПрограммныйИнтерфейс

// Преобразует обычный текст во внутренний формат в виде дерева значений
//
// Параметры:
//  Текст - Строка
//  ДеревоСхемы - ДеревоЗначений
//  Проект - Справочники.Проекты
//  Сценарий - Справочники.Сценарии
// 
// Возвращаемое значение:
//  Структура - Структура возврата
//
Процедура ДеревоСценарияИзТекста(Текст,ДеревоСхемы,Проект,Сценарий,ДополнительныеПараметры) Экспорт
	СборщикСценариев = СборщикСценариев();
	СборщикСценариев.ДеревоСценарияИзТекста(Текст,ДеревоСхемы,Проект,Сценарий,ДополнительныеПараметры);
КонецПроцедуры

// Возвращает полное дерево сценария, считывая его из БД
//
// Параметры:
//  Сценарий - Справочник.СценарииРаботыПользователей
// 
// Возвращаемое значение:
//  ДеревоЗначений - Дерево выполнения сценария
//
Функция ДеревоСценарияИзБазыДанных(Сценарий) Экспорт
	СборщикСценариев = СборщикСценариев();
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("ЧтениеИзТекста",Ложь);
	Возврат СборщикСценариев.ДеревоСценарияИзБазыДанных(Сценарий,СтруктураПараметров);
КонецФункции	

// Возвращает данные для получения текста сценария
//
// Параметры:
//  Сценарий - Справочник.СценарииРаботыПользователей
//  СтруктураПараметров - Структура
// 
// Возвращаемое значение:
//  Структура - Данные для формирования текстов сценариев
//
Функция ТекстыСценариев(Сценарий,СтруктураПараметров) Экспорт
	СборщикСценариев = СборщикСценариев();
	
	Если НЕ СтруктураПараметров.Свойство("ЧтениеИзТекста") Тогда
		СтруктураПараметров.Вставить("ЧтениеИзТекста",Ложь);
	КонецЕсли;	 
	
	Возврат СборщикСценариев.ТекстыСценариев(Сценарий,СтруктураПараметров);
КонецФункции	

// Возвращает обычный текст, полученный из форматированного документа
//
// Параметры:
//  ФД - ФорматированныйДокумент
// 
// Возвращаемое значение:
//  Строка - Текст
//
Функция ОбычныйТекстСценарияИзФорматированногоДокумента(ФД,ДополнительныеПараметры) Экспорт
	Текст = ФД.ПолучитьТекст();
	
	ЗаменитьОтступыНаСимволыТаб(Текст);
	
	Возврат Текст;
КонецФункции	

// Преобразует обычный текст в форматированный текст сценария
//
// Параметры:
//  Текст - Строка
//  ФД - ФорматированныйДокумент
//  Проект - Справочники.Проекты
//  Сценарий - Справочники.Сценарии
//  ДополнительныеПараметры - Структура
// 
Процедура ТекстФорматированныйТекстСценарияИзОбычногоТекста(Текст,ФД,Проект,Сценарий,ДополнительныеПараметры) Экспорт
	СборщикСценариев = СборщикСценариев();
	СборщикСценариев.ТекстФорматированныйТекстСценарияИзОбычногоТекста(Текст,ФД,Проект,Сценарий,ДополнительныеПараметры);
КонецПроцедуры

//  Преобразует графическую схему во внутренний формат в виде дерева значений
//
// Параметры:
//  Схема - ГрафическаяСхема.
//  ДеревоСхемыПараметр - ДеревоЗначений
// 
// Возвращаемое значение:
//  ДеревоЗначений - ДеревоСхемы
//
Функция ПреобразоватьГрафическуюСхемуВДеревоСхемы(Схема,ДеревоСхемыПараметр) Экспорт
	ДеревоСхемы = ДеревоСхемыПараметр.Скопировать();
	ДеревоСхемы.Строки.Очистить();
	
	ГрафическаяСхемаXDTO = ГрафическаяСхемаXDTO(Схема);
	
	ЗаполнитьДеревоСхемыНаОснованииГрафическойСхемы(ГрафическаяСхемаXDTO,ДеревоСхемы,ДеревоСхемыПараметр);
	
	Возврат ДеревоСхемы;
КонецФункции	

//  Преобразует графическую схему во внутренний формат в виде дерева значений
//
// Параметры:
//  Схема - Тип
// 
// Возвращаемое значение:
//  Структура - СтруктураВозврата
//
Функция ГрафическаяСхемаXDTO(Схема) Экспорт
	Сериализатор = Новый СериализаторXDTO(ФабрикаXDTO);
	ОбъектXDTOСхема = Сериализатор.ЗаписатьXDTO(Схема);
	ЭлементыСхемыXDTO = ОбъектXDTOСхема.ПолучитьСписок("item");
	
	СтруктураВозврата = Новый Структура;
	СтруктураВозврата.Вставить("ОбъектXDTOСхема",ОбъектXDTOСхема);
	СтруктураВозврата.Вставить("ЭлементыСхемыXDTO",ЭлементыСхемыXDTO);
	СтруктураВозврата.Вставить("Свойства",Новый Структура);
	
	Возврат СтруктураВозврата;
КонецФункции

// Преобразует внутренний формат схемы из дерева значений в графическую схему
//
// Параметры:
//  ДеревоСхемы - ДеревоЗначений
// 
// Возвращаемое значение:
//  Структура - СтруктураВозврата
//
Функция ГрафическаяСхемаПоДеревуСхемы(ДеревоСхемы) Экспорт
	Схема                = Новый ГрафическаяСхема;
	ГрафическаяСхемаXDTO = ГрафическаяСхемаXDTO(Схема);
	
	МатрицаЭлементов = МатрицаЭлементовПоДеревуСхемы(ГрафическаяСхемаXDTO,ДеревоСхемы);
	
	ПреобразоватьМатрицуВОбъектГрафическаяСхемаXDTO(ГрафическаяСхемаXDTO,МатрицаЭлементов,ДеревоСхемы);
	
	СтруктураВозврата = СхемаИзСпискаXDTO(ГрафическаяСхемаXDTO);
	СтруктураВозврата.Вставить("МатрицаЭлементов",МатрицаЭлементов);
	
	Возврат СтруктураВозврата;
КонецФункции	

// Преобразует текст перед установкой в поле форматированного документа
//
// Параметры:
//  Строка - ТекстДокумента
//
Процедура СделатьСтандартнуюПодготовкуТекстаHTML(ТекстДокумента) Экспорт
	СборщикСценариев = СборщикСценариев();
	СборщикСценариев.СделатьСтандартнуюПодготовкуТекстаHTML(ТекстДокумента);
КонецПроцедуры

// Преобразует схему во внутреннем формате в виде дерева значений в форматированный документ
//
// Параметры:
//  ДеревоСхемы - ДеревоЗначений
//  ФорматированныйДокумент - ФорматированныйДокумент
//
Процедура ФорматированныйДокументПоДеревуСхемы(ДеревоСхемы,ФорматированныйДокумент,ШаблонHTML,ДополнительныеПараметры) Экспорт
		   
		   
	СборщикСценариев = СборщикСценариев();
	СборщикСценариев.ФорматированныйДокументПоДеревуСхемы(ДеревоСхемы,ФорматированныйДокумент,
	    ШаблонHTML,ДополнительныеПараметры);
КонецПроцедуры

// Заполняет таблицу параметров из дерева значений
//
// Параметры:
//  Дерево - ДеревоЗначений
//  ТаблицаПараметров - ТаблицаЗначений
//
Процедура ПараметрыВходящиеИзДерева(Дерево,ТаблицаПараметров) Экспорт
	СборщикСценариев = СборщикСценариев();
	СборщикСценариев.ПараметрыВходящиеИзДерева(Дерево,ТаблицаПараметров);
КонецПроцедуры

// Обновляет из БД таблицу ВерсииШаблонов
//
// Параметры:
//  ПараметрыВерсийСценариев - Структура
//
Процедура ВерсииШаблонов(ПараметрыВерсийСценариев) Экспорт
	СборщикСценариев = СборщикСценариев();
	СборщикСценариев.ВерсииШаблонов(ПараметрыВерсийСценариев);
КонецПроцедуры

// Возвращает данные для получения текста сценария процесса
//
// Параметры:
//  Процесс - Справочник.Процессы
//  ПараметрыФормированияТекстаСценария - Структура
// 
// Возвращаемое значение:
//  Структура - Данные для формирования теста процесса
//
Функция ДанныеДляТекстаСценарияПроцесса(Процесс,ПараметрыФормированияТекстаСценария) Экспорт
	СборщикСценариев = СборщикСценариев();
	Возврат СборщикСценариев.ДанныеДляТекстаСценарияПроцесса(Процесс,ПараметрыФормированияТекстаСценария);
КонецФункции	

// Возвращает снипет по переданной строке
//
Функция СнипетПоСтроке(Стр,МассивПервыхСловНРег = Неопределено,КешПараметровСтроки = Неопределено) Экспорт
	СборщикСценариев = СборщикСценариев();
	Возврат СборщикСценариев.СнипетПоСтроке(Стр,МассивПервыхСловНРег,КешПараметровСтроки);
КонецФункции	

# КонецОбласти

# Область СлужебныеПроцедурыИФункции

# Область СлужебныеПроцедурыИФункцииПреобразованияСхемыВРазныеФорматы

Функция СнипетИзСтроки(Знач Стр,КешПараметровСтроки = Неопределено) Экспорт
	СборщикСценариев = СборщикСценариев();
	Возврат СборщикСценариев.СнипетИзСтроки(Стр,КешПараметровСтроки);
КонецФункции	

Функция УбратьКлючевоеСлово(Стр,МассивПервыхСловНРег = Неопределено,КешПараметровСтроки = Неопределено) Экспорт
	
	Если МассивПервыхСловНРег = Неопределено Тогда
		МассивПервыхСловНРег = МассивПервыхСловGherkinНРег();
	КонецЕсли;	 
	
	МассивСлов  = СтрРазделить(Стр," ",Истина);
	
	ПервоеСлово   = МассивСлов[0];
	
	Если ПервоеСлово = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;	 
	
	НРегСтр = НРег(Стр);
	Для Каждого КлючевоеСлово Из МассивПервыхСловНРег Цикл
		Позиция = Найти(НРегСтр, КлючевоеСлово);	
		Если Позиция = 1 Тогда
			Стр = СокрЛП(Сред(Стр,СтрДлина(КлючевоеСлово)+1));
			Возврат Истина; 
		КонецЕсли;	 
	КонецЦикла;	
	
	Возврат Ложь;
	
КонецФункции	

Процедура ЭкранироватьУгловыеСкобки(Стр) Экспорт
	СборщикСценариев = СборщикСценариев();
	СборщикСценариев.ЭкранироватьУгловыеСкобки(Стр);
КонецПроцедуры

Процедура ВернутьУгловыеСкобки(Стр) Экспорт
	СборщикСценариев = СборщикСценариев();
	СборщикСценариев.ВернутьУгловыеСкобки(Стр);
КонецПроцедуры

Процедура ЭкранироватьСпецСимволы(Стр) Экспорт
	СборщикСценариев = СборщикСценариев();
	СборщикСценариев.ЭкранироватьСпецСимволы(Стр);
КонецПроцедуры

Процедура ЭкранироватьОсновныеСпецСимволыGherkin(Стр) Экспорт
	СборщикСценариев = СборщикСценариев();
	СборщикСценариев.ЭкранироватьОсновныеСпецСимволыGherkin(Стр);
КонецПроцедуры

Функция ВеткиУсловия(Дерево)
	СборщикСценариев = СборщикСценариев();
	Возврат СборщикСценариев.ВеткиУсловия(Дерево);
КонецФункции	

# КонецОбласти

# Область СлужебныеПроцедурыИФункцииПреобразованияДереваСхемыВГрафическуюСхемуИОбратно

// Подготавливает таблицу, которая будет использована для установки элементов графической схемы
Функция СоздатьМатрицуЭлементов()
	Тзн = Новый ТаблицаЗначений;
	Возврат Тзн;
КонецФункции	

// Возвращает структуру, в которой содержаться значения строки дерева
Функция СтруктураЭлементаИзСтрокиДерева(СтрокаДерева = Неопределено)
	Структура = Новый Структура;
	Структура.Вставить("КординатаX",Неопределено);
	Структура.Вставить("КординатаY",Неопределено);
	
	Если СтрокаДерева = Неопределено Тогда
		Структура.Вставить("ИмяЭлемента",Неопределено);
		Структура.Вставить("ОписаниеЭлемента",Неопределено);
		Структура.Вставить("ТипЭлемента",Неопределено);
		Структура.Вставить("ЗначениеУсловия",Неопределено);
		Структура.Вставить("ИмяМетки",Неопределено);
		Структура.Вставить("ИдСтрокиТаблицаСтрок",Неопределено);
		Структура.Вставить("Параметры",Неопределено);
		Структура.Вставить("ТипЭлемента",Неопределено);
		Структура.Вставить("ПодчиненнаяСхема",Неопределено);
		Структура.Вставить("ИдСтрокиДерева",Неопределено);
		Структура.Вставить("ОтображаетсяКакЭлемент",Ложь);
		Структура.Вставить("ПерейтиКМетке",Ложь);
		Структура.Вставить("Комментарии",Неопределено);
		Структура.Вставить("Теги",Неопределено);
	Иначе	
		Структура.Вставить("ИмяЭлемента",СтрокаДерева.ИмяЭлемента);
		Структура.Вставить("ОписаниеЭлемента",СтрокаДерева.ОписаниеЭлемента);
		Структура.Вставить("ТипЭлемента",СтрокаДерева.ТипЭлемента);
		Структура.Вставить("ЗначениеУсловия",СтрокаДерева.ЗначениеУсловия);
		Структура.Вставить("ИмяМетки",СтрокаДерева.ИмяМетки);
		Структура.Вставить("ИдСтрокиТаблицаСтрок",СтрокаДерева.ИдСтрокиТаблицаСтрок);
		Структура.Вставить("Параметры",СтрокаДерева.Параметры);
		Структура.Вставить("ТипЭлемента",СтрокаДерева.ТипЭлемента);
		Структура.Вставить("ПодчиненнаяСхема",СтрокаДерева.ПодчиненнаяСхема);
		Структура.Вставить("ИдСтрокиДерева",СтрокаДерева.ИдСтрокиДерева);
		Структура.Вставить("ОтображаетсяКакЭлемент",Истина);
		Структура.Вставить("ПерейтиКМетке",СтрокаДерева.ПерейтиКМетке);
		Структура.Вставить("Комментарии",СтрокаДерева.Комментарии);
		Структура.Вставить("Теги",СтрокаДерева.Теги);
	КонецЕсли;	 
	
	Возврат Структура;
КонецФункции	

// Увеличивает размер матрицы если это необходимо
Процедура РасширитьМатрицуЭлементов(МатрицаЭлементов,ТекКоординатаВМатрицеX,ТекКоординатаВМатрицеY)
	Пока МатрицаЭлементов.Количество() < ТекКоординатаВМатрицеY Цикл
		МатрицаЭлементов.Добавить(); 
	КонецЦикла;	
	
	Пока МатрицаЭлементов.Колонки.Количество() < ТекКоординатаВМатрицеX Цикл
		МатрицаЭлементов.Колонки.Добавить("Колонка" + XMLСтрока((МатрицаЭлементов.Колонки.Количество()+1)));
	КонецЦикла;	
КонецПроцедуры

// Определеяет является ли условие простым (Если..Иначе) или сложным (Если..ИначеЕсли..Иначе)
Функция ТипУсловия(Дерево)
	Для Каждого СтрокаДерева Из Дерево.Строки Цикл
		Если СтрокаДерева.ТипЭлемента = ТипЭлементаИначеЕслиПрепроцессор() Тогда
			Возврат ТипУсловияСложное();
		КонецЕсли;	 
	КонецЦикла;	
	
	Возврат ТипУсловияПростое();
КонецФункции	

// Добавляет элементы из ветки в матрицу
Процедура УложитьВеткуУсловия(МатрицаЭлементов,ВеткаДерева,КординатаX,КординатаY,МассивЭлементовМатрицы)
	Если МассивЭлементовМатрицы = Неопределено Тогда
		МассивЭлементовМатрицы = Новый Массив;
	КонецЕсли;	 
	
	Для Каждого СтрокаДерева Из ВеткаДерева.Строки Цикл
		Если ТипЭлементаНеИмеетОтображения(СтрокаДерева.ТипЭлемента) Тогда
			Продолжить;
		КонецЕсли;	 
		
		СтруктураЭлемента = УложитьЭлементВМатрицу(СтрокаДерева,МатрицаЭлементов,КординатаX,КординатаY,МассивЭлементовМатрицы);
		Если Не СтруктураЭлемента.ОтображаетсяКакЭлемент Тогда
			Продолжить;
		КонецЕсли;	 
		СтруктураЭлемента.Вставить("КординатаX",КординатаX);
		СтруктураЭлемента.Вставить("КординатаY",КординатаY);
		МассивЭлементовМатрицы.Добавить(СтруктураЭлемента);
	КонецЦикла;	
КонецПроцедуры

// Возвращает предыдущую строку дерева
Функция ПредыдущаяСтрокаДерева(СтрокаДерева)
	Если ТипЗнч(СтрокаДерева) = Тип("ДеревоЗначений") Тогда
		//это уже самый верхний уровень
		Возврат Неопределено;
	КонецЕсли;	 
	
	Родитель = СтрокаДерева.Родитель;
	Если Родитель = Неопределено Тогда
		Родитель = СтрокаДерева.Владелец();
	КонецЕсли;	 
	
	ИндексСледующейСтроки = Родитель.Строки.Индекс(СтрокаДерева) - 1;	
	
	Если ИндексСледующейСтроки >= 0  Тогда
		ПредыдущаяСтрока = Родитель.Строки.Получить(ИндексСледующейСтроки);
		Пока Истина Цикл
			Если ПредыдущаяСтрока = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;	 
			
			Если (ПредыдущаяСтрока.ТипЭлемента = ТипЭлементаМетка()) или (ПредыдущаяСтрока.ТипЭлемента = ТипЭлементаПерейти())
				или (ТипЭлементаНеИмеетОтображения(ПредыдущаяСтрока.ТипЭлемента)) Тогда
				ИндексСледующейСтроки = ИндексСледующейСтроки - 1;
				Если ИндексСледующейСтроки >= 0 Тогда
					ПредыдущаяСтрока = Родитель.Строки.Получить(ИндексСледующейСтроки);
				Иначе
					Возврат Неопределено;
				КонецЕсли;	 
			Иначе
				Прервать;
			КонецЕсли;	 
		КонецЦикла;	
		
		Если ПредыдущаяСтрока.ТипЭлемента = ТипЭлементаКонецЕслиПрепроцессор()
			 или ПредыдущаяСтрока.ТипЭлемента = ТипЭлементаКонецЕсли()
			 или ПредыдущаяСтрока.ТипЭлемента = ТипЭлементаКонецЕслиEng()
			 или ПредыдущаяСтрока.ТипЭлемента = ТипЭлементаКонецЦикла()
			 или ПредыдущаяСтрока.ТипЭлемента = ТипЭлементаКонецЦиклаEng()
			Тогда
			Возврат СледующаяСтрокаДерева(ПредыдущаяСтрока);
		КонецЕсли;	 
		
		Возврат ПредыдущаяСтрока;
	Иначе
		Возврат СледующаяСтрокаДерева(Родитель);
	КонецЕсли;	 
	
	Возврат Неопределено;
КонецФункции	

Функция ТипЭлементаНеИмеетОтображения(ТипЭлемента)
	Если ТипЭлемента = ТипЭлементаПустаяСтрока() Тогда
		Возврат Истина;
	ИначеЕсли ТипЭлемента = ТипЭлементаКомментарий() Тогда
		Возврат Истина;
	ИначеЕсли ТипЭлемента = ТипЭлементаБлочныйКомментарий() Тогда
		Возврат Истина;
	ИначеЕсли ТипЭлемента = ТипЭлементаТег() Тогда
		Возврат Истина;
	ИначеЕсли ТипЭлемента = ТипЭлементаТаблица() Тогда
		Возврат Истина;
	ИначеЕсли ТипЭлемента = ТипЭлементаБлочныйКомментарийНачало() Тогда
		Возврат Истина;
	ИначеЕсли ТипЭлемента = ТипЭлементаБлочныйКомментарийОкончание() Тогда
		Возврат Истина;
	КонецЕсли;	 
	
	Возврат Ложь;
КонецФункции	

// Возвращает следующую строку дерева
Функция СледующаяСтрокаДерева(СтрокаДерева)
	Если ТипЗнч(СтрокаДерева) = Тип("ДеревоЗначений") Тогда
		//это уже самый верхний уровень
		Возврат Неопределено;
	КонецЕсли;	 
	
	Родитель = СтрокаДерева.Родитель;
	Если Родитель = Неопределено Тогда
		Родитель = СтрокаДерева.Владелец();
	КонецЕсли;	 
	
	ИндексСледующейСтроки = Родитель.Строки.Индекс(СтрокаДерева) + 1;	
	
	Если ИндексСледующейСтроки <= Родитель.Строки.Количество()-1  Тогда
		СледующаяСтрока = Родитель.Строки.Получить(ИндексСледующейСтроки);
		
		Если (СледующаяСтрока.ТипЭлемента = ТипЭлементаЗаголовок())
			или ТипЭлементаНеИмеетОтображения(СледующаяСтрока.ТипЭлемента) Тогда
			СледующаяСтрока = СледующаяСтрокаДерева(СледующаяСтрока);
		КонецЕсли;	 
		
		Пока Истина Цикл
			Если СледующаяСтрока = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;	 
			
			Если (СледующаяСтрока.ТипЭлемента = ТипЭлементаМетка())
				или (СледующаяСтрока.ТипЭлемента = ТипЭлементаПерейти())  Тогда
				ИндексСледующейСтроки = ИндексСледующейСтроки + 1;
				Если ИндексСледующейСтроки <= Родитель.Строки.Количество()-1  Тогда
					СледующаяСтрока = Родитель.Строки.Получить(ИндексСледующейСтроки);
					Если ТипЭлементаНеИмеетОтображения(СледующаяСтрока.ТипЭлемента) Тогда
						СледующаяСтрока = СледующаяСтрокаДерева(СледующаяСтрока);
					КонецЕсли;	 
				Иначе
					Возврат Неопределено;
				КонецЕсли;	 
			Иначе
				Прервать;
			КонецЕсли;	 
		КонецЦикла;	
		
		Если (СледующаяСтрока.ТипЭлемента = ТипЭлементаКонецЕслиПрепроцессор())
			или (СледующаяСтрока.ТипЭлемента = ТипЭлементаИначеПрепроцессор())
			или (СледующаяСтрока.ТипЭлемента = ТипЭлементаИначеЕслиПрепроцессор())
			Тогда
			Возврат СледующаяСтрокаДерева(СледующаяСтрока);                                 
		КонецЕсли;	 
		
		Возврат СледующаяСтрока;
	Иначе
		Возврат СледующаяСтрокаДерева(Родитель);
	КонецЕсли;	 
	
	Возврат Неопределено;
КонецФункции	

// Определяет возможную координату X, куда можно уложить новый элемент схемы
Функция ВозможноеЗначениеКоординатыXВданномРяду(МатрицаЭлементов,Y)
	Если (МатрицаЭлементов.Количество()) < Y+1 Тогда
		РасширитьМатрицуЭлементов(МатрицаЭлементов,0,Y+1);
	КонецЕсли;	 
	
	МаксX = -1;
	Для X = 0 По МатрицаЭлементов.Колонки.Количество()-1 Цикл
		СтруктураЭлемента = МатрицаЭлементов[Y][X];
		Если СтруктураЭлемента = Неопределено Тогда
			Продолжить;
		КонецЕсли;	 
		
		МаксX = X;
		
	КонецЦикла;	
	
	Возврат МаксX+1+1;
КонецФункции	

// Возвращает Ид строки дерева, которая содержит данную метку
Функция НайтиМеткуВДереве(СтрокаДерева,ИмяМетки)
	Если ТипЗнч(СтрокаДерева) = Тип("СтрокаДереваЗначений") Тогда
		Дерево = СтрокаДерева.Владелец();
	Иначе
		Дерево = СтрокаДерева;
	КонецЕсли;	 
	
	СтрокаДереваСМеткой = Дерево.Строки.Найти(ИмяМетки,"ИмяМетки",Истина);
	Если СтрокаДереваСМеткой = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;	 
	
	Возврат СтрокаДереваСМеткой.ИдСтрокиДерева;
КонецФункции	

Функция КоличествоИсполняемыхШаговВВетке(Дерево)
	Количество = 0;
	Для Каждого СтрокаДерева Из Дерево.Строки Цикл
		Если ТипЭлементаНеИмеетОтображения(СтрокаДерева.ТипЭлемента) Тогда
			Продолжить;
		КонецЕсли;	 
		
		Количество = Количество + 1;
	КонецЦикла;	
	
	Возврат Количество;
КонецФункции	

// Помещает элемент схемы в матрицу элементов, чтобы потом по этой матрице можно было построить графическую схему
Функция УложитьЭлементВМатрицу(СтрокаДерева,МатрицаЭлементов,ТекКоординатаВМатрицеX,ТекКоординатаВМатрицеY,МассивЭлементовМатрицы)
	СтруктураЭлемента = СтруктураЭлементаИзСтрокиДерева(СтрокаДерева);
	
	Если СтрокаДерева.ТипЭлемента = ТипЭлементаЗаголовок() Тогда
		Возврат СтруктураЭлемента;
	ИначеЕсли (СтрокаДерева.ТипЭлемента = ТипЭлементаКонтекст()) или (СтрокаДерева.ТипЭлемента = ТипЭлементаСценарий()) Тогда
		Для Каждого ВложеннаяСтрока Из СтрокаДерева.Строки Цикл
			УложитьЭлементВМатрицу(ВложеннаяСтрока,МатрицаЭлементов,ТекКоординатаВМатрицеX,
								   ТекКоординатаВМатрицеY,МассивЭлементовМатрицы)
		КонецЦикла;	
	ИначеЕсли СтрокаДерева.ТипЭлемента = ТипЭлементаУсловиеПрепроцессор()
		      или СтрокаДерева.ТипЭлемента = ТипЭлементаУсловие()
		      или СтрокаДерева.ТипЭлемента = ТипЭлементаУсловиеEng()
		      или СтрокаДерева.ТипЭлемента = ТипЭлементаЦикл()
		      или СтрокаДерева.ТипЭлемента = ТипЭлементаЦиклEng()
			  Тогда
		ТипУсловия = ТипУсловия(СтрокаДерева); 
		СтруктураЭлемента.Вставить("ТипУсловия",ТипУсловия);
		
		Если ТипУсловия = ТипУсловияПростое() Тогда //простое Если..Иначе
			ВозможнаяКоординатаX   = ВозможноеЗначениеКоординатыXВданномРяду(МатрицаЭлементов,ТекКоординатаВМатрицеY-1);
			ТекКоординатаВМатрицеX = Макс(ТекКоординатаВМатрицеX,ВозможнаяКоординатаX);
			
			РасширитьМатрицуЭлементов(МатрицаЭлементов,ТекКоординатаВМатрицеX,ТекКоординатаВМатрицеY);
			МатрицаЭлементов[ТекКоординатаВМатрицеY-1][ТекКоординатаВМатрицеX-1] = СтруктураЭлемента;
			
			ВеткиУсловия  = ВеткиУсловия(СтрокаДерева);
			
			ОсновнаяВетка = ВеткиУсловия[0];
			СтруктураЭлемента.Вставить("ЗначениеУсловия",ОсновнаяВетка.ЗначениеУсловия);
			Если ОсновнаяВетка.Строки.Количество() > 0 Тогда
				ПерваяСтрокаСНеПустымЭлементом = ОсновнаяВетка.Строки[0];
				Если ТипЭлементаНеИмеетОтображения(ПерваяСтрокаСНеПустымЭлементом.ТипЭлемента) Тогда
					ПерваяСтрокаСНеПустымЭлементом = СледующаяСтрокаДерева(ПерваяСтрокаСНеПустымЭлементом);
				КонецЕсли;	 
				СтруктураЭлемента.Вставить("СоединениеTrue",ПерваяСтрокаСНеПустымЭлементом.ИдСтрокиДерева);
			Иначе	
				СледующаяСтрока = СледующаяСтрокаДерева(СтрокаДерева);
				СтруктураЭлемента.Вставить("СоединениеTrue",СледующаяСтрока.ИдСтрокиДерева);
			КонецЕсли;	 
			
			ВеткаИначе = Неопределено;
			Если ВеткиУсловия.Количество() = 2 Тогда
				ВеткаИначе = ВеткиУсловия[1];
				Если ВеткаИначе.Строки.Количество() > 0 Тогда
					ПерваяСтрокаСНеПустымЭлементом = ВеткаИначе.Строки[0];
					Если ТипЭлементаНеИмеетОтображения(ПерваяСтрокаСНеПустымЭлементом.ТипЭлемента) Тогда
						ПерваяСтрокаСНеПустымЭлементом = СледующаяСтрокаДерева(ПерваяСтрокаСНеПустымЭлементом);
					КонецЕсли;	 
					СтруктураЭлемента.Вставить("СоединениеFalse",ПерваяСтрокаСНеПустымЭлементом.ИдСтрокиДерева);
				КонецЕсли;	
			КонецЕсли;	 
			
			Если ВеткаИначе = Неопределено Тогда
				СледующаяСтрока = СледующаяСтрокаДерева(СтрокаДерева);
				Если СледующаяСтрока <> Неопределено Тогда
					СтруктураЭлемента.Вставить("СоединениеFalse",СледующаяСтрока.ИдСтрокиДерева);
				КонецЕсли;	 
			КонецЕсли;	 
			
			КординатаУсловияX = ТекКоординатаВМатрицеX;
			КординатаУсловияY = ТекКоординатаВМатрицеY;
			
			КординатаВеткиX = КординатаУсловияX;
			КординатаВеткиY = КординатаУсловияY;
			
			СмещениеВправо = КоличествоИсполняемыхШаговВВетке(ОсновнаяВетка);
			
			МассивЭлементовМатрицы = Новый Массив;
			УложитьВеткуУсловия(МатрицаЭлементов,ОсновнаяВетка,КординатаВеткиX+1,КординатаВеткиY,МассивЭлементовМатрицы);
			Если МассивЭлементовМатрицы.Количество() > 0 Тогда
				ПоследнийЭлементВетки = МассивЭлементовМатрицы[МассивЭлементовМатрицы.Количество()-1];
				
				СледующаяСтрока = СледующаяСтрокаДерева(СтрокаДерева);
				Если СледующаяСтрока <> Неопределено Тогда
					Если (ПоследнийЭлементВетки.ТипЭлемента <> ТипЭлементаУсловиеПрепроцессор())
						и (ПоследнийЭлементВетки.ТипЭлемента <> ТипЭлементаУсловие())
						и (ПоследнийЭлементВетки.ТипЭлемента <> ТипЭлементаУсловиеEng())
						и (ПоследнийЭлементВетки.ТипЭлемента <> ТипЭлементаЦикл())
						и (ПоследнийЭлементВетки.ТипЭлемента <> ТипЭлементаЦиклEng())
						Тогда
						ПоследнийЭлементВетки.Вставить("НадоСоединитьС",СледующаяСтрока.ИдСтрокиДерева);
					КонецЕсли;	 
				КонецЕсли;	 
			КонецЕсли;	 
			
			Если ВеткаИначе <> Неопределено Тогда
				СмещениеВеткиИначе = КоличествоИсполняемыхШаговВВетке(ВеткаИначе);
				Если СмещениеВправо < СмещениеВеткиИначе Тогда
					СмещениеВправо = СмещениеВеткиИначе;
				КонецЕсли;	 
				
				КординатаВеткиX = КординатаУсловияX;
				МассивЭлементовМатрицы = Новый Массив;
				
				КординатаВеткиY = МатрицаЭлементов.Количество();
				УложитьВеткуУсловия(МатрицаЭлементов,ВеткаИначе,КординатаВеткиX+1,КординатаВеткиY+1,МассивЭлементовМатрицы);
				
				Если МассивЭлементовМатрицы.Количество() > 0 Тогда
					ПоследнийЭлементВетки = МассивЭлементовМатрицы[МассивЭлементовМатрицы.Количество()-1];
					
					СледующаяСтрока = СледующаяСтрокаДерева(СтрокаДерева);
					Если СледующаяСтрока <> Неопределено Тогда
						Если (ПоследнийЭлементВетки.ТипЭлемента <> ТипЭлементаУсловиеПрепроцессор())
							и (ПоследнийЭлементВетки.ТипЭлемента <> ТипЭлементаУсловие())
							и (ПоследнийЭлементВетки.ТипЭлемента <> ТипЭлементаУсловиеEng())
							и (ПоследнийЭлементВетки.ТипЭлемента <> ТипЭлементаЦикл())
							и (ПоследнийЭлементВетки.ТипЭлемента <> ТипЭлементаЦиклEng())
							Тогда
							Если НЕ ПоследнийЭлементВетки.Свойство("НадоСоединитьС") Тогда
								ПоследнийЭлементВетки.Вставить("НадоСоединитьС",СледующаяСтрока.ИдСтрокиДерева);
							КонецЕсли;	 
						КонецЕсли;	 
					КонецЕсли;	 
				КонецЕсли;	 
			КонецЕсли;	 
			
			ТекКоординатаВМатрицеX = КординатаУсловияX + СмещениеВправо;
			
		Иначе
			//условие содержащее ИначеЕсли
			ВозможнаяКоординатаX   = ВозможноеЗначениеКоординатыXВданномРяду(МатрицаЭлементов,ТекКоординатаВМатрицеY-1);
			ТекКоординатаВМатрицеX = Макс(ТекКоординатаВМатрицеX,ВозможнаяКоординатаX);
			
			РасширитьМатрицуЭлементов(МатрицаЭлементов,ТекКоординатаВМатрицеX,ТекКоординатаВМатрицеY);
			МатрицаЭлементов[ТекКоординатаВМатрицеY-1][ТекКоординатаВМатрицеX-1] = СтруктураЭлемента;
			
			КординатаУсловияX = ТекКоординатаВМатрицеX;
			КординатаУсловияY = ТекКоординатаВМатрицеY;
			
			КординатаВеткиX = КординатаУсловияX;
			КординатаВеткиY = КординатаУсловияY;
			
			СмещениеВправо = 0;
			
			ВеткиУсловия  = ВеткиУсловия(СтрокаДерева);
			МассивУсловий = Новый Массив;
			
			МассивЭлементовМатрицы = Неопределено;
			
			Ном = -1;
			Для Каждого ВеткаУсловия Из ВеткиУсловия Цикл
				Ном = Ном + 1;
				
				КординатаВеткиY = КординатаВеткиY + 1;
				
				Если ВеткаУсловия.Строки.Количество() = 0 Тогда
					Продолжить;
				КонецЕсли;	 
				
				Если МассивЭлементовМатрицы <> Неопределено Тогда
					//значит МассивЭлементовМатрицы содержит элементы предыдущей ветки. Определим нижнюю границу для вставки новой ветки.
					Для Каждого ЭлементМатрицы Из МассивЭлементовМатрицы Цикл
						КординатаВеткиY = Макс(КординатаВеткиY,ЭлементМатрицы.КординатаY+1);
					КонецЦикла;	
				КонецЕсли;	 
				
				
				
				Если МассивЭлементовМатрицы = Неопределено Тогда
					МассивЭлементовМатрицы = Новый Массив;
				КонецЕсли;	 
				УложитьВеткуУсловия(МатрицаЭлементов,ВеткаУсловия,КординатаВеткиX+1,КординатаВеткиY,МассивЭлементовМатрицы);
				
				Если СмещениеВправо < ВеткаУсловия.Строки.Количество() Тогда
					СмещениеВправо = ВеткаУсловия.Строки.Количество();
				КонецЕсли;	
				
				
				СледующийЭлемент = ВеткаУсловия.Строки[0];
				
				СтруктураУсловия = Новый Структура;
				СтруктураУсловия.Вставить("НадоСоединитьС",СледующийЭлемент.ИдСтрокиДерева);
				
				Если ВеткаУсловия.ТипЭлемента = ТипЭлементаИначеПрепроцессор() Тогда
					СтруктураУсловия.Вставить("ЗначениеУсловия","Иначе");
				Иначе	
					СтруктураУсловия.Вставить("ЗначениеУсловия",ВеткаУсловия.ЗначениеУсловия);
				КонецЕсли;	 
				
				МассивУсловий.Добавить(СтруктураУсловия);  
				
				
				Если МассивЭлементовМатрицы.Количество() > 0 Тогда
					ПоследнийЭлементВетки = МассивЭлементовМатрицы[МассивЭлементовМатрицы.Количество()-1];
					
					СледующаяСтрока = СледующаяСтрокаДерева(СтрокаДерева);
					Если СледующаяСтрока <> Неопределено Тогда
						Если (ПоследнийЭлементВетки.ТипЭлемента <> ТипЭлементаУсловиеПрепроцессор())
							и (ПоследнийЭлементВетки.ТипЭлемента <> ТипЭлементаУсловие())
							и (ПоследнийЭлементВетки.ТипЭлемента <> ТипЭлементаУсловиеEng())
							и (ПоследнийЭлементВетки.ТипЭлемента <> ТипЭлементаЦикл())
							и (ПоследнийЭлементВетки.ТипЭлемента <> ТипЭлементаЦиклEng())
							Тогда
							Если НЕ ПоследнийЭлементВетки.Свойство("НадоСоединитьС") Тогда
								ПоследнийЭлементВетки.Вставить("НадоСоединитьС",СледующаяСтрока.ИдСтрокиДерева);
							КонецЕсли;	 
						КонецЕсли;	 
					КонецЕсли;	 
				КонецЕсли;	 
				
				
			КонецЦикла;	

			СтруктураЭлемента.Вставить("МассивУсловий",МассивУсловий);
			
			ТекКоординатаВМатрицеX = КординатаУсловияX + СмещениеВправо;
			
		КонецЕсли;	 
		
	ИначеЕсли (СтрокаДерева.ТипЭлемента = ТипЭлементаГруппаШагов())
		или (СтрокаДерева.ТипЭлемента = ТипЭлементаШаблонСценария()) Тогда
		ВозможнаяКоординатаX   = ВозможноеЗначениеКоординатыXВданномРяду(МатрицаЭлементов,ТекКоординатаВМатрицеY-1);
		ТекКоординатаВМатрицеX = Макс(ТекКоординатаВМатрицеX,ВозможнаяКоординатаX);
		
		РасширитьМатрицуЭлементов(МатрицаЭлементов,ТекКоординатаВМатрицеX,ТекКоординатаВМатрицеY);
		МатрицаЭлементов[ТекКоординатаВМатрицеY-1][ТекКоординатаВМатрицеX-1] = СтруктураЭлемента;
		ТекКоординатаВМатрицеX                                               = ТекКоординатаВМатрицеX + 1;
		
		СледующаяСтрока = СледующаяСтрокаДерева(СтрокаДерева);
		Если СледующаяСтрока <> Неопределено Тогда
			СтруктураЭлемента.Вставить("НадоСоединитьС",СледующаяСтрока.ИдСтрокиДерева);
		КонецЕсли;	
		
		СтруктураПодчиненнойСхемы     = ГрафическаяСхемаПоДеревуСхемы(СтрокаДерева);
		СтрокаДерева.ПодчиненнаяСхема = СтруктураПодчиненнойСхемы.Схема;
	ИначеЕсли (СтрокаДерева.ТипЭлемента = ТипЭлементаОкончаниеСхемы()) Тогда
		ТекКоординатаВМатрицеX = МатрицаЭлементов.Колонки.Количество() + 1;
		ВозможнаяКоординатаX   = ВозможноеЗначениеКоординатыXВданномРяду(МатрицаЭлементов,ТекКоординатаВМатрицеY-1);
		ТекКоординатаВМатрицеX = Макс(ТекКоординатаВМатрицеX,ВозможнаяКоординатаX);
		
		РасширитьМатрицуЭлементов(МатрицаЭлементов,ТекКоординатаВМатрицеX,ТекКоординатаВМатрицеY);
		МатрицаЭлементов[ТекКоординатаВМатрицеY-1][ТекКоординатаВМатрицеX-1] = СтруктураЭлемента;
	ИначеЕсли СтрокаДерева.ТипЭлемента = ТипЭлементаМетка() Тогда
		СтруктураЭлемента.Вставить("ОтображаетсяКакЭлемент",Ложь);
	ИначеЕсли СтрокаДерева.ТипЭлемента = ТипЭлементаПерейти() Тогда
		СтруктураЭлемента.Вставить("ОтображаетсяКакЭлемент",Ложь);
	ИначеЕсли СтрокаДерева.ТипЭлемента = ТипЭлементаПустаяСтрока() Тогда
		СтруктураЭлемента.Вставить("ОтображаетсяКакЭлемент",Ложь);
	ИначеЕсли СтрокаДерева.ТипЭлемента = ТипЭлементаКомментарий() Тогда
		СтруктураЭлемента.Вставить("ОтображаетсяКакЭлемент",Ложь);
	ИначеЕсли СтрокаДерева.ТипЭлемента = ТипЭлементаБлочныйКомментарий() Тогда
		СтруктураЭлемента.Вставить("ОтображаетсяКакЭлемент",Ложь);
	ИначеЕсли СтрокаДерева.ТипЭлемента = ТипЭлементаТаблица() Тогда
		СтруктураЭлемента.Вставить("ОтображаетсяКакЭлемент",Ложь);
	ИначеЕсли СтрокаДерева.ТипЭлемента = ТипЭлементаБлочныйКомментарийНачало() Тогда
		СтруктураЭлемента.Вставить("ОтображаетсяКакЭлемент",Ложь);
	ИначеЕсли СтрокаДерева.ТипЭлемента = ТипЭлементаБлочныйКомментарийОкончание() Тогда
		СтруктураЭлемента.Вставить("ОтображаетсяКакЭлемент",Ложь);
	Иначе	
		РасширитьМатрицуЭлементов(МатрицаЭлементов,ТекКоординатаВМатрицеX-1,ТекКоординатаВМатрицеY);//чтобы добавилась новая строка если это необходимо
		
		ВозможнаяКоординатаX   = ВозможноеЗначениеКоординатыXВданномРяду(МатрицаЭлементов,ТекКоординатаВМатрицеY-1);
		ТекКоординатаВМатрицеX = Макс(ТекКоординатаВМатрицеX,ВозможнаяКоординатаX);
		
		РасширитьМатрицуЭлементов(МатрицаЭлементов,ТекКоординатаВМатрицеX,ТекКоординатаВМатрицеY);
		МатрицаЭлементов[ТекКоординатаВМатрицеY-1][ТекКоординатаВМатрицеX-1] = СтруктураЭлемента;
		ТекКоординатаВМатрицеX                                               = ТекКоординатаВМатрицеX + 1;
		
		Если ЗначениеЗаполнено(СтрокаДерева.ПерейтиКМетке) Тогда
			ИдСтрокиМетки = НайтиМеткуВДереве(СтрокаДерева,СтрокаДерева.ПерейтиКМетке);
			Если ИдСтрокиМетки <> Неопределено Тогда
				СтруктураЭлемента.Вставить("НадоСоединитьС",ИдСтрокиМетки);
			КонецЕсли;	 
		Иначе	
			СледующаяСтрока = СледующаяСтрокаДерева(СтрокаДерева);
			Если СледующаяСтрока <> Неопределено Тогда
				Если СледующаяСтрока.ТипЭлемента = ТипЭлементаСценарий() Тогда
					Если СледующаяСтрока.Строки.Количество() > 0 Тогда
						СтруктураЭлемента.Вставить("НадоСоединитьС",СледующаяСтрока.Строки[0].ИдСтрокиДерева);
					КонецЕсли;	 
				ИначеЕсли СледующаяСтрока.ТипЭлемента = ТипЭлементаКонтекст() Тогда
					Если СледующаяСтрока.Строки.Количество() > 0 Тогда
						СтруктураЭлемента.Вставить("НадоСоединитьС",СледующаяСтрока.Строки[0].ИдСтрокиДерева);
					КонецЕсли;	 
				Иначе	
					СтруктураЭлемента.Вставить("НадоСоединитьС",СледующаяСтрока.ИдСтрокиДерева);
				КонецЕсли;	 
			КонецЕсли;	 
		КонецЕсли;	 
		
	КонецЕсли;	 
	
	Возврат СтруктураЭлемента;
КонецФункции

// Проверяет является ли данный элемент графической схемы условием
Функция ЭтоЭлементУсловие(ЭлементСхемы)
	Если Найти(ЭлементСхемы.itemCode,"Условие") > 0 Тогда
		Возврат Истина;
	КонецЕсли;	 
	
	Возврат Ложь;
КонецФункции	

// Проверяет является ли данный элемент графической схемы условием
Функция ЭтоЭлементУсловиеEng(ЭлементСхемы)
	Если Найти(ЭлементСхемы.itemCode,"Condition") > 0 Тогда
		Возврат Истина;
	КонецЕсли;	 
	
	Возврат Ложь;
КонецФункции	

// Проверяет является ли данный элемент графической схемы условием
Функция ЭтоЭлементЦикл(ЭлементСхемы)
	Если Найти(Лев(ЭлементСхемы.itemCode,4),"Цикл") > 0 Тогда
		Возврат Истина;
	КонецЕсли;	 
	
	Возврат Ложь;
КонецФункции	

// Проверяет является ли данный элемент графической схемы условием
Функция ЭтоЭлементЦиклEng(ЭлементСхемы)
	Если Найти(Лев(ЭлементСхемы.itemCode,2),"Do") > 0 Тогда
		Возврат Истина;
	КонецЕсли;	 
	
	Возврат Ложь;
КонецФункции	

// Проверяет является ли данный элемент графической схемы ветвлением
Функция ЭтоЭлементВетвление(ЭлементСхемы)
	Если Найти(ЭлементСхемы.itemCode,"Ветвление") > 0 Тогда
		Возврат Истина;
	КонецЕсли;	 
	
	Возврат Ложь;
КонецФункции	

// // Проверяет является ли данный элемент графической схемы действием
Функция ЭтоЭлементДействие(ЭлементСхемы)
	Если Найти(ЭлементСхемы.itemCode,"Действие") > 0 Тогда
		Возврат Истина;
	КонецЕсли;	 
	
	Возврат Ложь;
КонецФункции	

// Проверяет является ли данный элемент графической схемы группой шагов
Функция ЭтоЭлементГруппаШагов(ЭлементСхемы)
	Если Найти(ЭлементСхемы.itemCode,"ВложенныйПроцесс") > 0 Тогда
		Возврат Истина;
	КонецЕсли;	 
	
	Возврат Ложь;
КонецФункции	

// Проверяет является ли данный элемент графической схемы шаблоном сценария
Функция ЭтоЭлементШаблонСценария(ЭлементСхемы)
	Если Найти(ЭлементСхемы.itemCode,"ШаблонСценария") > 0 Тогда
		Возврат Истина;
	КонецЕсли;	 
	
	Возврат Ложь;
КонецФункции	

// Проверяет является ли данный элемент графической схемы началом схемы
Функция ЭтоЭлементСтарт(ЭлементСхемы)
	Если Найти(ЭлементСхемы.itemCode,"Старт") > 0 Тогда
		Возврат Истина;
	КонецЕсли;	 
	
	Возврат Ложь;
КонецФункции	

// Проверяет является ли данный элемент графической схемы окончанием схемы
Функция ЭтоЭлементСтоп(ЭлементСхемы)
	Если Найти(ЭлементСхемы.itemCode,"Стоп") > 0 Тогда
		Возврат Истина;
	КонецЕсли;	 
	
	Возврат Ложь;
КонецФункции	

// Делает перерасчет координат элемента
Процедура ПересчитатьМассивPointУЭлемента(ЭлементСхемы,МассивPoint)
	Ширина = ЭлементСхемы.RectRight  - ЭлементСхемы.RectLeft;
	Высота = ЭлементСхемы.rectBottom - ЭлементСхемы.rectTop;
	
	Если ЭлементСхемы.point.Количество() > 0 Тогда
		Если ЭтоЭлементУсловие(ЭлементСхемы) или ЭтоЭлементУсловиеEng(ЭлементСхемы) 
			или ЭтоЭлементЦикл(ЭлементСхемы) или ЭтоЭлементЦиклEng(ЭлементСхемы) 
			Тогда
			Ном = -1;
			Для Каждого ДанныеPoint Из МассивPoint Цикл
				Ном = Ном + 1;
				ЭлементСхемы.point[Ном].x = ЭлементСхемы.RectLeft - ДанныеPoint.OffsetX;
				ЭлементСхемы.point[Ном].y = ЭлементСхемы.RectTop  - ДанныеPoint.OffsetY;
			КонецЦикла;	
		Иначе	
			ЭлементСхемы.point[0].x = ЭлементСхемы.RectLeft;
			ЭлементСхемы.point[0].y = ЭлементСхемы.RectTop;
			
			ЭлементСхемы.point[1].x = ЭлементСхемы.RectLeft + Ширина - 1;
			ЭлементСхемы.point[1].y = ЭлементСхемы.RectTop;
			
			ЭлементСхемы.point[2].x = ЭлементСхемы.RectLeft + Ширина - 1;
			ЭлементСхемы.point[2].y = ЭлементСхемы.RectTop  + Высота - 1;
			
			ЭлементСхемы.point[3].x = ЭлементСхемы.RectLeft;
			ЭлементСхемы.point[3].y = ЭлементСхемы.RectTop  + Высота - 1;
		КонецЕсли;	 
	КонецЕсли;	 
КонецПроцедуры

// Устанавливает координаты элемента схемы
Процедура УстановитьКоординатыЭлементаСхемы(ПозицияX,ПозицияY,ЭлементСхемы)
	Ширина = ЭлементСхемы.RectRight  - ЭлементСхемы.RectLeft;
	Высота = ЭлементСхемы.rectBottom - ЭлементСхемы.rectTop;
	
	МассивPoint = Новый Массив;
	Для Каждого Point Из ЭлементСхемы.point Цикл
		Структура = Новый Структура;
		Структура.Вставить("OffsetX",ЭлементСхемы.RectLeft - Point.x);
		Структура.Вставить("OffsetY",ЭлементСхемы.RectTop  - Point.y);
		
		МассивPoint.Добавить(Структура);
	КонецЦикла;	
	
	ЭлементСхемы.rectLeft   = ПозицияX;
	ЭлементСхемы.rectTop    = ПозицияY;
	ЭлементСхемы.rectRight  = ЭлементСхемы.rectLeft  + Ширина;
	ЭлементСхемы.rectBottom = ЭлементСхемы.rectTop   + Высота;
	
	ПересчитатьМассивPointУЭлемента(ЭлементСхемы,МассивPoint);
КонецПроцедуры

// Вычисляет правую координату у элементов схемы в данной колонке матрицы
Функция ПраваяГраницаКолонкиЭлементов(МатрицаЭлементов,X)
	ПраваяГраница = 0;
	Для Y = 0 По МатрицаЭлементов.Количество()-1 Цикл
		СтруктураЭлемента = МатрицаЭлементов[Y][X];
		Если СтруктураЭлемента = Неопределено Тогда
			Продолжить;
		КонецЕсли;	 
		
		Если СтруктураЭлемента.Свойство("ЭлементСхемы") Тогда
			Если ПраваяГраница < СтруктураЭлемента.ЭлементСхемы.rectRight Тогда
				ПраваяГраница = СтруктураЭлемента.ЭлементСхемы.rectRight;
			КонецЕсли;	 
		КонецЕсли;	 
	КонецЦикла;	
	
	Возврат ПраваяГраница;
КонецФункции	

//Функция возвращает нужный элемент управления
Функция ФигураСоединениеПоТипуУправления(ГрафическаяСхемаXDTO,ТипСоединения)
	Если ТипСоединения = Перечисления.ТипСоединенияBPMN.Управление Тогда
		Стрелка     = СтандартныйЭлементСхемыИзМакета(ГрафическаяСхемаXDTO,"ЭлементСхемыУправление","Управление");
	Иначе
		ВызватьИсключение НСтр("ru = 'Не определен тип соединения.'");
	КонецЕсли;	 
	
	Возврат Стрелка;
КонецФункции	

// Возвращает массив допустимых исходящих портов элемента схемы
Функция ДопустимыйМассивПортовFrom(ЭлементСхемы,ВидСоединения)
	Массив = Новый Массив;
	
	Если ЭтоЭлементУсловие(ЭлементСхемы) или ЭтоЭлементУсловиеEng(ЭлементСхемы) 
		или ЭтоЭлементЦикл(ЭлементСхемы) или ЭтоЭлементЦиклEng(ЭлементСхемы) 
		Тогда
		Если ВидСоединения = "УсловиеВеткаFalse" Тогда
			Массив.Добавить(ЭлементСхемы.falsePortIndex);
		Иначе	
			Массив.Добавить(ЭлементСхемы.truePortIndex);
		КонецЕсли;	 
	Иначе	
		//для Действия
		Массив.Добавить(2);
		Массив.Добавить(3);
		Массив.Добавить(4);
	КонецЕсли;	 
	
	Возврат Массив;
КонецФункции	

// Возвращает массив допустимых входящих портов элемента схемы
Функция ДопустимыйМассивПортовTo(ЭлементСхемы,ВидСоединения)
	Массив = Новый Массив;
	
	//для Действия
	Массив.Добавить(1);
	Массив.Добавить(2);
	Массив.Добавить(4);
	
	Возврат Массив;
КонецФункции	

// Возвращает массив возможных координат портов элемента схемы
Функция МассивВозможныхКоординатТочек(ЭлементСхемы,ДопустимыйМассивПортов);
	МассивКоординатТочек = Новый Массив;
	
	Ширина = ЭлементСхемы.RectRight  - ЭлементСхемы.RectLeft;
	Высота = ЭлементСхемы.RectBottom - ЭлементСхемы.RectTop;
	
	Для Каждого Порт Из ДопустимыйМассивПортов Цикл
		Если Порт = 1 Тогда // самый левый
			x = ЭлементСхемы.RectLeft;
			y = ЭлементСхемы.RectTop + Окр(Высота/2);
			
		ИначеЕсли Порт = 2 Тогда // самый верхний
			x = ЭлементСхемы.RectLeft + Окр(Ширина/2);
			y = ЭлементСхемы.RectTop;
			
		ИначеЕсли Порт = 3 Тогда // самый правый
			x = ЭлементСхемы.RectLeft + Ширина;
			y = ЭлементСхемы.RectTop + Окр(Высота/2);
			
		ИначеЕсли Порт = 4 Тогда // самый нижний
			x = ЭлементСхемы.RectLeft + Окр(Ширина/2);
			y = ЭлементСхемы.RectBottom;
		КонецЕсли;	 
		
		МассивКоординатТочек.Добавить(Новый Структура("x,y",x,y));
	КонецЦикла;	
	
	Возврат МассивКоординатТочек;
КонецФункции	

// Вычисляет расстояние между точками
Функция РасстояниеМеждуТочками(Точка1,Точка2)
	Возврат Sqrt((Точка1.x-Точка2.x)*(Точка1.x-Точка2.x) + (Точка1.y-Точка2.y)*(Точка1.y-Точка2.y));
КонецФункции	

// Вычисляет лучший способ соеденить две точки вычисляя наименьшее растояние
Функция СоединениеЭлементов(ЭлементСхемыОт,ЭлементСхемыК,ВидСоединения)
	ДопустимыйМассивПортовFrom = ДопустимыйМассивПортовFrom(ЭлементСхемыОт,ВидСоединения);
	ДопустимыйМассивПортовTo  = ДопустимыйМассивПортовTo(ЭлементСхемыК,ВидСоединения);
	
	Если ВидСоединения = "СложноеУсловие" Тогда
		ДопустимыйМассивПортовTo = Новый Массив;
		ДопустимыйМассивПортовTo.Добавить(1);
	ИначеЕсли ВидСоединения = "УсловиеВеткаFalse" Тогда
		Если ЭлементСхемыОт.RectTop >= ЭлементСхемыК.RectTop Тогда
			//они в одном ряду или условие ниже
			ДопустимыйМассивПортовTo = Новый Массив;
			ДопустимыйМассивПортовTo.Добавить(4);
		КонецЕсли;	 
	ИначеЕсли ЭтоЭлементСтоп(ЭлементСхемыК) Тогда 	
		Если ЭлементСхемыОт.RectTop > ЭлементСхемыК.RectTop Тогда
			//идёт соединение к стоп - снизу
			ДопустимыйМассивПортовTo = Новый Массив;
			ДопустимыйМассивПортовTo.Добавить(4);
			
			//идёт соединение от элемента  - справа
			ДопустимыйМассивПортовFrom = Новый Массив;
			ДопустимыйМассивПортовFrom.Добавить(3);
		КонецЕсли;	 
	ИначеЕсли ЭлементСхемыОт.RectTop > ЭлементСхемыК.RectTop Тогда
		//идёт соединение снизу
		ДопустимыйМассивПортовTo = Новый Массив;
		ДопустимыйМассивПортовTo.Добавить(4);
	КонецЕсли;	 
	
	МассивКоординатТочекFrom = МассивВозможныхКоординатТочек(ЭлементСхемыОт,ДопустимыйМассивПортовFrom);
	МассивКоординатТочекTo  = МассивВозможныхКоординатТочек(ЭлементСхемыК,ДопустимыйМассивПортовTo);
	
	ТекРасстояние = 1000000000;
	
	НаименьшийИДFrom = Неопределено;
	НаименьшийИДTo   = Неопределено;
	
	ИдFrom = -1;
	Для Каждого Точка1 Из МассивКоординатТочекFrom Цикл
		ИдFrom = ИдFrom + 1;
		
		ИдTo  = -1;
		Для Каждого Точка2 Из МассивКоординатТочекTo Цикл
			ИдTo = ИдTo + 1;
			РасстояниеМеждуТочками = РасстояниеМеждуТочками(Точка1,Точка2);
			Если РасстояниеМеждуТочками < ТекРасстояние Тогда
				НаименьшийИДFrom = ИдFrom;
				НаименьшийИДTo = ИдTo;
				ТекРасстояние = РасстояниеМеждуТочками;
			КонецЕсли;	 
		КонецЦикла;	
	КонецЦикла;	
	
	Если НаименьшийИДFrom = Неопределено Тогда
		ВызватьИсключение НСтр("ru = 'Не получилось рассчитать лучший способ соединения точек.'");
	КонецЕсли;	 
	
	Структура = Новый Структура;
	Структура.Вставить("portIndexFrom",ДопустимыйМассивПортовFrom[НаименьшийИДFrom]);
	Структура.Вставить("portIndexTo",ДопустимыйМассивПортовTo[НаименьшийИДTo]);
	Структура.Вставить("pointFrom",МассивКоординатТочекFrom[НаименьшийИДFrom]);
	Структура.Вставить("pointTo",МассивКоординатТочекTo[НаименьшийИДTo]);
	
	Возврат Структура;
КонецФункции	

//Процедура соединяет первую фигуру со второй стрелкой нужного типа
Процедура СоединитьФигуры(ГрафическаяСхемаXDTO,ЭлементСхемы1,ЭлементСхемы2,ТипСоединения,ВидСоединения)
	Стрелка = ФигураСоединениеПоТипуУправления(ГрафическаяСхемаXDTO,ТипСоединения);
	
	СвойстваСоединения        = СоединениеЭлементов(ЭлементСхемы1,ЭлементСхемы2,ВидСоединения);
	
	Стрелка.connectFromItemId = ЭлементСхемы1.ItemID;
	Стрелка.connectToItemId   = ЭлементСхемы2.ItemID;
	Стрелка.portIndexFrom     = СвойстваСоединения.portIndexFrom; 
	Стрелка.portIndexTo       = СвойстваСоединения.portIndexTo;
	
	//обычное соединение
	//надо явно указать координаты стрелки
	Стрелка.point[0].x = СвойстваСоединения.pointFrom.x;
	Стрелка.point[0].y = СвойстваСоединения.pointFrom.y;
	Стрелка.point[3].x = СвойстваСоединения.pointTo.x;
	Стрелка.point[3].y = СвойстваСоединения.pointTo.y;
	
	Если ВидСоединения = "УсловиеВеткаFalse" Тогда
		Если ЭлементСхемы1.RectTop >= ЭлементСхемы2.RectTop Тогда
			//они в одном ряду
			Стрелка.point[1].x = Стрелка.point[0].x;
			Стрелка.point[1].y = Стрелка.point[0].y + 20;
			
			Стрелка.point[2].x = Стрелка.point[3].x;
			Стрелка.point[2].y = Стрелка.point[0].y + 20;
		Иначе	
			Стрелка.point.Удалить(1);
			
			Стрелка.point[1].x = Стрелка.point[0].x;
			Стрелка.point[1].y = Стрелка.point[2].y;
		КонецЕсли;	 
	ИначеЕсли (ЭтоЭлементСтоп(ЭлементСхемы2)) И (ЭлементСхемы1.RectTop > ЭлементСхемы2.RectTop) Тогда
		Стрелка.point.Удалить(1);
		Стрелка.point[1].x = Стрелка.point[2].x;
		Стрелка.point[1].y = Стрелка.point[0].y;
	Иначе	
		Если (ЭлементСхемы1.RectTop > ЭлементСхемы2.RectTop) Тогда
			//надо сделать соединение снизу
			Если ЭлементСхемы1.RectLeft = ЭлементСхемы2.RectLeft Тогда
				Стрелка.point.Удалить(1);
				Стрелка.point[1].x = Стрелка.point[2].x;
				Стрелка.point[1].y = Стрелка.point[0].y;
			ИначеЕсли ЭлементСхемы1.RectLeft < ЭлементСхемы2.RectLeft Тогда
				Стрелка.point.Удалить(1);
				Стрелка.point[1].x = Стрелка.point[2].x;
				Стрелка.point[1].y = Стрелка.point[0].y;
			Иначе	
				Стрелка.point[1].x = Стрелка.point[0].x;
				Стрелка.point[1].y = Стрелка.point[0].y - 20;
				
				//второй поворот стрелки
				Стрелка.point[2].x = Стрелка.point[3].x;
				Стрелка.point[2].y = Стрелка.point[1].y;
			КонецЕсли;	 
		Иначе	
			//первый поворот стрелки
			Стрелка.point[1].x = Стрелка.point[0].x + Окр((Стрелка.point[3].x - Стрелка.point[0].x)/2);
			Стрелка.point[1].y = Стрелка.point[0].y;
			
			//второй поворот стрелки
			Стрелка.point[2].x = Стрелка.point[1].x;
			Стрелка.point[2].y = Стрелка.point[3].y;
		КонецЕсли;	 
		
	КонецЕсли;	 
	
	Если ВидСоединения = "УсловиеВеткаFalse" Тогда
		Стрелка.itemTitle.item[0].content = "Нет";
	ИначеЕсли ВидСоединения = "УсловиеВеткаTrue" Тогда
		Стрелка.itemTitle.item[0].content = "Да";
	КонецЕсли;	 
	
	ГрафическаяСхемаXDTO.ЭлементыСхемыXDTO.Добавить(Стрелка);
КонецПроцедуры

// Соединяет элементы схемы стрелкой
Процедура СоеденитьЭлементыСхемы(ГрафическаяСхемаXDTO,ЭлементМатрицы1,ЭлементМатрицы2,ВидСоединения = "Обычное")
	Если ЭлементМатрицы1 = Неопределено Тогда
		Возврат;
	КонецЕсли;	 
	Если ЭлементМатрицы2 = Неопределено Тогда
		Возврат;
	КонецЕсли;	 
	Если Не ЭлементМатрицы1.Свойство("ЭлементСхемы") Тогда
		Возврат;
	КонецЕсли;	 
	Если Не ЭлементМатрицы2.Свойство("ЭлементСхемы") Тогда
		Возврат;
	КонецЕсли;	 
	
	Если ЭтоЭлементСтоп(ЭлементМатрицы1.ЭлементСхемы) Тогда
		Возврат;
	КонецЕсли;	
 
	СоединитьФигуры(ГрафическаяСхемаXDTO,ЭлементМатрицы1.ЭлементСхемы,ЭлементМатрицы2.ЭлементСхемы,
					Перечисления.ТипСоединенияBPMN.Управление,ВидСоединения);
	
КонецПроцедуры

// Возвращает строку таблицы ТаблицаИД по нужному ИД
Функция КоординатыЭлементаПоИД(ТаблицаИД,ИдСтрокиДерева)
	СтрТаблицаИД = ТаблицаИД.Найти(ИдСтрокиДерева,"ИдСтрокиДерева");
	Возврат СтрТаблицаИД;
КонецФункции	

// Соединяет порт элемента сложного условия с нужным элементом схемы
Процедура СоеденитьВеткуСложногоУсловия(ГрафическаяСхемаXDTO,ЭлементУсловие,ЭлементСхемы,НомерПорта,КоличествоУсловий)
	Стрелка = ФигураСоединениеПоТипуУправления(ГрафическаяСхемаXDTO,Перечисления.ТипСоединенияBPMN.Управление);
	
	СвойстваСоединения        = СоединениеЭлементов(ЭлементУсловие,ЭлементСхемы,"СложноеУсловие");
	
	Стрелка.connectFromItemId = ЭлементУсловие.ItemID;
	Стрелка.connectToItemId   = ЭлементСхемы.ItemID;
	Стрелка.portIndexFrom     = 7 + (НомерПорта-1)*2; 
	Стрелка.portIndexTo       = 1;
	
	//обычное соединение
	//надо явно указать координаты стрелки
	Стрелка.point[0].x = ЭлементУсловие.RectRight;
	Стрелка.point[0].y = ЭлементУсловие.RectBottom - (КоличествоУсловий - (НомерПорта-1))*18 + 8;
	Стрелка.point[3].x = СвойстваСоединения.pointTo.x;
	Стрелка.point[3].y = СвойстваСоединения.pointTo.y;
	
	Стрелка.point[1].x = Стрелка.point[0].x + Окр((Стрелка.point[3].x - Стрелка.point[0].x)/1.5) - (НомерПорта-1)*5;
	Стрелка.point[1].y = Стрелка.point[0].y;
	
	//второй поворот стрелки
	Стрелка.point[2].x = Стрелка.point[1].x;
	Стрелка.point[2].y = Стрелка.point[3].y;
	
	ГрафическаяСхемаXDTO.ЭлементыСхемыXDTO.Добавить(Стрелка);
КонецПроцедуры

// Соединяет элемент условия со следующим элементом схемы
Процедура СоеденитьВеткуУсловий(ГрафическаяСхемаXDTO,МатрицаЭлементов,ТаблицаИД)
	Для X = 0 По МатрицаЭлементов.Колонки.Количество()-1 Цикл
		Для Y = 0 По МатрицаЭлементов.Количество()-1 Цикл
			СтруктураЭлемента = МатрицаЭлементов[Y][X];
			Если СтруктураЭлемента = Неопределено Тогда
				Продолжить;
			КонецЕсли;	 
			
			Если СтруктураЭлемента.ТипЭлемента = ТипЭлементаУсловиеПрепроцессор()
				 или СтруктураЭлемента.ТипЭлемента = ТипЭлементаУсловие()
				 или СтруктураЭлемента.ТипЭлемента = ТипЭлементаУсловиеEng()
				 или СтруктураЭлемента.ТипЭлемента = ТипЭлементаЦикл()
				 или СтруктураЭлемента.ТипЭлемента = ТипЭлементаЦиклEng()
				 Тогда
				Если СтруктураЭлемента.ТипУсловия = ТипУсловияПростое()  Тогда
					Если СтруктураЭлемента.Свойство("СоединениеTrue") Тогда
						КоординатыЭлемента = КоординатыЭлементаПоИД(ТаблицаИД,СтруктураЭлемента.СоединениеTrue);
						Если КоординатыЭлемента <> Неопределено Тогда
							СоеденитьЭлементыСхемы(ГрафическаяСхемаXDTO,МатрицаЭлементов[Y][X],
												   МатрицаЭлементов[КоординатыЭлемента.Y][КоординатыЭлемента.X],"УсловиеВеткаTrue");
						КонецЕсли;	 
					КонецЕсли;	 
					
					Если СтруктураЭлемента.Свойство("СоединениеFalse") Тогда
						КоординатыЭлемента = КоординатыЭлементаПоИД(ТаблицаИД,СтруктураЭлемента.СоединениеFalse);
						Если КоординатыЭлемента <> Неопределено Тогда
							СоеденитьЭлементыСхемы(ГрафическаяСхемаXDTO,МатрицаЭлементов[Y][X],
												   МатрицаЭлементов[КоординатыЭлемента.Y][КоординатыЭлемента.X],"УсловиеВеткаFalse");
						КонецЕсли;	 
					КонецЕсли;	 
				Иначе
					//сложное
					НомерПорта        = 0;
					КоличествоУсловий = СтруктураЭлемента.МассивУсловий.Количество();
					Для Каждого Условие Из СтруктураЭлемента.МассивУсловий Цикл
						НомерПорта = НомерПорта + 1;
						КоординатыЭлемента = КоординатыЭлементаПоИД(ТаблицаИД,Условие.НадоСоединитьС);
						Если КоординатыЭлемента <> Неопределено Тогда
							СоеденитьВеткуСложногоУсловия(ГрафическаяСхемаXDTO,МатрицаЭлементов[Y][X].ЭлементСхемы,
							                              МатрицаЭлементов[КоординатыЭлемента.Y][КоординатыЭлемента.X].ЭлементСхемы,
														  НомерПорта,КоличествоУсловий);
						КонецЕсли;	 
					КонецЦикла;	
				КонецЕсли;	 
			КонецЕсли;	 
		КонецЦикла;	
	КонецЦикла;	
КонецПроцедуры

// Возвращает служебную таблицу координат элементов
Функция ТаблицаИД(МатрицаЭлементов)
	ТаблицаИД = Новый ТаблицаЗначений;
	ТаблицаИД.Колонки.Добавить("X");
	ТаблицаИД.Колонки.Добавить("Y");
	ТаблицаИД.Колонки.Добавить("ИдСтрокиДерева");
	
	Для X = 0 По МатрицаЭлементов.Колонки.Количество()-1 Цикл
		Для Y = 0 По МатрицаЭлементов.Количество()-1 Цикл
			СтруктураЭлемента = МатрицаЭлементов[Y][X];
			Если СтруктураЭлемента = Неопределено Тогда
				Продолжить;
			КонецЕсли;	
			
			СтрТаблицаИД = ТаблицаИД.Добавить();
			СтрТаблицаИД.X = X;
			СтрТаблицаИД.Y = Y;
			СтрТаблицаИД.ИдСтрокиДерева = СтруктураЭлемента.ИдСтрокиДерева;
		КонецЦикла;
	КонецЦикла;
	
	Возврат ТаблицаИД;
КонецФункции	

// Выполняет соединение стрелкой элементов схемы
Процедура СоеденитьОставшиесяЭлементы(ГрафическаяСхемаXDTO,МатрицаЭлементов,ТаблицаИД)
	Для X = 0 По МатрицаЭлементов.Колонки.Количество()-1 Цикл
		Для Y = 0 По МатрицаЭлементов.Количество()-1 Цикл
			СтруктураЭлемента = МатрицаЭлементов[Y][X];
			Если СтруктураЭлемента = Неопределено Тогда
				Продолжить;
			КонецЕсли;	 
			
			Если СтруктураЭлемента.Свойство("НадоСоединитьС") Тогда
				Если СтруктураЭлемента.НадоСоединитьС < 0 Тогда
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неверно ID соедиения: %1'"),
																							  СтруктураЭлемента.НадоСоединитьС);
				КонецЕсли;	 
				
				КоординатыЭлемента = КоординатыЭлементаПоИД(ТаблицаИД,СтруктураЭлемента.НадоСоединитьС);
				Если КоординатыЭлемента <> Неопределено Тогда
					СоеденитьЭлементыСхемы(ГрафическаяСхемаXDTO,МатрицаЭлементов[Y][X],
										   МатрицаЭлементов[КоординатыЭлемента.Y][КоординатыЭлемента.X]);
				КонецЕсли;	 
			КонецЕсли;	 
		КонецЦикла;	
	КонецЦикла;	
КонецПроцедуры

// Заполняет в дереве схемы в нужной строке поле ИмяЭлемента
Процедура УстановитьВДеревоСхемыИмяЭлемента(ЭлементСхемы,СтруктураЭлемента,ДеревоСхемы)
	Если СтруктураЭлемента = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ИдСтрокиДерева = СтруктураЭлемента.ИдСтрокиДерева;
	
	СтрокаДерева = ДеревоСхемы.Строки.Найти(ИдСтрокиДерева,"ИдСтрокиДерева",Истина);
	Если СтрокаДерева = Неопределено Тогда
		ВызватьИсключение НСтр("ru = 'Не найдена строка в дереве по ""ИдСтрокиДерева"".'");
	КонецЕсли;	 
	
	СтрокаДерева.ИмяЭлемента = ЭлементСхемы.ItemCode;	
КонецПроцедуры

// Выполняет копирование объекта XDTO со всеми подчиненными объектами
Функция СкопироватьЭлементXDTO(ОбъектXDTO)
	ЗаписьХМЛ = Новый ЗаписьXML;
	ЗаписьХМЛ.УстановитьСтроку();
	ФабрикаXDTO.ЗаписатьXML(ЗаписьХМЛ, ОбъектXDTO);
	
	Стр = ЗаписьХМЛ.Закрыть();
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(Стр);
	ЧтениеXML.ПерейтиКСодержимому();
	ТипОбъектаXDTO = ФабрикаXDTO.Тип(ЧтениеXML.URIПространстваИмен,ЧтениеXML.Имя);
	КопияОбъектXDTO = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML,ТипОбъектаXDTO);	
	
	Возврат КопияОбъектXDTO;
КонецФункции	

// Добавляет элементу схемы, который отвечает за сложное ветвление нужное чисо веток
Процедура ДобавитьСложномуВетвлениюВариантов(ЭлементСхемы,КоличествоВариантов)
	ЭлементВариант = ЭлементСхемы.transition[0];
	Для Ккк = 1 По КоличествоВариантов-1 Цикл
		КопияЭлемента = СкопироватьЭлементXDTO(ЭлементВариант);
		ЭлементСхемы.transition.Добавить(КопияЭлемента);
	КонецЦикла;	
КонецПроцедуры

// Преобразует матрицу элементов в графическую схему
Процедура ПреобразоватьМатрицуВОбъектГрафическаяСхемаXDTO(ГрафическаяСхемаXDTO,МатрицаЭлементов,ДеревоСхемы)
	НачальнаяПозицияX = 40;
	НачальнаяПозицияY = 40;
	
	ОтступОтПредыдущейКолонки = 40;
	ОтступОтПредыдущегоРяда   = 40;
	ШиринаРяда                = 60;
	
	ТаблицаИД = ТаблицаИД(МатрицаЭлементов);
	
	Для X = 0 По МатрицаЭлементов.Колонки.Количество()-1 Цикл
		ПозицияY = НачальнаяПозицияY;
		
		Для Y = 0 По МатрицаЭлементов.Количество()-1 Цикл
			СтруктураЭлемента = МатрицаЭлементов[Y][X];
			Если СтруктураЭлемента = Неопределено Тогда
				ПозицияY = ПозицияY + ШиринаРяда + ОтступОтПредыдущегоРяда; 
				Продолжить;
			КонецЕсли;	 
			
			ЭлементСхемы = Неопределено;
			
			Если СтруктураЭлемента.ТипЭлемента = ТипЭлементаНачалоСхемы() Тогда
				ЭлементСхемы = СтандартныйЭлементСхемы(ГрафическаяСхемаXDTO,Перечисления.ТипыЭлементовСхемыBPMN.Старт,
														       "Старт",СтруктураЭлемента);
				ГрафическаяСхемаXDTO.ЭлементыСхемыXDTO.Добавить(ЭлементСхемы);
			ИначеЕсли СтруктураЭлемента.ТипЭлемента = ТипЭлементаОкончаниеСхемы() Тогда
				ЭлементСхемы = СтандартныйЭлементСхемы(ГрафическаяСхемаXDTO,Перечисления.ТипыЭлементовСхемыBPMN.Стоп,
															   "Стоп",СтруктураЭлемента);
				ГрафическаяСхемаXDTO.ЭлементыСхемыXDTO.Добавить(ЭлементСхемы);
			ИначеЕсли СтруктураЭлемента.ТипЭлемента = ТипЭлементаДействие() Тогда
				ЭлементСхемы = СтандартныйЭлементСхемы(ГрафическаяСхемаXDTO,Перечисления.ТипыЭлементовСхемыBPMN.Действие,
															   "Действие",СтруктураЭлемента);
				ЭлементСхемы.itemTitle.item[0].content = СтруктураЭлемента.ОписаниеЭлемента;
				ГрафическаяСхемаXDTO.ЭлементыСхемыXDTO.Добавить(ЭлементСхемы);
			ИначеЕсли СтруктураЭлемента.ТипЭлемента = ТипЭлементаЦикл()
				или СтруктураЭлемента.ТипЭлемента = ТипЭлементаЦиклEng()
				Тогда
				ЭлементСхемы = СтандартныйЭлементСхемы(ГрафическаяСхемаXDTO,Перечисления.ТипыЭлементовСхемыBPMN.Цикл,
				                                               "Цикл",СтруктураЭлемента);
				ЭлементСхемы.itemTitle.item[0].content = СтруктураЭлемента.ЗначениеУсловия;
				ГрафическаяСхемаXDTO.ЭлементыСхемыXDTO.Добавить(ЭлементСхемы);
			ИначеЕсли СтруктураЭлемента.ТипЭлемента = ТипЭлементаУсловиеПрепроцессор()
				      или СтруктураЭлемента.ТипЭлемента = ТипЭлементаУсловие()
				      или СтруктураЭлемента.ТипЭлемента = ТипЭлементаУсловиеEng()
					  Тогда
				Если СтруктураЭлемента.ТипУсловия = ТипУсловияПростое() Тогда
					ЭлементСхемы = СтандартныйЭлементСхемы(ГрафическаяСхемаXDTO,Перечисления.ТипыЭлементовСхемыBPMN.Условие,
																   "Условие",СтруктураЭлемента);
					ЭлементСхемы.itemTitle.item[0].content = СтруктураЭлемента.ЗначениеУсловия;
					ГрафическаяСхемаXDTO.ЭлементыСхемыXDTO.Добавить(ЭлементСхемы);
				Иначе	
					ЭлементСхемы = СтандартныйЭлементСхемы(ГрафическаяСхемаXDTO,Перечисления.ТипыЭлементовСхемыBPMN.Ветвление,
																   "Ветвление",СтруктураЭлемента);
					ДобавитьСложномуВетвлениюВариантов(ЭлементСхемы,СтруктураЭлемента.МассивУсловий.Количество());
					ЭлементСхемы.itemTitle.item[0].content = "";
					
					Ном = -1;
					Для Каждого Вариант Из ЭлементСхемы.transition Цикл
						Ном = Ном + 1;
						Вариант.description.item[0].content = СтруктураЭлемента.МассивУсловий[Ном].ЗначениеУсловия;
					КонецЦикла;	
					ГрафическаяСхемаXDTO.ЭлементыСхемыXDTO.Добавить(ЭлементСхемы);
				КонецЕсли;	 
			ИначеЕсли СтруктураЭлемента.ТипЭлемента = ТипЭлементаГруппаШагов() Тогда
				ЭлементСхемы = СтандартныйЭлементСхемы(ГрафическаяСхемаXDTO,Перечисления.ТипыЭлементовСхемыBPMN.ВложенныйПроцесс,
															   "ВложенныйПроцесс",СтруктураЭлемента);
				ЭлементСхемы.itemTitle.item[0].content = СтруктураЭлемента.ОписаниеЭлемента;
				ГрафическаяСхемаXDTO.ЭлементыСхемыXDTO.Добавить(ЭлементСхемы);
			ИначеЕсли СтруктураЭлемента.ТипЭлемента = ТипЭлементаСтоп() Тогда
				ЭлементСхемы = СтандартныйЭлементСхемы(ГрафическаяСхемаXDTO,Перечисления.ТипыЭлементовСхемыBPMN.Стоп,
															   "Стоп",СтруктураЭлемента);
				ЭлементСхемы.itemTitle.item[0].content = СтруктураЭлемента.ОписаниеЭлемента;
				ГрафическаяСхемаXDTO.ЭлементыСхемыXDTO.Добавить(ЭлементСхемы);
			ИначеЕсли СтруктураЭлемента.ТипЭлемента = ТипЭлементаПерейти() Тогда
				Продолжить;
			ИначеЕсли СтруктураЭлемента.ТипЭлемента = ТипЭлементаМетка() Тогда
				Продолжить;
			ИначеЕсли СтруктураЭлемента.ТипЭлемента = ТипЭлементаПустаяСтрока() Тогда
				Продолжить;
			ИначеЕсли СтруктураЭлемента.ТипЭлемента = ТипЭлементаТаблица() Тогда
				Продолжить;
			ИначеЕсли СтруктураЭлемента.ТипЭлемента = ТипЭлементаКомментарий() Тогда
				Продолжить;
			ИначеЕсли СтруктураЭлемента.ТипЭлемента = ТипЭлементаБлочныйКомментарий() Тогда
				Продолжить;
			ИначеЕсли СтруктураЭлемента.ТипЭлемента = ТипЭлементаПередачаПараметров() Тогда
				Продолжить;
			ИначеЕсли СтруктураЭлемента.ТипЭлемента = ТипЭлементаШаблонСценария() Тогда
				ЭлементСхемы = СтандартныйЭлементСхемы(ГрафическаяСхемаXDTO,Перечисления.ТипыЭлементовСхемыBPMN.ШаблонСценария,
															   "ШаблонСценария",СтруктураЭлемента);
				ЭлементСхемы.itemTitle.item[0].content = СтруктураЭлемента.ОписаниеЭлемента;
				ГрафическаяСхемаXDTO.ЭлементыСхемыXDTO.Добавить(ЭлементСхемы);
			Иначе
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не обработан ТипЭлемента схемы: %1'"),
																						  СтруктураЭлемента.ТипЭлемента);
			КонецЕсли;	 
			
			УстановитьВДеревоСхемыИмяЭлемента(ЭлементСхемы,СтруктураЭлемента,ДеревоСхемы);
			
			Если X = 0 Тогда
				ПравыйКрайПредыдущейКолонки = 0;
				ПозицияX                    = НачальнаяПозицияX;
			Иначе	
				ПравыйКрайПредыдущейКолонки = ПраваяГраницаКолонкиЭлементов(МатрицаЭлементов,X-1);
				ПозицияX                    = ПравыйКрайПредыдущейКолонки + ОтступОтПредыдущейКолонки;
			КонецЕсли;	 
			
			СтруктураЭлемента.Вставить("ЭлементСхемы",ЭлементСхемы);
			
			УстановитьКоординатыЭлементаСхемы(ПозицияX,ПозицияY,ЭлементСхемы);
			
			ПозицияY                    = ЭлементСхемы.rectBottom + ОтступОтПредыдущегоРяда; 
			Если X > 0  и Y < (МатрицаЭлементов.Количество()-1)  Тогда
				Если МатрицаЭлементов[Y+1][X-1] <> Неопределено И МатрицаЭлементов[Y+1][X-1].Свойство("ЭлементСхемы") Тогда
					//тогда берем позицию элемента слева
					ПозицияY                    = МатрицаЭлементов[Y+1][X-1].ЭлементСхемы.rectTop; 
				КонецЕсли;	 
			КонецЕсли;	 
			
		КонецЦикла;	
		
	КонецЦикла;	
	
	СоеденитьВеткуУсловий(ГрафическаяСхемаXDTO,МатрицаЭлементов,ТаблицаИД);
	СоеденитьОставшиесяЭлементы(ГрафическаяСхемаXDTO,МатрицаЭлементов,ТаблицаИД);
КонецПроцедуры

// Устанавливает значение метки и перехода по метке у строк дерева
Процедура ОбработатьМеткиИПереходыВдереве(ДеревоСхемы)
	Для Каждого СтрокаДерева Из ДеревоСхемы.Строки Цикл
		Если СтрокаДерева.ТипЭлемента = ТипЭлементаМетка() Тогда
			СледующаяСтрока = СледующаяСтрокаДерева(СтрокаДерева);
			Если СледующаяСтрока <> Неопределено Тогда
				СледующаяСтрока.ИмяМетки = СтрокаДерева.ИмяМетки;
				СтрокаДерева.ИмяМетки    = "";
			КонецЕсли;	
		КонецЕсли;	 
		
		Если СтрокаДерева.ТипЭлемента = ТипЭлементаПерейти() Тогда
			ПредыдущаяСтрока = ПредыдущаяСтрокаДерева(СтрокаДерева);
			Если ПредыдущаяСтрока <> Неопределено Тогда
				ПредыдущаяСтрока.ПерейтиКМетке = СтрокаДерева.ИмяМетки;
				СтрокаДерева.ИмяМетки          = "";
			КонецЕсли;	
		КонецЕсли;	 
		
		ОбработатьМеткиИПереходыВдереве(СтрокаДерева);
	КонецЦикла;	
КонецПроцедуры

// Возвращает матрицу элементов по внутреннему формату схемы
Функция МатрицаЭлементовПоДеревуСхемы(ГрафическаяСхемаXDTOПереданный,ДеревоСхемы)
	ОбработатьМеткиИПереходыВдереве(ДеревоСхемы);
	
	МатрицаЭлементов = СоздатьМатрицуЭлементов();
	
	ТекКоординатаВМатрицеX = 0;
	ТекКоординатаВМатрицеY = 1;
	
	Для Каждого СтрокаДерева Из ДеревоСхемы.Строки Цикл
		СтруктураЭлемента = УложитьЭлементВМатрицу(СтрокаДерева,МатрицаЭлементов,ТекКоординатаВМатрицеX,ТекКоординатаВМатрицеY,Неопределено);
	КонецЦикла;	
	
	Возврат МатрицаЭлементов;
КонецФункции

// Возвращает структуру, которая содержит графическую схему. Схема получается из объекта XDTO,
// который содержит список элементов графической схемы
Функция СхемаИзСпискаXDTO(ГрафическаяСхемаXDTO)
	Сериализатор = Новый СериализаторXDTO(ФабрикаXDTO);
	
	СтруктураВозврата = Новый Структура;
	СтруктураВозврата.Вставить("Схема",Сериализатор.ПрочитатьXDTO(ГрафическаяСхемаXDTO.ОбъектXDTOСхема));
	СтруктураВозврата.Вставить("Свойства",ГрафическаяСхемаXDTO.Свойства);
	
	Возврат СтруктураВозврата;
КонецФункции	

// Получает элемент графической схемы, чтобы потом его можно было добавить в свою графическую схему
//
// Параметры:
//  ТипЭлемента - Перечисление.ТипыЭлементовСхемыBPMN
//
// Возвращаемое значение:
//  ОбъектXDTO - в свойствах которого описаны параметры элемента графической схемы
Функция СтандартныйЭлементСхемы(ГрафическаяСхемаXDTO,ТипЭлемента,ИмяЭлемента,СтруктураЭлемента)
	Если ТипЭлемента = Перечисления.ТипыЭлементовСхемыBPMN.Старт Тогда
		Возврат СтандартныйЭлементСхемыИзМакета(ГрафическаяСхемаXDTO,"ЭлементСхемыСтарт",ИмяЭлемента,СтруктураЭлемента);
	ИначеЕсли ТипЭлемента = Перечисления.ТипыЭлементовСхемыBPMN.Действие Тогда
		Возврат СтандартныйЭлементСхемыИзМакета(ГрафическаяСхемаXDTO,"ЭлементСхемыДействие",ИмяЭлемента,СтруктураЭлемента);
	ИначеЕсли ТипЭлемента = Перечисления.ТипыЭлементовСхемыBPMN.Стоп Тогда
		Возврат СтандартныйЭлементСхемыИзМакета(ГрафическаяСхемаXDTO,"ЭлементСхемыСтоп",ИмяЭлемента,СтруктураЭлемента);
	ИначеЕсли ТипЭлемента = Перечисления.ТипыЭлементовСхемыBPMN.ГраницаТрека Тогда
		Возврат СтандартныйЭлементСхемыИзМакета(ГрафическаяСхемаXDTO,"ЭлементГраницаТрека",ИмяЭлемента,СтруктураЭлемента);
	ИначеЕсли ТипЭлемента = Перечисления.ТипыЭлементовСхемыBPMN.ЗаголовокТрека Тогда
		Возврат СтандартныйЭлементСхемыИзМакета(ГрафическаяСхемаXDTO,"ЭлементЗаголовокТрека",ИмяЭлемента,СтруктураЭлемента);
	ИначеЕсли ТипЭлемента = Перечисления.ТипыЭлементовСхемыBPMN.Условие Тогда
		Возврат СтандартныйЭлементСхемыИзМакета(ГрафическаяСхемаXDTO,"ЭлементУсловие",ИмяЭлемента,СтруктураЭлемента);
	ИначеЕсли ТипЭлемента = Перечисления.ТипыЭлементовСхемыBPMN.ВложенныйПроцесс Тогда
		Возврат СтандартныйЭлементСхемыИзМакета(ГрафическаяСхемаXDTO,"ВложенныйПроцесс",ИмяЭлемента,СтруктураЭлемента);
	ИначеЕсли ТипЭлемента = Перечисления.ТипыЭлементовСхемыBPMN.Ветвление Тогда
		Возврат СтандартныйЭлементСхемыИзМакета(ГрафическаяСхемаXDTO,"Ветвление",ИмяЭлемента,СтруктураЭлемента);
	ИначеЕсли ТипЭлемента = Перечисления.ТипыЭлементовСхемыBPMN.ШаблонСценария Тогда
		Возврат СтандартныйЭлементСхемыИзМакета(ГрафическаяСхемаXDTO,"ШаблонСценария",ИмяЭлемента,СтруктураЭлемента);
	ИначеЕсли ТипЭлемента = Перечисления.ТипыЭлементовСхемыBPMN.Цикл Тогда
		Возврат СтандартныйЭлементСхемыИзМакета(ГрафическаяСхемаXDTO,"ЭлементЦикл",ИмяЭлемента,СтруктураЭлемента);
	Иначе
		ВызватьИсключение НСтр("ru = 'Не определен тип элемента.'");
	КонецЕсли;	 
КонецФункции	

// Заполняет поля ItemID и ItemCode у элемента графической схемы
Функция УстановитьIDЭлементаСхемы(ЭлементСхемы,ItemCode,ГрафическаяСхемаXDTO)
	МаксИД = 0;
	Для Каждого Элемент Из ГрафическаяСхемаXDTO.ЭлементыСхемыXDTO Цикл
		Если МаксИД < Элемент.ItemID Тогда
			МаксИД = Элемент.ItemID;
		КонецЕсли;	 
	КонецЦикла;	
	ЭлементСхемы.ItemID   = МаксИД+1; 
	ЭлементСхемы.ItemCode = ItemCode + XMLСтрока(ЭлементСхемы.ItemID);
КонецФункции	

// Возвращает строку подсказки комментариев
Функция СтрокаПодсказкиИзКомментариев(Комментарии)
	Возврат СтрСоединить(Комментарии,Символы.ПС);
КонецФункции	

// Возвращает строку подсказки из тегов
Функция СтрокаПодсказкиИзТегов(Комментарии,Теги)
	Массив = Новый Массив;
	Если Комментарии <> Неопределено Тогда
		Для Каждого Элем Из Комментарии Цикл
			Массив.Добавить(Элем);
		КонецЦикла;	
	КонецЕсли;	 
	
	Для Каждого Элем Из Теги Цикл
		Массив.Добавить(Элем);
	КонецЦикла;	
	
	Возврат СтрСоединить(Массив,Символы.ПС);
КонецФункции	

// Возвращает элемент графической схемы, полученный из макета
Функция СтандартныйЭлементСхемыИзМакета(ГрафическаяСхемаXDTO,ИмяМакета,ИмяЭлемента,СтруктураЭлемента = Неопределено)
	Схема                        = Справочники.СценарииРаботыПользователей.ПолучитьМакет(ИмяМакета);
	ГрафическаяСхемаXDTOЭлемента = ГрафическаяСхемаXDTO(Схема);
	ЭлементСхемы                 = ГрафическаяСхемаXDTOЭлемента.ЭлементыСхемыXDTO[0];
	Если СтруктураЭлемента = Неопределено Тогда
		УстановитьIDЭлементаСхемы(ЭлементСхемы,ИмяЭлемента,ГрафическаяСхемаXDTO);
	Иначе	
		ЭлементСхемы.ItemCode = ИмяЭлемента + XMLСтрока(СтруктураЭлемента.ИдСтрокиДерева);
		ЭлементСхемы.ItemID   = СтруктураЭлемента.ИдСтрокиДерева; 
		
		Если СтруктураЭлемента.Комментарии = Неопределено Тогда
			ЭлементСхемы.tipText.item[0].content = "";
		Иначе	
			ЭлементСхемы.tipText.item[0].content = СтрокаПодсказкиИзКомментариев(СтруктураЭлемента.Комментарии);
		КонецЕсли;	 
		
		Если СтруктураЭлемента.Теги = Неопределено Тогда
			Если СтруктураЭлемента.Комментарии = Неопределено Тогда
				ЭлементСхемы.tipText.item[0].content = "";
			КонецЕсли;	 
		Иначе	
			ЭлементСхемы.tipText.item[0].content = СтрокаПодсказкиИзТегов(СтруктураЭлемента.Комментарии,СтруктураЭлемента.Теги);
		КонецЕсли;	 
	КонецЕсли;	 
	
	Возврат ЭлементСхемы;
КонецФункции

// Находит элемент Старт в графической схеме
Функция НайтиЭлементСтарт(ЭлементыСхемыXDTO)
	Для Каждого ЭлементСхемыXDTO Из ЭлементыСхемыXDTO Цикл
		Если ЭтоЭлементСтарт(ЭлементСхемыXDTO) Тогда
			Возврат ЭлементСхемыXDTO;
		КонецЕсли;	 
	КонецЦикла;	
	
	Возврат Неопределено;
КонецФункции	

// Возвращает таблицу значений, созданную на основе списка элементов графической схемы
Функция СоздатьТаблицуСхемыXDTO(ЭлементыСхемыXDTO)
	ТаблицаСхемыXDTO = Новый ТаблицаЗначений;
	ТаблицаСхемыXDTO.Колонки.Добавить("ItemCode");
	ТаблицаСхемыXDTO.Колонки.Добавить("ItemID");
	ТаблицаСхемыXDTO.Колонки.Добавить("ConnectFromItemID");
	ТаблицаСхемыXDTO.Колонки.Добавить("ConnectToItemID");
	ТаблицаСхемыXDTO.Колонки.Добавить("ЭлементСхемы");
	ТаблицаСхемыXDTO.Колонки.Добавить("PortIndexFrom");
	ТаблицаСхемыXDTO.Колонки.Добавить("PortIndexTo");
	
	Для Каждого ЭлементСхемыXDTO Из ЭлементыСхемыXDTO Цикл
		СтрТаблицаСхемыXDTO = ТаблицаСхемыXDTO.Добавить();
		ЗаполнитьЗначенияСвойств(СтрТаблицаСхемыXDTO,ЭлементСхемыXDTO);
		
		СтрТаблицаСхемыXDTO.ЭлементСхемы = ЭлементСхемыXDTO;
	КонецЦикла;	
	
	ТаблицаСхемыXDTO.Индексы.Добавить("ItemID");
	ТаблицаСхемыXDTO.Индексы.Добавить("ItemCode");
	ТаблицаСхемыXDTO.Индексы.Добавить("ConnectFromItemID");
	ТаблицаСхемыXDTO.Индексы.Добавить("ConnectToItemID");
	ТаблицаСхемыXDTO.Индексы.Добавить("PortIndexFrom");
	ТаблицаСхемыXDTO.Индексы.Добавить("PortIndexTo");
	
	Возврат ТаблицаСхемыXDTO;
КонецФункции	

// Возвращает элемент схемы, который следует за данным
Функция НайтиСледующийЭлементСхемы(ТаблицаСхемыXDTO,ItemID,port = Неопределено)
	ПараметрыОтбора = Новый Структура;
	ПараметрыОтбора.Вставить("ConnectFromItemID",ItemID);
	Если port <> Неопределено Тогда
		ПараметрыОтбора.Вставить("PortIndexFrom",port);
	КонецЕсли;	 
	
	МассивСтрок = ТаблицаСхемыXDTO.НайтиСтроки(ПараметрыОтбора);
	Если МассивСтрок.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;	 
	
	Если МассивСтрок.Количество() > 1 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Найдено больше одного соединения от ItemID ""%1"", port ""%2""'"),
																				  ItemID,port);
	КонецЕсли;	 
	
	СтрТаблицаСхемыXDTO = МассивСтрок[0];
	
	//нашли стрелку от элемента
	
	СтрТаблицаСхемыXDTO = ТаблицаСхемыXDTO.Найти(СтрТаблицаСхемыXDTO.ConnectToItemID,"ItemID");
	Если СтрТаблицаСхемыXDTO = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;	 
	
	Возврат СтрТаблицаСхемыXDTO.ЭлементСхемы;
КонецФункции	

// Возвращает массив комментариев, которые содержатся в элементе схемы
Функция ЗаполнитьКомментарииИзЭлементаГрафическойСхемы(ЭлементСхемы)
	Если ЭлементСхемы.tipText.item.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;	 
	
	ТекстПодсказки = ЭлементСхемы.tipText.item[0].content;
	Если СокрЛП(ТекстПодсказки) = "" Тогда
		Возврат Неопределено;
	КонецЕсли;	 
	
	МассивПодсказки = СтрРазделить(ТекстПодсказки,Символы.ПС);
	Массив          = Новый Массив;
	Для Каждого Элем Из МассивПодсказки Цикл
		Если Лев(СокрЛП(Элем),1) = "#" Тогда
			Массив.Добавить(Элем);
		КонецЕсли;	 
	КонецЦикла;	
	
	Возврат Массив;
КонецФункции	

// Возвращает массив тегов, которые содержатся в элементе схемы
Функция ЗаполнитьТегиИзЭлементаГрафическойСхемы(ЭлементСхемы)
	Если ЭлементСхемы.tipText.item.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;	 
	
	ТекстПодсказки = ЭлементСхемы.tipText.item[0].content;
	Если СокрЛП(ТекстПодсказки) = "" Тогда
		Возврат Неопределено;
	КонецЕсли;	 
	
	МассивПодсказки = СтрРазделить(ТекстПодсказки,Символы.ПС);
	Массив          = Новый Массив;
	Для Каждого Элем Из МассивПодсказки Цикл
		Если Лев(СокрЛП(Элем),1) = "@" Тогда
			Массив.Добавить(Элем);
		КонецЕсли;	 
	КонецЦикла;	
	
	Возврат Массив;
КонецФункции	

// Добавляет элемент в ветку дерева схемы
Процедура ДобавитьЭлементВВеткуДереваСхемы(ГрафическаяСхемаXDTO,ТаблицаСхемыXDTO,СледующийЭлемент,ДеревоСхемы,ДеревоВложенныхСхем,НашлиЭлементСтоп)
	Если ЭтоЭлементДействие(СледующийЭлемент) Тогда
		СтрокаДерева                  = ДеревоСхемы.Строки.Добавить();
		СтрокаДерева.ИмяЭлемента      = СледующийЭлемент.ItemCode;
		СтрокаДерева.ОписаниеЭлемента = СледующийЭлемент.itemTitle.item[0].content;
		СтрокаДерева.ТипЭлемента      = ТипЭлементаДействие();
		СтрокаДерева.Комментарии      = ЗаполнитьКомментарииИзЭлементаГрафическойСхемы(СледующийЭлемент);
		СтрокаДерева.Теги             = ЗаполнитьТегиИзЭлементаГрафическойСхемы(СледующийЭлемент);
		
		СледующийЭлемент = НайтиСледующийЭлементСхемы(ТаблицаСхемыXDTO,СледующийЭлемент.ItemID);
	ИначеЕсли ЭтоЭлементСтоп(СледующийЭлемент) Тогда
		СтрокаДерева                  = ДеревоСхемы.Строки.Добавить();
		СтрокаДерева.ИмяЭлемента      = СледующийЭлемент.ItemCode;
		СтрокаДерева.ОписаниеЭлемента = СледующийЭлемент.itemTitle.item[0].content;
		СтрокаДерева.ТипЭлемента      = ТипЭлементаОкончаниеСхемы();
		СтрокаДерева.Комментарии      = ЗаполнитьКомментарииИзЭлементаГрафическойСхемы(СледующийЭлемент);
		СтрокаДерева.Теги             = ЗаполнитьТегиИзЭлементаГрафическойСхемы(СледующийЭлемент);
		НашлиЭлементСтоп              = Истина;
	ИначеЕсли ЭтоЭлементГруппаШагов(СледующийЭлемент) или ЭтоЭлементШаблонСценария(СледующийЭлемент) Тогда
		СтрокаДерева                  = ДеревоСхемы.Строки.Добавить();
		СтрокаДерева.ИмяЭлемента      = СледующийЭлемент.ItemCode;
		СтрокаДерева.ОписаниеЭлемента = СледующийЭлемент.itemTitle.item[0].content;
		СтрокаДерева.ТипЭлемента      = ТипЭлементаГруппаШагов();
		СтрокаДерева.Комментарии      = ЗаполнитьКомментарииИзЭлементаГрафическойСхемы(СледующийЭлемент);
		СтрокаДерева.Теги             = ЗаполнитьТегиИзЭлементаГрафическойСхемы(СледующийЭлемент);
		
		СтрокаДеревоВложенныхСхем = ДеревоВложенныхСхем.Строки.Найти(СтрокаДерева.ИмяЭлемента,"ИмяЭлемента",Истина);
		Если СтрокаДеревоВложенныхСхем = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не найдена строка со вложенной схемой по строке дерева ""%1"" ""%2""'"),
																					  СтрокаДерева.ИмяЭлемента,СтрокаДерева.ОписаниеЭлемента);
		КонецЕсли;	 
		
		ГрафическаяСхемаXDTOВложеннойСхемы = ГрафическаяСхемаXDTO(СтрокаДеревоВложенныхСхем.ПодчиненнаяСхема);
		СтрокаДерева.ПодчиненнаяСхема      = СтрокаДеревоВложенныхСхем.ПодчиненнаяСхема;
		
		ЗаполнитьДеревоСхемыНаОснованииГрафическойСхемы(ГрафическаяСхемаXDTOВложеннойСхемы,СтрокаДерева,ДеревоВложенныхСхем);
		
		СледующийЭлемент = НайтиСледующийЭлементСхемы(ТаблицаСхемыXDTO,СледующийЭлемент.ItemID);
	ИначеЕсли ЭтоЭлементВетвление(СледующийЭлемент) Тогда
		ВызватьИсключение НСтр("ru = 'Не обработан элемент ветвление.'");
	ИначеЕсли ЭтоЭлементУсловие(СледующийЭлемент) или ЭтоЭлементУсловиеEng(СледующийЭлемент) 
		 или ЭтоЭлементЦикл(СледующийЭлемент) или ЭтоЭлементЦиклEng(СледующийЭлемент) 
		 Тогда
		ЭлементУсловие  = СледующийЭлемент;
		ЗначениеУсловия = ЭлементУсловие.itemTitle.item[0].content;
		
		СтрокаУсловие                  = ДеревоСхемы.Строки.Добавить();
		СтрокаУсловие.ИмяЭлемента      = ЭлементУсловие.ItemCode;
		СтрокаУсловие.ОписаниеЭлемента = "Если " + ЗначениеУсловия + " Тогда";
		СтрокаУсловие.ТипЭлемента      = ТипЭлементаУсловиеПрепроцессор();
		СтрокаУсловие.Комментарии      = ЗаполнитьКомментарииИзЭлементаГрафическойСхемы(ЭлементУсловие);
		СтрокаУсловие.Теги             = ЗаполнитьТегиИзЭлементаГрафическойСхемы(ЭлементУсловие);
		
		
		СтрокаУсловиеОсновнаяВетка                  = СтрокаУсловие.Строки.Добавить();
		СтрокаУсловиеОсновнаяВетка.ОписаниеЭлемента = "Если " +  ЭлементУсловие.itemTitle.item[0].content + " Тогда";
		СтрокаУсловиеОсновнаяВетка.ТипЭлемента      = ТипЭлементаНачалоУсловияПрепроцессор();
		СтрокаУсловиеОсновнаяВетка.ЗначениеУсловия  = ЗначениеУсловия;
		
		СтрокаУсловиеИначе                  = СтрокаУсловие.Строки.Добавить();
		СтрокаУсловиеИначе.ОписаниеЭлемента = ОписаниеЭлементаИначеПрепроцессор();
		СтрокаУсловиеИначе.ТипЭлемента      = ТипЭлементаИначеПрепроцессор();
		
		СтрокаКонецЕсли                  = СтрокаУсловие.Строки.Добавить();
		СтрокаКонецЕсли.ОписаниеЭлемента = ОписаниеЭлементаКонецЕслиПрепроцессор();
		СтрокаКонецЕсли.ТипЭлемента      = ТипЭлементаКонецЕслиПрепроцессор();
		
		ТаблицаЭлементовTrue   = Неопределено;
		ТаблицаЭлементовFalse  = Неопределено;
		ТочкаПересеченияItemID = НайтиТочкуПересеченияВетокУсловия(ГрафическаяСхемаXDTO.ЭлементыСхемыXDTO,
																   ТаблицаСхемыXDTO,ЭлементУсловие,
																   ТаблицаЭлементовTrue,ТаблицаЭлементовFalse);
		
		
		
		Если ТочкаПересеченияItemID <> Неопределено Тогда
			ЗаполнитьВеткуУсловияДереваДоНужногоЭлемента(ГрафическаяСхемаXDTO,ТаблицаСхемыXDTO,ЭлементУсловие,
														 СтрокаУсловиеОсновнаяВетка,ДеревоВложенныхСхем,
														 ТочкаПересеченияItemID,ЭлементУсловие.truePortIndex);
														 
			ЗаполнитьВеткуУсловияДереваДоНужногоЭлемента(ГрафическаяСхемаXDTO,ТаблицаСхемыXDTO,ЭлементУсловие,
														 СтрокаУсловиеИначе,ДеревоВложенныхСхем,
														 ТочкаПересеченияItemID,ЭлементУсловие.falsePortIndex);
			
			Если СтрокаУсловиеИначе.Строки.Количество() = 0 Тогда //значит нет ветки иначе
				СтрокаУсловие.Строки.Удалить(СтрокаУсловиеИначе);
			КонецЕсли;	 
			
			
			СледующийЭлемент = ТаблицаСхемыXDTO.Найти(ТочкаПересеченияItemID,"ItemID").ЭлементСхемы;
		Иначе
			//т.е. ветки условия не пересекаются
			НужныйItemID = ТаблицаЭлементовTrue[ТаблицаЭлементовTrue.Количество()-1].ItemID;
			ЗаполнитьВеткуУсловияДереваДоНужногоЭлемента(ГрафическаяСхемаXDTO,ТаблицаСхемыXDTO,ЭлементУсловие,
														 СтрокаУсловиеОсновнаяВетка,ДеревоВложенныхСхем,
														 НужныйItemID,ЭлементУсловие.truePortIndex);
			
			Если ТаблицаЭлементовFalse.Количество() = 0 Тогда
				СтрокаУсловие.Строки.Удалить(СтрокаУсловиеИначе);
			Иначе	
				НужныйItemID = ТаблицаЭлементовFalse[ТаблицаЭлементовFalse.Количество()-1].ItemID;
				ЗаполнитьВеткуУсловияДереваДоНужногоЭлемента(ГрафическаяСхемаXDTO,ТаблицаСхемыXDTO,ЭлементУсловие,
															 СтрокаУсловиеИначе,ДеревоВложенныхСхем,
															 НужныйItemID,ЭлементУсловие.falsePortIndex);
				
				ЭлементСтоп = ТаблицаЭлементовFalse[ТаблицаЭлементовFalse.Количество()-1].ЭлементСхемы;
				
				//добавим для ветки false элемент Стоп
				СтрокаДерева                  = СтрокаУсловиеИначе.Строки.Добавить();
				СтрокаДерева.ИмяЭлемента      = ЭлементСтоп.ItemCode;
				СтрокаДерева.ОписаниеЭлемента = ЭлементСтоп.itemTitle.item[0].content;
				СтрокаДерева.ТипЭлемента      = ТипЭлементаСтоп();
			КонецЕсли;	 
			
			СледующийЭлемент = ТаблицаЭлементовTrue[ТаблицаЭлементовTrue.Количество()-1].ЭлементСхемы; 
		КонецЕсли;	 
		
	КонецЕсли;	 
КонецПроцедуры

Функция ПараметрыGherkinИзСтрокиИПреобразоватьСтрокуДляРаботыСПараметрами(Стр,
	                                         ИзменяемыеПараметрыСценария = Неопределено,
											 КешПараметровСтроки = Неопределено)
											 
	СборщикСценариев = СборщикСценариев();
	Возврат СборщикСценариев.ПараметрыGherkinИзСтрокиИПреобразоватьСтрокуДляРаботыСПараметрами(Стр,ИзменяемыеПараметрыСценария,КешПараметровСтроки);
КонецФункции	

// Определяет параметры шагов в дереве схемы
Процедура ПараметрыШаговВДеревеСхемы(ДеревоСхемы)
	Для Каждого СтрокаДерева Из ДеревоСхемы.Строки Цикл
		Если (СтрокаДерева.ТипЭлемента = ТипЭлементаДействие())Тогда
			ОбработаннаяСтрокаПараметров              = СокрЛП(СтрокаДерева.ОписаниеЭлемента);
			СтрокаДерева.Параметры                    = ПараметрыGherkinИзСтрокиИПреобразоватьСтрокуДляРаботыСПараметрами(ОбработаннаяСтрокаПараметров);
			СтрокаДерева.ОбработаннаяСтрокаПараметров = ОбработаннаяСтрокаПараметров;
		ИначеЕсли (СтрокаДерева.ТипЭлемента = ТипЭлементаНачалоУсловияПрепроцессор())
			или (СтрокаДерева.ТипЭлемента = ТипЭлементаИначеЕслиПрепроцессор()) Тогда
			ОбработаннаяСтрокаПараметров              = СокрЛП(СтрокаДерева.ЗначениеУсловия);
			СтрокаДерева.Параметры                    = ПараметрыУсловия(ОбработаннаяСтрокаПараметров);
			СтрокаДерева.ОбработаннаяСтрокаПараметров = ОбработаннаяСтрокаПараметров;
		КонецЕсли;	 
		
		ПараметрыШаговВДеревеСхемы(СтрокаДерева);
	КонецЦикла;	
КонецПроцедуры

Функция ПараметрыУсловия(Стр,ИзменяемыеПараметрыСценария = Неопределено)
	СборщикСценариев = СборщикСценариев();
	Возврат СборщикСценариев.ПараметрыУсловия(Стр,ИзменяемыеПараметрыСценария); 
КонецФункции	


Процедура ПроставитьИдСтрокиИЗависимыеПараметрыДереваРекурсивно(Дерево,ИдСтрокиДерева)
	СборщикСценариев = СборщикСценариев();
	СборщикСценариев.ПроставитьИдСтрокиИЗависимыеПараметрыДереваРекурсивно(Дерево,ИдСтрокиДерева);
КонецПроцедуры

// Преобразует графическую схему в схему во внутреннем формате дерева значений
Процедура ЗаполнитьДеревоСхемыНаОснованииГрафическойСхемы(ГрафическаяСхемаXDTO,ДеревоСхемы,ДеревоВложенныхСхем)
	ЭлементСтарт = НайтиЭлементСтарт(ГрафическаяСхемаXDTO.ЭлементыСхемыXDTO);
	Если ЭлементСтарт = Неопределено Тогда
		ВызватьИсключение НСтр("ru = 'Не найден элемент ""Старт"".'");
	КонецЕсли;	 
	
	СтрокаДерева                  = ДеревоСхемы.Строки.Добавить();
	СтрокаДерева.ИмяЭлемента      = ЭлементСтарт.ItemCode;
	СтрокаДерева.ОписаниеЭлемента = ОписаниеЭлементаСтарт();
	СтрокаДерева.ТипЭлемента      = ТипЭлементаНачалоСхемы();
	
	ТаблицаСхемыXDTO = СоздатьТаблицуСхемыXDTO(ГрафическаяСхемаXDTO.ЭлементыСхемыXDTO);
	
	СледующийЭлемент = НайтиСледующийЭлементСхемы(ТаблицаСхемыXDTO,ЭлементСтарт.ItemID);
	ПредыдущийЭлемент = СледующийЭлемент;
	НашлиЭлементСтоп = Ложь;
	Пока Истина Цикл
		Если СледующийЭлемент = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не найден следующий элемент схемы за ""%1"" ""%2""'"),
																					  ПредыдущийЭлемент.ItemCode,
																					  ПредыдущийЭлемент.itemTitle.item[0].content);
		КонецЕсли;	 
		
		ПредыдущийЭлемент = СледующийЭлемент;
		ДобавитьЭлементВВеткуДереваСхемы(ГрафическаяСхемаXDTO,ТаблицаСхемыXDTO,СледующийЭлемент,
										 ДеревоСхемы,ДеревоВложенныхСхем,НашлиЭлементСтоп);
		Если НашлиЭлементСтоп Тогда
			Прервать;
		КонецЕсли;	 
		
	КонецЦикла;	
	
	ИдСтрокиДерева = 0;
	ПараметрыШаговВДеревеСхемы(ДеревоСхемы);
	ПроставитьИдСтрокиИЗависимыеПараметрыДереваРекурсивно(ДеревоСхемы,ИдСтрокиДерева);
КонецПроцедуры

// Заполняет ветку дерева, которая соответствует ветке условия графической схемы
Процедура ЗаполнитьВеткуУсловияДереваДоНужногоЭлемента(ГрафическаяСхемаXDTO,ТаблицаСхемыXDTO,ЭлементУсловие,ДеревоСхемы,ДеревоВложенныхСхем,ТочкаПересеченияItemID,port)
	СледующийЭлемент = НайтиСледующийЭлементСхемы(ТаблицаСхемыXDTO,ЭлементУсловие.ItemID,port);
	
	НашлиЭлементСтоп = Ложь;
	Пока Истина Цикл
		Если СледующийЭлемент.ItemID = ТочкаПересеченияItemID Тогда
			Прервать;
		КонецЕсли;	 
		
		ДобавитьЭлементВВеткуДереваСхемы(ГрафическаяСхемаXDTO,ТаблицаСхемыXDTO,СледующийЭлемент,
										 ДеревоСхемы,ДеревоВложенныхСхем,НашлиЭлементСтоп);
		Если НашлиЭлементСтоп Тогда
			Прервать;
		КонецЕсли;	 
	КонецЦикла;	
КонецПроцедуры

// Возвращает таблицу элементов по ветке условия
Функция ТаблицаЭлементовПоВеткеУсловия(ЭлементыСхемыXDTO,ТаблицаСхемыXDTO,ЭлементУсловие,port)
	ТаблицаЭлементов = Новый ТаблицаЗначений;
	ТаблицаЭлементов.Колонки.Добавить("ItemID");
	ТаблицаЭлементов.Колонки.Добавить("ItemCode");
	ТаблицаЭлементов.Колонки.Добавить("ЭлементСхемы");
	
	СледующийЭлемент                 = НайтиСледующийЭлементСхемы(ТаблицаСхемыXDTO,ЭлементУсловие.ItemID,port);
	СтрТаблицаЭлементов               = ТаблицаЭлементов.Добавить();
	СтрТаблицаЭлементов.ItemID        = СледующийЭлемент.ItemID;
	СтрТаблицаЭлементов.ItemCode      = СледующийЭлемент.ItemCode;
	СтрТаблицаЭлементов.ЭлементСхемы  = СледующийЭлемент;
	
	Пока Истина Цикл
		Если ЭтоЭлементСтоп(СледующийЭлемент) Тогда
			Прервать;
		КонецЕсли;	 
		
		Если ЭтоЭлементДействие(СледующийЭлемент) Тогда
			СледующийЭлемент = НайтиСледующийЭлементСхемы(ТаблицаСхемыXDTO,СледующийЭлемент.ItemID);
			СтрТаблицаЭлементов               = ТаблицаЭлементов.Добавить();
			СтрТаблицаЭлементов.ItemID        = СледующийЭлемент.ItemID;
			СтрТаблицаЭлементов.ItemCode      = СледующийЭлемент.ItemCode;
			СтрТаблицаЭлементов.ЭлементСхемы  = СледующийЭлемент;
		ИначеЕсли ЭтоЭлементУсловие(СледующийЭлемент) или ЭтоЭлементУсловиеEng(СледующийЭлемент) 
			или ЭтоЭлементЦикл(СледующийЭлемент) или ЭтоЭлементЦиклEng(СледующийЭлемент) 
			Тогда
			СледующийЭлемент = НайтиСледующийЭлементСхемы(ТаблицаСхемыXDTO,СледующийЭлемент.ItemID,СледующийЭлемент.truePortIndex); //идём по ветке true
			СтрТаблицаЭлементов               = ТаблицаЭлементов.Добавить();
			СтрТаблицаЭлементов.ItemID        = СледующийЭлемент.ItemID;
			СтрТаблицаЭлементов.ItemCode      = СледующийЭлемент.ItemCode;
			СтрТаблицаЭлементов.ЭлементСхемы  = СледующийЭлемент;
		Иначе
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Обнаружен неизвестный тип элемента: %1'"),
																					  СледующийЭлемент.ItemCode);
		КонецЕсли;	 
	КонецЦикла;	
	
	Возврат ТаблицаЭлементов;
КонецФункции	

// Возвращает точку пересечения веток условия
Функция НайтиТочкуПересеченияВетокУсловия(ЭлементыСхемыXDTO,ТаблицаСхемыXDTO,ЭлементУсловие,ТаблицаЭлементовTrue,ТаблицаЭлементовFalse)
	
	ТаблицаЭлементовTrue  = ТаблицаЭлементовПоВеткеУсловия(ЭлементыСхемыXDTO,ТаблицаСхемыXDTO,
																   ЭлементУсловие,ЭлементУсловие.truePortIndex);
																   
	ТаблицаЭлементовFalse = ТаблицаЭлементовПоВеткеУсловия(ЭлементыСхемыXDTO,ТаблицаСхемыXDTO,
																   ЭлементУсловие,ЭлементУсловие.falsePortIndex);
	
	Для Каждого СтрТаблицаЭлементовTrue Из ТаблицаЭлементовTrue Цикл
		СтрТаблицаЭлементовFalse = ТаблицаЭлементовFalse.Найти(СтрТаблицаЭлементовTrue.ItemID,"ItemID");
		Если СтрТаблицаЭлементовFalse <> Неопределено Тогда
			Возврат СтрТаблицаЭлементовFalse.ItemID;
		КонецЕсли;	 
	КонецЦикла;	
	
	Возврат Неопределено;
КонецФункции	

// Делает замену пробелов на символы табуляции
Процедура ЗаменитьОтступыНаСимволыТаб(Текст)
	Текст = СтрЗаменить(Текст,"        ",Символы.Таб);
КонецПроцедуры

Функция МассивПервыхСловGherkinНРег()
	СборщикСценариев = СборщикСценариев();
	Возврат СборщикСценариев.МассивПервыхСловGherkinНРег(); 
КонецФункции	

Функция СборщикСценариев()
	Возврат Обработки.СборкаТекстовСценариев.Создать();
КонецФункции	

# Область ОпределениеОписанияЭлемента

Функция ОписаниеЭлементаКонецЕслиПрепроцессор()
	Возврат "#КонецЕсли";
КонецФункции	 

Функция ОписаниеЭлементаИначеПрепроцессор()
	Возврат "#Иначе";
КонецФункции	 

Функция ОписаниеЭлементаСтарт()
	Возврат "Старт";
КонецФункции	 

#КонецОбласти

# Область ОпределениеТипаЭлемента

Функция ТипЭлементаТег()
	Возврат "Тег";
КонецФункции	 

Функция ТипЭлементаКомментарий()
	Возврат "Комментарий";
КонецФункции	 

Функция ТипЭлементаБлочныйКомментарий()
	Возврат "БлочныйКомментарий";
КонецФункции	 

Функция ТипЭлементаБлочныйКомментарийНачало()
	Возврат "БлочныйКомментарийНачало";
КонецФункции	 

Функция ТипЭлементаБлочныйКомментарийОкончание()
	Возврат "БлочныйКомментарийОкончание";
КонецФункции	 

Функция ТипЭлементаДействие()
	Возврат "Действие";
КонецФункции	 

Функция ТипЭлементаГруппаШагов()
	Возврат "ГруппаШагов";
КонецФункции	 

Функция ТипЭлементаШаблонСценария() Экспорт
	Возврат "ШаблонСценария";
КонецФункции	 

Функция ТипЭлементаНачалоСхемы()
	Возврат "НачалоСхемы";
КонецФункции	 

Функция ТипЭлементаСтоп()
	Возврат "Стоп";
КонецФункции	 

Функция ТипЭлементаОкончаниеСхемы()
	Возврат "ОкончаниеСхемы";
КонецФункции	 

Функция ТипЭлементаПередачаПараметров()
	Возврат "ПередачаПараметров";
КонецФункции	 

//условия
Функция ТипЭлементаУсловиеПрепроцессор()
	Возврат "УсловиеПрепроцессор";
КонецФункции	 

Функция ТипЭлементаЦикл()
	Возврат "Цикл";
КонецФункции	 

Функция ТипЭлементаЦиклEng()
	Возврат "Do";
КонецФункции	 

Функция ТипЭлементаУсловие()
	Возврат "Условие";
КонецФункции	 

Функция ТипЭлементаУсловиеEng()
	Возврат "Condition";
КонецФункции	 

Функция ТипЭлементаИначеПрепроцессор()
	Возврат "ИначеПрепроцессор";
КонецФункции	 

Функция ТипЭлементаИначеЕслиПрепроцессор()
	Возврат "ИначеЕслиПрепроцессор";
КонецФункции	 

Функция ТипЭлементаНачалоУсловияПрепроцессор()
	Возврат "НачалоУсловияПрепроцессор";
КонецФункции	 

Функция ТипЭлементаКонецЕслиПрепроцессор()
	Возврат "КонецЕслиПрепроцессор";
КонецФункции	 

Функция ТипЭлементаКонецЕсли()
	Возврат "КонецЕсли";
КонецФункции	 

Функция ТипЭлементаКонецЕслиEng()
	Возврат "EndIf";
КонецФункции	 

Функция ТипЭлементаКонецЦикла()
	Возврат "КонецЦикла";
КонецФункции	 

Функция ТипЭлементаКонецЦиклаEng()
	Возврат "EndDo";
КонецФункции	 

Функция ТипЭлементаЗаголовок()
	Возврат "Заголовок";
КонецФункции	 

Функция ТипЭлементаПустаяСтрока()
	Возврат "ПустаяСтрока";
КонецФункции	 

Функция ТипЭлементаСценарий()
	Возврат "Сценарий";
КонецФункции	 

Функция ТипЭлементаКонтекст()
	Возврат "Контекст";
КонецФункции	 

Функция ТипЭлементаМетка()
	Возврат "Метка";
КонецФункции	 

Функция ТипЭлементаПерейти()
	Возврат "Перейти";
КонецФункции	 

Функция ТипЭлементаТаблица()
	Возврат "Таблица";
КонецФункции	 

#КонецОбласти


# КонецОбласти

# Область ОпределениеТипаУсловия

Функция ТипУсловияСложное()
	Возврат "Сложное";
КонецФункции	 

Функция ТипУсловияПростое()
	Возврат "Простое";
КонецФункции	 

#КонецОбласти

# КонецОбласти
