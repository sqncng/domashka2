////////////////////////////////////////////////////////////////////////////////
//	Общие серверные процедуры для синхронизации с Google API
//
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

Функция ИдентификаторПриложения() Экспорт
	
	ИдентификаторПриложения = Новый Структура;
	ИдентификаторПриложения.Вставить("client_id", "");
	ИдентификаторПриложения.Вставить("client_secret", "");
	ИдентификаторПриложения.Вставить("redirect_uri", "http://127.0.0.1:23451");
	ИдентификаторПриложения.Вставить("auth_uri", "https://accounts.google.com/o/oauth2/auth");
	ИдентификаторПриложения.Вставить("token_uri", "https://accounts.google.com/o/oauth2/token");
	
	ИдентификаторПриложения.client_id = "770034366040-mub8m97u2koofluirh9d8hbq5qi6ss4o.apps.googleusercontent.com";
	ИдентификаторПриложения.client_secret = "Kq3Yhg2-a5S0_BRUx_MNzgVj";
	
	Возврат ИдентификаторПриложения;
	
КонецФункции

Функция АдресЗапросаНаПодтверждениеДоступа() Экспорт

	ИдентификаторПриложения = ИдентификаторПриложения();
	Если Не ЗначениеЗаполнено(ИдентификаторПриложения.client_id) Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Для конфигурации %1 не определены учетные данные Google'"), Метаданные.Имя);
		ЗарегистрироватьОшибку(ТекстОшибки, ТекстОшибки);
		ВызватьИсключение НСтр("ru = 'При подключении возникла ошибка. Обратитесь к администратору.'");
	КонецЕсли;	
	АдресЗапросаНаПодтверждениеДоступа = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		"%1?scope=%2&redirect_uri=%3&response_type=code&client_id=%4&approval_prompt=force",
		ИдентификаторПриложения.auth_uri,		// 1
		АдресGoogleAPI() + "/auth/calendar",	// 2
		ИдентификаторПриложения.redirect_uri,	// 3
		ИдентификаторПриложения.client_id);		// 4
	Возврат АдресЗапросаНаПодтверждениеДоступа;

КонецФункции

Процедура ПолучитьСписокКалендарейВФоне(ПараметрыПроцедуры, АдресХранилища) Экспорт

	Результат = Новый Структура;
	Если ПараметрыПроцедуры.Свойство("КодРазрешения") Тогда
		ДанныеАвторизации = ДанныеАвторизацииПоКодуРазрешения(ПараметрыПроцедуры.КодРазрешения);
	Иначе
		ДанныеАвторизации = РегистрыСведений.НастройкиСинхронизацииGoogle.ДействительныеДанныеАвторизации(ПараметрыПроцедуры.Узел);
	КонецЕсли;
	Результат.Вставить("ДанныеАвторизации", ДанныеАвторизации);
	СписокКалендарей = СписокКалендарейПользователя(ДанныеАвторизации);
	Результат.Вставить("СписокКалендарей", СписокКалендарей);
	ПоместитьВоВременноеХранилище(Результат, АдресХранилища);

КонецПроцедуры

Процедура ВыгрузитьДанныеКалендаря(ОписаниеКалендаря) Экспорт

	ДанныеАвторизации = РегистрыСведений.НастройкиСинхронизацииGoogle.ДействительныеДанныеАвторизации(ОписаниеКалендаря.Узел);
	Если Не ЗначениеЗаполнено(ДанныеАвторизации.ТокенДоступа) Тогда
		КраткийТекстОшибки =
			НСтр("ru = 'При подключении к календарю возникла ошибка доступа, проверьте настройки подключения.'");
		ПодробныйТекстОшибки = НСтр(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"ru = 'Не удалось получить данные авторизации для узла %1.'", ОписаниеКалендаря.Узел));
		ЗарегистрироватьОшибку(КраткийТекстОшибки, ПодробныйТекстОшибки);
		ВызватьИсключение КраткийТекстОшибки;
	КонецЕсли;
	
	РазмерПакета = 20;
	ДанныеДляВыгрузки = ОписаниеКалендаря.События.СкопироватьКолонки();
	Для Каждого Событие Из ОписаниеКалендаря.События Цикл
		НоваяСтрока = ДанныеДляВыгрузки.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Событие);
		Если ДанныеДляВыгрузки.Количество() < РазмерПакета Тогда
			Продолжить;
		КонецЕсли;
		ВыгрузитьДанныеВУзел(ОписаниеКалендаря.Узел, ОписаниеКалендаря.Идентификатор, ДанныеДляВыгрузки,
			ДанныеАвторизации, ОписаниеКалендаря.ВремяУведомленийЭкспорт, ОписаниеКалендаря.Владелец);
		ДанныеДляВыгрузки.Очистить();
	КонецЦикла;
	
	Если ЗначениеЗаполнено(ДанныеДляВыгрузки) Тогда
		ВыгрузитьДанныеВУзел(ОписаниеКалендаря.Узел, ОписаниеКалендаря.Идентификатор, ДанныеДляВыгрузки,
			ДанныеАвторизации, ОписаниеКалендаря.ВремяУведомленийЭкспорт, ОписаниеКалендаря.Владелец);
	КонецЕсли;

КонецПроцедуры

Процедура ЗагрузитьДанныеКалендаря(ОписаниеКалендаря, ДатаНачала, ДатаОкончания) Экспорт

	ДанныеАвторизации = РегистрыСведений.НастройкиСинхронизацииGoogle.ДействительныеДанныеАвторизации(ОписаниеКалендаря.Узел);
	Если Не ЗначениеЗаполнено(ДанныеАвторизации.ТокенДоступа) Тогда
		КраткийТекстОшибки =
			НСтр("ru = 'При подключении к календарю возникла ошибка доступа, проверьте настройки подключения.'");
		ПодробныйТекстОшибки = НСтр(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"ru = 'Не удалось получить данные авторизации для узла %1.'", ОписаниеКалендаря.Узел));
		ЗарегистрироватьОшибку(КраткийТекстОшибки, ПодробныйТекстОшибки);
		ВызватьИсключение КраткийТекстОшибки;
	КонецЕсли;
	ЗаполнитьСобытияКалендаря(ДанныеАвторизации, ОписаниеКалендаря, ДатаНачала, ДатаОкончания);

КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция НоваяГраницаСекций()

	Возврат СтрЗаменить(Новый УникальныйИдентификатор(), "-", "");

КонецФункции

Функция АдресGoogleAPI()

	Возврат "https://www.googleapis.com";

КонецФункции

Функция HTTPСоединениеGoogle(СтруктураURI)

	ИнтернетПрокси = Неопределено;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		МодульПолучениеФайловИзИнтернетаКлиентСервер = ОбщегоНазначения.ОбщийМодуль("ПолучениеФайловИзИнтернетаКлиентСервер");
		ИнтернетПрокси = МодульПолучениеФайловИзИнтернетаКлиентСервер.ПолучитьПрокси(СтруктураURI.Схема);
	КонецЕсли;
	Таймаут = 20;
	ЗащищенноеСоединение = ОбщегоНазначенияКлиентСервер.НовоеЗащищенноеСоединение();
	Возврат Новый HTTPСоединение(
		СтруктураURI.Хост,
		СтруктураURI.Порт,,,
		ИнтернетПрокси, Таймаут,
		ЗащищенноеСоединение);

КонецФункции

Функция ТелоПакетногоЗапросаИзменениеДанныхКалендаря(Узел, ИдентификаторКалендаря, ДанныеДляВыгрузки, ГраницаСекций, ВремяУведомлений)

	Результат = "";
	Для Каждого Событие Из ДанныеДляВыгрузки Цикл
		ДанныеДляИзменения = Новый Соответствие;
		Если Не ЗначениеЗаполнено(Событие.Идентификатор) Тогда
			
			Если Событие.ПометкаУдаления ИЛИ Событие.ЗаписьУдалена Тогда
				// События, которые удалены и не синхронизированы ранее, не передаются.
				Продолжить;
			КонецЕсли;
			
			ИдентификаторНовогоСобытия = СтрЗаменить(Событие.Ссылка, "-", ""); // Google не принимает идентификаторы с тире
			ДанныеДляИзменения["id"] = ИдентификаторНовогоСобытия;
			ДанныеДляИзменения["reminders"] = ОписаниеНапоминания(ВремяУведомлений);
		
			МенеджерЗаписи = РегистрыСведений.ЗаписиСинхронизацииКалендарей.СоздатьМенеджерЗаписи();
			МенеджерЗаписи.ИдентификаторЗаписи 	                 = Событие.Ссылка;
			МенеджерЗаписи.Узел 					             = Узел;
			МенеджерЗаписи.ИдентификаторКалендаря	             = ИдентификаторКалендаря;
			МенеджерЗаписи.ИдентификаторЗаписиВоВнешнемКалендаре = ИдентификаторНовогоСобытия;
			МенеджерЗаписи.ОтпечатокОбъекта 		             = "";
			МенеджерЗаписи.Записать();
		КонецЕсли;
		Если Событие.ПометкаУдаления Тогда
			ДанныеДляИзменения["status"] = "cancelled"
		Иначе
			ДанныеДляИзменения["status"] = "tentative";
		КонецЕсли;
		ДанныеДляИзменения["description"] = Событие.Описание;
		ДанныеДляИзменения["summary"] = Событие.Наименование;
		
		ВесьДень = Событие.ДатаНачала = НачалоДня(Событие.ДатаНачала)
			И Событие.ДатаОкончания = КонецДня(Событие.ДатаОкончания);
		ДанныеДляИзменения["start"] = ОписаниеДатыСобытия(Событие.ДатаНачала, ВесьДень, "ДатаНачала");
		ДанныеДляИзменения["end"] = ОписаниеДатыСобытия(Событие.ДатаОкончания, ВесьДень, "ДатаОкончания");
		
		ПравилоПовторенияiCalendar = СинхронизацияКалендарей.ПравилоПовторенияiCalendar(Событие.ПравилоПовторения);
		Если ЗначениеЗаполнено(ПравилоПовторенияiCalendar) Тогда
			
			МассивRecurrence = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПравилоПовторенияiCalendar);
			
			ИсключенияПовторенияiCalendar = СинхронизацияКалендарей.ИсключенияПовторенияiCalendar(
				ВесьДень,
				Событие.ДатаНачала,
				Событие.ПравилоПовторения);
			Если ЗначениеЗаполнено(ИсключенияПовторенияiCalendar) Тогда
				МассивRecurrence.Добавить(ИсключенияПовторенияiCalendar);
			КонецЕсли;
			
			ДанныеДляИзменения["recurrence"] = МассивRecurrence;
			
		КонецЕсли;
		
		Если Событие.ПометкаУдаления Тогда
			Результат = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"%1--%2
				|Content-Type: application/http
				|Content-ID: %3
				|
				|%4 /calendar/v3/calendars/%5/events/%6",
				ОтступДляСекции(Результат),					// 1
				ГраницаСекций,								// 2
				Событие.Ссылка,	                            // 3
				ИмяМетодаHTTP(Событие),						// 4
				ИдентификаторКалендаря,						// 5
				Событие.Идентификатор);						// 6
		Иначе
			ИмяМетода = ИмяМетодаHTTP(Событие);
			ЗаписьJSON = Новый ЗаписьJSON;
			ЗаписьJSON.УстановитьСтроку();
			НастройкиСериализации = Новый НастройкиСериализацииJSON;
			НастройкиСериализации.ВариантЗаписиДаты = ВариантЗаписиДатыJSON.ЛокальнаяДатаСоСмещением;
			ЗаписатьJSON(ЗаписьJSON, ДанныеДляИзменения, НастройкиСериализации);
			СтрокаJSON = СтрЗаменить(ЗаписьJSON.Закрыть(), """%null%""", "null"); // Удаление полей
			Результат = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				"%1--%2
				|Content-Type: application/http
				|Content-ID: %3
				|
				|%4 /calendar/v3/calendars/%5/events/%6%7
				|Content-Type: application/json
				|%8
				|%9",
				ОтступДляСекции(Результат),					            // 1
				ГраницаСекций,								            // 2
				Событие.Ссылка,	                                        // 3
				ИмяМетода,									            // 4
				ИдентификаторКалендаря,						            // 5
				Событие.Идентификатор,						            // 6
				ПередаваемыеПоля(Событие.Идентификатор),	            // 7
				ЗаголовокETag(Событие.ОтпечатокОбъекта),	            // 8
				СтрокаJSON);								            // 9
		КонецЕсли;
	КонецЦикла;
	Если ЗначениеЗаполнено(Результат) Тогда
		Результат = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		"%1
		|
		|--%2--",
		Результат,
		ГраницаСекций);
	КонецЕсли;
	Возврат Результат;

КонецФункции

Функция ОписаниеНапоминания(Секунд)

	Результат = Новый Соответствие;
	Если Секунд > 0 Тогда
		Минут = Цел(Секунд/60);
		Результат["useDefault"] = "false";
		ОписаниеНапоминаний = Новый Массив;
		ОписаниеНапоминания = Новый Соответствие();
		ОписаниеНапоминания.Вставить("method",  "popup");
		ОписаниеНапоминания.Вставить("minutes", Минут);
		ОписаниеНапоминаний.Добавить(ОписаниеНапоминания);
		Результат["overrides"] = ОписаниеНапоминаний;
	Иначе
		Результат["useDefault"] = "true";
	КонецЕсли;
	Возврат Результат;

КонецФункции

Функция ОписаниеДатыСобытия(Знач ДатаВремя, ВесьДень, ТипДаты)

	Результат = Новый Соответствие;
	ДатаВремяПриведенноеКСерверу = МестноеВремя(УниверсальноеВремя(ДатаВремя, ПолучитьЧасовойПоясИнформационнойБазы()));
	Если ВесьДень И ТипДаты = "ДатаНачала" Тогда
		Результат["date"] = Формат(ДатаВремяПриведенноеКСерверу, "ДФ=yyyy-MM-dd");
	ИначеЕсли ВесьДень И ТипДаты = "ДатаОкончания" Тогда
		Результат["date"] = Формат(ДатаВремяПриведенноеКСерверу + 86400, "ДФ=yyyy-MM-dd");
	Иначе
		Результат["dateTime"] = ДатаВремяПриведенноеКСерверу;
		Результат["timeZone"] = ЧасовойПоясСеанса();
	КонецЕсли;
	Возврат Результат;

КонецФункции

Функция ЗаголовокETag(ETag)

	Если ЗначениеЗаполнено(ETag) Тогда
		Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		"If-Match: %1%2",
		ETag,
		Символы.ПС);
	КонецЕсли;
	Возврат "";

КонецФункции

Функция ПередаваемыеПоля(Идентификатор)

	Если ЗначениеЗаполнено(Идентификатор) Тогда
		Возврат "?fields=etag,start,end,status,summary,description,attendees,recurrence";
	КонецЕсли;
	Возврат "";

КонецФункции

Функция ОтступДляСекции(ТелоСообщения)

	Если ЗначениеЗаполнено(ТелоСообщения) Тогда
		Возврат ТелоСообщения + Символы.ПС + Символы.ПС;
	КонецЕсли;
	Возврат "";

КонецФункции

Функция ИмяМетодаHTTP(Событие)

	Если Событие.ПометкаУдаления Тогда
		Возврат "DELETE";
	КонецЕсли;
	Если ЗначениеЗаполнено(Событие.Идентификатор) Тогда
		Возврат "PATCH";
	КонецЕсли;
	Возврат "POST";

КонецФункции

Функция ВосстановитьДатуJSON(Свойство, Значение, Параметры) Экспорт

	Попытка
		Возврат ПрочитатьДатуJSON(Значение, ФорматДатыJSON.ISO);
	Исключение
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Синхронизация календарей'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Предупреждение,,,
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось прочитать дату JSON для свойства ""%1"": ""%2"".'"),
			Свойство,
			Значение));
	КонецПопытки;
	Возврат '0001-01-01';

КонецФункции

Функция ПараметрПериод(ТокенСинхронизации, ДатаНачала, ДатаОкончания)

	Если ЗначениеЗаполнено(ТокенСинхронизации) Тогда
		Возврат "";
	КонецЕсли;
	Начало = ЗаписатьДатуJSON(
	ДатаНачала,
	ФорматДатыJSON.ISO,
	ВариантЗаписиДатыJSON.УниверсальнаяДата);
	Окончание = ЗаписатьДатуJSON(
	ДатаОкончания,
	ФорматДатыJSON.ISO,
	ВариантЗаписиДатыJSON.УниверсальнаяДата);
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("&timeMin=%1&timeMax=%2", Начало, Окончание);

КонецФункции

Функция ПараметрТокенСинхронизации(ТокенСинхронизации)

	Если ЗначениеЗаполнено(ТокенСинхронизации) Тогда
		Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("&syncToken=%1", ТокенСинхронизации);
	КонецЕсли;
	Возврат "";

КонецФункции

Функция ПараметрСтраничныйТокен(СтраничныйТокен)

	Если ЗначениеЗаполнено(СтраничныйТокен) Тогда
		Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("&pageToken=%1", СтраничныйТокен);
	КонецЕсли;
	Возврат "";

КонецФункции

Процедура ЗаполнитьПолеДатаВремя(Приемник, ИмяПоляПриемник, Источник, ИмяПоляИсточник)

	Если Не ЗначениеЗаполнено(Источник[ИмяПоляИсточник]) Тогда
		Возврат;
	КонецЕсли;
	Если ЗначениеЗаполнено(Источник[ИмяПоляИсточник]["dateTime"]) Тогда
		ЗначениеПоляДатаВремя = Источник[ИмяПоляИсточник]["dateTime"];
	Иначе
		ЗначениеПоляДатаВремя = Источник[ИмяПоляИсточник]["date"];
	КонецЕсли;
	ЗначениеПриведенноеКЧасовомуПоясуИБ = МестноеВремя(УниверсальноеВремя(ЗначениеПоляДатаВремя), ПолучитьЧасовойПоясИнформационнойБазы());
	Приемник[ИмяПоляПриемник] = ЗначениеПриведенноеКЧасовомуПоясуИБ;

КонецПроцедуры

Процедура ВыгрузитьДанныеВУзел(Узел, ИдентификаторКалендаря, ДанныеДляВыгрузки, ДанныеАвторизации, ВремяУведомлений, Пользователь)
	
	// ЗаписьСообщения используется только для управления нумерацией сообщений и блокировки узла.
	ЗаписьСообщения = ПланыОбмена.СоздатьЗаписьСообщения();
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	ЗаписьСообщения.НачатьЗапись(ЗаписьXML, Узел);
	
	ГраницаСекций = НоваяГраницаСекций();
	СтруктураURI = ОбщегоНазначенияКлиентСервер.СтруктураURI(АдресGoogleAPI() + "/batch/calendar/v3");
	Соединение = HTTPСоединениеGoogle(СтруктураURI);
	ТелоКакСтрока = ТелоПакетногоЗапросаИзменениеДанныхКалендаря(
		Узел, ИдентификаторКалендаря, ДанныеДляВыгрузки, ГраницаСекций, ВремяУведомлений);
	Если Не ЗначениеЗаполнено(ТелоКакСтрока) Тогда
		Возврат;
	КонецЕсли;
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Authorization", СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		"%1 %2", ДанныеАвторизации["ТипТокенаДоступа"], ДанныеАвторизации["ТокенДоступа"]));
	Заголовки.Вставить("Content-Type", СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		"multipart/mixed; boundary=%1", ГраницаСекций));
	Запрос = Новый HTTPЗапрос(СтруктураURI.ПутьНаСервере, Заголовки);
	Запрос.УстановитьТелоИзСтроки(ТелоКакСтрока,, ИспользованиеByteOrderMark.НеИспользовать);
	Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	Если Не Ответ.КодСостояния = 200 Тогда
		Возврат;
	КонецЕсли;
	
	ВыгруженныеЗаписиКалендаря = ДанныеДляВыгрузки.ВыгрузитьКолонку("Ссылка");
	
	// Установим новые отпечатки объектов, полученные с сервера.
	ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
	Если СтрНачинаетсяС(ТелоОтвета, "--") Тогда
		
		// Ответ приходит в виде пакета - каждую секцию пакета анализируем отдельно.
		ЭтоКонецСекции = Ложь;
		ГраницаСекцийОтвета = СтрПолучитьСтроку(ТелоОтвета, 1);
		МеткаИдентификатораСекцииОтвета = "content-id: response-";
		СмещениеИдентификатораСекцииОтвета = СтрДлина(МеткаИдентификатораСекцииОтвета) + 1;
		МеткаОтпечаткаОбъекта = "etag:";
		СмещениеОтпечаткаОбъекта = СтрДлина(МеткаОтпечаткаОбъекта) + 1;
		
		// В секции ответа нужно найти идентификатор секции (это идентификатор записи календаря) и отпечаток объекта.
		ИдентификаторСекцииОтвета = "";
		ОтпечатокОбъектаСекции = "";
		ЗаписьНеНайдена = Ложь;
		ДоступЗапрещен = Ложь;
		ПревышеноОграничение = Ложь;
		
		ПустойИдентификатор = Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000");
		
		Для Каждого СтрокаОтвета Из СтрРазделить(ТелоОтвета, Символы.ПС) Цикл
			
			Если СтрНачинаетсяС(СтрокаОтвета, ГраницаСекцийОтвета) Тогда
				
				// Для обновления в секции необходимо найти отпечаток и идентификатор нужного формата.
				Если ЗначениеЗаполнено(ИдентификаторСекцииОтвета)
					И СтроковыеФункцииКлиентСервер.ЭтоУникальныйИдентификатор(ИдентификаторСекцииОтвета)
					И (ЗначениеЗаполнено(ОтпечатокОбъектаСекции)
						Или ЗаписьНеНайдена
						Или (ДоступЗапрещен И ПревышеноОграничение)) Тогда
					
					ЗаписьКалендаряСекции = Новый УникальныйИдентификатор(ИдентификаторСекцииОтвета);
					
					МенеджерЗаписи = РегистрыСведений.ЗаписиСинхронизацииКалендарей.СоздатьМенеджерЗаписи();
					МенеджерЗаписи.ИдентификаторЗаписи = ЗаписьКалендаряСекции;
					МенеджерЗаписи.Узел = Узел;
					МенеджерЗаписи.Прочитать();
					
					Если ЗначениеЗаполнено(ОтпечатокОбъектаСекции) Тогда
						
						// Отпечаток объекта обновляем, только если уже есть данные, и отпечаток изменился.
						Если МенеджерЗаписи.Выбран() И МенеджерЗаписи.ОтпечатокОбъекта <> ОтпечатокОбъектаСекции Тогда
							МенеджерЗаписи.ОтпечатокОбъекта = ОтпечатокОбъектаСекции;
							МенеджерЗаписи.Записать();
						КонецЕсли;
						
					ИначеЕсли ЗаписьНеНайдена Тогда
						
						МенеджерЗаписи.ИдентификаторЗаписи = ЗаписьКалендаряСекции;
						МенеджерЗаписи.Узел = Узел;
						МенеджерЗаписи.Удалить();
						
					ИначеЕсли ДоступЗапрещен И ПревышеноОграничение Тогда
						
						ОбщегоНазначенияКлиентСервер.УдалитьВсеВхожденияЗначенияИзМассива(
							ВыгруженныеЗаписиКалендаря,
							ЗаписьКалендаряСекции);
						
					КонецЕсли;
					
				КонецЕсли;
				
				// Начинается новая секция.
				ИдентификаторСекцииОтвета = "";
				ОтпечатокОбъектаСекции = "";
				ЗаписьНеНайдена = Ложь;
				
				Продолжить;
				
			КонецЕсли;
			
			НРегСтрокаОтвета = НРег(СтрокаОтвета);
			Если СтрНачинаетсяС(НРегСтрокаОтвета, МеткаИдентификатораСекцииОтвета) Тогда
				ИдентификаторСекцииОтвета = СокрЛП(Сред(СтрокаОтвета, СмещениеИдентификатораСекцииОтвета));
			ИначеЕсли СтрНачинаетсяС(НРегСтрокаОтвета, "etag:") Тогда
				ОтпечатокОбъектаСекции = СокрЛП(Сред(СтрокаОтвета, СмещениеОтпечаткаОбъекта));
			ИначеЕсли СтрНачинаетсяС(НРегСтрокаОтвета, "http/1.1 404 not found") Тогда
				ЗаписьНеНайдена = Истина;
			ИначеЕсли СтрНачинаетсяС(НРегСтрокаОтвета, "http/1.1 403 forbidden") Тогда
				ДоступЗапрещен = Истина;
			ИначеЕсли СтрНачинаетсяС(СокрЛП(НРегСтрокаОтвета), """reason"": ""ratelimitexceeded""") Тогда
				ПревышеноОграничение = Истина;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	НаборыЗаписей = Новый Массив;
	ЗаписиКУдалению = Новый Массив;
	
	// Формируются наборы записей по выгруженным записям для выборки изменений в плане обмена
	Для Каждого ВыгруженнаяЗапись из ВыгруженныеЗаписиКалендаря Цикл
		СтрокаДанных = ДанныеДляВыгрузки.Найти(ВыгруженнаяЗапись, "Ссылка");
		Если СтрокаДанных <> Неопределено Тогда
			НаборЗаписей = РегистрыСведений.КалендариПользователей.СоздатьНаборЗаписей();
			НаборЗаписей.Отбор.Пользователь.Установить(СтрокаДанных.Пользователь, Истина);
			НаборЗаписей.Отбор.ИдентификаторЗаписи.Установить(СтрокаДанных.ИдентификаторЗаписи, Истина);
			
			НаборыЗаписей.Добавить(НаборЗаписей);
			
			// Если в регистре календарей записи уже нет, запись синхронизации нужно удалить
			Если СтрокаДанных.ЗаписьУдалена Тогда
				ЗаписиКУдалению.Добавить(СтрокаДанных.Ссылка);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	ПланыОбмена.ВыбратьИзменения(Узел, ЗаписьСообщения.НомерСообщения, НаборыЗаписей);
	
	НомерСообщения = ЗаписьСообщения.НомерСообщения;
	ЗаписьСообщения.ЗакончитьЗапись();
	ПланыОбмена.УдалитьРегистрациюИзменений(Узел, НомерСообщения);
	
	Для Каждого ИдентификаторЗаписи из ЗаписиКУдалению Цикл
		МенеджерЗаписи = РегистрыСведений.ЗаписиСинхронизацииКалендарей.СоздатьМенеджерЗаписи();
		МенеджерЗаписи.ИдентификаторЗаписи = ИдентификаторЗаписи;
		МенеджерЗаписи.Узел = Узел;
		МенеджерЗаписи.Удалить();
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьСобытияКалендаря(ДанныеАвторизации, ОписаниеКалендаря, ДатаНачала, ДатаОкончания, СтраничныйТокен = Неопределено)

	Если Не ЗначениеЗаполнено(ДатаНачала) Тогда
		ДатаНачала = НачалоДня(ТекущаяДатаСеанса());
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ДатаОкончания) Тогда
		ДатаОкончания = ДобавитьМесяц(ДатаНачала, 12);
	КонецЕсли;
	СтруктураURI = ОбщегоНазначенияКлиентСервер.СтруктураURI(
		СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			АдресGoogleAPI() + "/calendar/v3/calendars/%1/events?singleEvents=False&maxResults=256&timeZone=%2%3%4%5",
			ОписаниеКалендаря.Идентификатор, // 1
			ЧасовойПояс(), // 2
			ПараметрПериод(ОписаниеКалендаря.ТокенСинхронизации, ДатаНачала, ДатаОкончания), // 3
			ПараметрТокенСинхронизации(ОписаниеКалендаря.ТокенСинхронизации), // 4
			ПараметрСтраничныйТокен(СтраничныйТокен))); // 5
	СтрокаJSON = ВызватьGET(СтруктураURI, ДанныеАвторизации);
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	РезультатЧтенияJSON = ПрочитатьJSON(ЧтениеJSON,
		Истина,,,
		"ВосстановитьДатуJSON",
		СинхронизацияGoogle,,
		СтрРазделить("created,date,dateTime,updated", ","));
	Если Не РезультатЧтенияJSON["error"] = Неопределено
		И РезультатЧтенияJSON["error"]["code"] = 410 Тогда
		// Выполняется полная синхронизация, без указания токена синхронизации
		ОписаниеКалендаря.ТокенСинхронизации = "";
		ЗаполнитьСобытияКалендаря(ДанныеАвторизации, ОписаниеКалендаря, ДатаНачала, ДатаОкончания, СтраничныйТокен);
		Возврат;
	КонецЕсли;
	Если РезультатЧтенияJSON["error"] <> Неопределено Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Произошла ошибка синхронизации с Google Calendar: %1'"),
		РезультатЧтенияJSON["error"]["message"]);
	КонецЕсли;
	Для Каждого ТекОписаниеСобытия Из РезультатЧтенияJSON["items"] Цикл
		
		НоваяСтрока = ОписаниеКалендаря.События.Добавить();
		НоваяСтрока.Наименование			       = ТекОписаниеСобытия["summary"];
		НоваяСтрока.Описание				       = ТекОписаниеСобытия["description"];
		НоваяСтрока.Идентификатор			       = ТекОписаниеСобытия["id"];
		НоваяСтрока.ИдентификаторПовторенияВнешний = ТекОписаниеСобытия["recurringEventId"];
		НоваяСтрока.ОтпечатокОбъекта		       = ТекОписаниеСобытия["etag"];
		НоваяСтрока.ПометкаУдаления			       = (ТекОписаниеСобытия["status"] = "cancelled");
		
		ЗаполнитьПолеДатаВремя(НоваяСтрока, "ДатаНачала", ТекОписаниеСобытия, "start");
		ЗаполнитьПолеДатаВремя(НоваяСтрока, "ДатаОкончания", ТекОписаниеСобытия, "end");
		ЗаполнитьПолеДатаВремя(НоваяСтрока, "ДатаИсключения", ТекОписаниеСобытия, "originalStartTime");
		
		МассивИсключенияПовторения = Новый Массив;
		МассивRecurrence = ?(ТипЗнч(ТекОписаниеСобытия["recurrence"]) = Тип("Массив"),
			ТекОписаниеСобытия["recurrence"],
			Новый Массив);
		Для Каждого ЭлементRecurrence Из МассивRecurrence Цикл
			
			Если СтрНачинаетсяС(ВРег(ЭлементRecurrence), "RRULE") Тогда
				НоваяСтрока.ПравилоПовторения = СинхронизацияКалендарей.ПравилоПовторения(ЭлементRecurrence);
			ИначеЕсли СтрНачинаетсяС(ВРег(ЭлементRecurrence), "EXDATE") Тогда
				МассивИсключенияПовторения.Добавить(
					СинхронизацияКалендарей.ИсключенияПовторения(ЭлементRecurrence));
			КонецЕсли;
			
		КонецЦикла;
		Если НоваяСтрока.ПравилоПовторения.Количество() = 0 Тогда
			НоваяСтрока.ПравилоПовторения = КалендариПользователей.ПравилоПовторенияНикогда();
		КонецЕсли;
		Для Каждого ИсключенияПовторения Из МассивИсключенияПовторения Цикл
			
			Для Каждого ИсключениеПовторения Из ИсключенияПовторения Цикл
				
				ЗаполнитьЗначенияСвойств(
					НоваяСтрока.ПравилоПовторения.ИсключенияПовторения.Добавить(),
					ИсключениеПовторения,
					"ДатаИсключения, ЗаписьИсключения");
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	СтраничныйТокен = РезультатЧтенияJSON["nextPageToken"];
	Если ЗначениеЗаполнено(СтраничныйТокен) Тогда
		ЗаполнитьСобытияКалендаря(ДанныеАвторизации, ОписаниеКалендаря, ДатаНачала, ДатаОкончания, СтраничныйТокен);
		Возврат;
	КонецЕсли;
	ОписаниеКалендаря.ТокенСинхронизации = РезультатЧтенияJSON["nextSyncToken"];

КонецПроцедуры

Функция СписокКалендарейПользователя(ДанныеАвторизации)

	СписокКалендарей = Новый Массив;
	СтруктураURI = ОбщегоНазначенияКлиентСервер.СтруктураURI(
		АдресGoogleAPI() + "/calendar/v3/users/me/calendarList");
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(ВызватьGET(СтруктураURI, ДанныеАвторизации));
	РезультатЧтенияJSON = ПрочитатьJSON(ЧтениеJSON, Истина);
	Если ЗначениеЗаполнено(РезультатЧтенияJSON["error"]) Тогда
		ВызватьИсключение НСтр("ru = 'Приложению запрещен доступ к аккаунту Google.'");
	ИначеЕсли РезультатЧтенияJSON.Получить("items") <> Неопределено Тогда
		Для Каждого ДанныеКалендаря Из РезультатЧтенияJSON.Получить("items") Цикл
			Если ДанныеКалендаря["accessRole"] <> "owner" Тогда
				Продолжить;
			КонецЕсли;
			ОписаниеКалендаря = Новый Структура;
			ОписаниеКалендаря.Вставить("Идентификатор", ДанныеКалендаря.Получить("id"));
			ОписаниеКалендаря.Вставить("Наименование", ДанныеКалендаря.Получить("summary"));
			СписокКалендарей.Добавить(ОписаниеКалендаря);
		КонецЦикла;
	КонецЕсли;
	Возврат СписокКалендарей;

КонецФункции

Функция ДанныеАвторизацииПоКодуРазрешения(КодРазрешения)

	ИдентификаторПриложения = ИдентификаторПриложения();
	СтруктураURI = ОбщегоНазначенияКлиентСервер.СтруктураURI(
		ИдентификаторПриложения.token_uri);
	Соединение = HTTPСоединениеGoogle(СтруктураURI);
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
	Запрос = Новый HTTPЗапрос(СтруктураURI.ПутьНаСервере, Заголовки);
	Запрос.УстановитьТелоИзСтроки(
		СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"code=%1&client_id=%2&client_secret=%3&redirect_uri=%4&grant_type=authorization_code",
			КодРазрешения,
			ИдентификаторПриложения.client_id,
			ИдентификаторПриложения.client_secret,
			ИдентификаторПриложения.redirect_uri));
	Попытка	
		Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	Исключение
		ЗарегистрироватьОшибку(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	ДанныеАвторизации = РегистрыСведений.НастройкиСинхронизацииGoogle.НовыеДанныеАвторизации();
	Если Ответ.КодСостояния = 200 Тогда
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(Ответ.ПолучитьТелоКакСтроку());
		Результат = ПрочитатьJSON(ЧтениеJSON);
		ДанныеАвторизации.ТокенДоступа = Результат.access_token;
		ДанныеАвторизации.ТипТокенаДоступа = Результат.token_type;
		ДанныеАвторизации.ТокенОбновления = Результат.refresh_token;
	Иначе
		КраткийТекстОшибки = НСтр(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"ru = 'Получение сеансовых данных по коду разрешения завершилось ошибкой.
			|Код разрешения: %1'", КодРазрешения));
		ПодробныйТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Сервер вернул состояние: %1
						|Тело ответа: %2'"), Ответ.КодСостояния, Ответ.ПолучитьТелоКакСтроку());
		ЗарегистрироватьОшибку(КраткийТекстОшибки, ПодробныйТекстОшибки);
		ВызватьИсключение КраткийТекстОшибки;
	КонецЕсли;
	Возврат ДанныеАвторизации;

КонецФункции

Функция ВызватьGET(СтруктураURI, ДанныеАвторизации)

	Соединение = HTTPСоединениеGoogle(СтруктураURI);
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Authorization", СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		"%1 %2", ДанныеАвторизации["ТипТокенаДоступа"], ДанныеАвторизации["ТокенДоступа"]));
	Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
	Запрос = Новый HTTPЗапрос(СтруктураURI.ПутьНаСервере, Заголовки);
	Попытка
		Ответ = Соединение.Получить(Запрос);
	Исключение
		ЗарегистрироватьОшибку(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	Возврат Ответ.ПолучитьТелоКакСтроку();

КонецФункции

Процедура ЗарегистрироватьОшибку(КраткийТекстОшибки, ПодробныйТекстОшибки, ПоказыватьСообщения = Ложь)

	ИмяСобытия = НСтр("ru = 'Синхронизация календарей.Google'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка());
	ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньЖурналаРегистрации.Ошибка,,, ПодробныйТекстОшибки);
	Если Не ПоказыватьСообщения Тогда
		Возврат;
	КонецЕсли;
	ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'При синхронизации возникла ошибка. Обратитесь к администратору.
			       |Текст ошибки:
			       |%1'"),
		КраткийТекстОшибки);
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения);

КонецПроцедуры

#КонецОбласти