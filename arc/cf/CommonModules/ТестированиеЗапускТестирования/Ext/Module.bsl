
#Область ПрограммныйИнтерфейс

// Запускает тестирование веток проекта.
//
Процедура СформироватьРасписаниеИЗапуститьТестирование() Экспорт
	УстановитьПривилегированныйРежим(Истина);
	
	ПроектыКОбработке = ПроектыКОбработке();
	
	Для Каждого Проект Из ПроектыКОбработке Цикл
		ЗаполнитьРасписание(Проект.Ссылка);
		ЗапуститьОтложенныеЗапускиТестирования(Проект.Ссылка);
	КонецЦикла; 
	
КонецПроцедуры 

//Создает запланированные запуски тестирования по проекту на указанное время.
//
// Параметры:
//  Проект                - СправочникСсылка.Проекты  - Проект, для которого формируется расписание.
//  ТекущаяДата           - Дата                      - Дата, на которую формируется расписание. 
//
Процедура ЗаполнитьРасписание(Проект, ТекущаяДата=Неопределено) Экспорт
	
	// Формирует и доформировывает расписание запусков.
	Если ТекущаяДата = Неопределено Тогда
		ТекущаяДата = ТекущаяДата();
	КонецЕсли;
	
	ДоступноеВремя = ДоступноеВремяИМощностьДляТестирования(Проект, ТекущаяДата);
	Если ДоступноеВремя.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	ЗапускиДляТестирования = ЗапланированныеЗапускиТестирования(Проект, ДоступноеВремя);
	ДатаНачала = ВремяНачалаТестированияПоДате(Проект, ДоступноеВремя[0].ДатаВремяЗапуска);

	// Считываются ветки для тестирования
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	|	Ветки.Ссылка КАК Ветка,
	|	Ветки.Имя КАК ВеткаИмя,
	|	Ветки.Приемник.Имя КАК ВеткаПриемникИмя,
	|	Ветки.Ответственный КАК Ответственный,
	|	Ветки.НастройкаЗапускаТестирования КАК НастройкаЗапускаТестирования,
	|	Ветки.НастройкаЗапускаТестирования.ПредпочтительноеВремяЗапуска КАК ПредпочтительноеВремяЗапуска,
	|	Ветки.НастройкаЗапускаТестирования.ЗанимаемаяМощность КАК ЗанимаемаяМощность,
	|	Ветки.Приемник.Ответственный КАК ПриемникОтветственный,
	|	Ветки.ПриоритетТестирования КАК ПриоритетТестирования,
	|	ПоследнийЗапускТестирования.Ссылка КАК ПоследнийЗапуск,
	|	ПоследнийЗапускТестирования.Pipeline_ID КАК ИдентификаторПоследнегоЗапуска,
	|	Ветки.ДатаНачалаТестирования КАК ДатаНачалаТестирования,
	|	ЕСТЬNULL(ПоследнийЗапускТестирования.Дата, ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0)) КАК ДатаПоследнегоЗапуска,
	|	ВЫБОР
	|		КОГДА Ошибки.Ссылка ЕСТЬ NULL
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ ЛОЖЬ
	|	КОНЕЦ КАК ВсеОшибкиИсправлены,
	|	ВЫБОР
	|		КОГДА Ветки.ПриоритетТестирования = ЗНАЧЕНИЕ(Перечисление.ПриоритетыТестированияВеток.Срочный)
	|			ТОГДА 1
	|		КОГДА Ветки.ПриоритетТестирования = ЗНАЧЕНИЕ(Перечисление.ПриоритетыТестированияВеток.Повышенный)
	|				И Ошибки.Ссылка ЕСТЬ NULL
	|			ТОГДА 2
	|		КОГДА Ветки.ПриоритетТестирования = ЗНАЧЕНИЕ(Перечисление.ПриоритетыТестированияВеток.Обычный)
	|				И Ошибки.Ссылка ЕСТЬ NULL
	|			ТОГДА 3
	|		КОГДА Ветки.ПриоритетТестирования = ЗНАЧЕНИЕ(Перечисление.ПриоритетыТестированияВеток.Повышенный)
	|			ТОГДА 4
	|		КОГДА Ветки.ПриоритетТестирования = ЗНАЧЕНИЕ(Перечисление.ПриоритетыТестированияВеток.Обычный)
	|			ТОГДА 5
	|		ИНАЧЕ 6
	|	КОНЕЦ КАК ПорядокПоПриоритету,
	|	ВЫБОР
	|		КОГДА Ветки.Тип = ЗНАЧЕНИЕ(Перечисление.ТипыВеток.ОсновнаяВеткаПроекта)
	|			ТОГДА 1
	|		КОГДА Ветки.Тип = ЗНАЧЕНИЕ(Перечисление.ТипыВеток.ВеткаВерсии)
	|			ТОГДА 2
	|		КОГДА Ветки.Тип = ЗНАЧЕНИЕ(Перечисление.ТипыВеток.ВеткаДляИсправленияОшибок)
	|			ТОГДА 3
	|		КОГДА Ветки.Тип = ЗНАЧЕНИЕ(Перечисление.ТипыВеток.ВеткаТехническогоПроекта)
	|			ТОГДА 4
	|		ИНАЧЕ 5
	|	КОНЕЦ КАК ПорядокПоТипу
	|ИЗ
	|	Справочник.Ветки КАК Ветки
	|		ЛЕВОЕ СОЕДИНЕНИЕ Документ.ЗапускТестирования КАК ПоследнийЗапускТестирования
	|		ПО (ПоследнийЗапускТестирования.Ссылка В
	|				(ВЫБРАТЬ ПЕРВЫЕ 1
	|					ЗапускТестирования.Ссылка
	|				ИЗ
	|					Документ.ЗапускТестирования КАК ЗапускТестирования
	|				ГДЕ
	|					ЗапускТестирования.Ветка = Ветки.Ссылка
	|					И ЗапускТестирования.Проведен
	|					И НЕ ЗапускТестирования.ПометкаУдаления
	|					И НЕ ПОДСТРОКА(ЗапускТестирования.Pipeline_ID, 1, 1) ПОДОБНО """"
	|					И ЗапускТестирования.Настройка <> ЗНАЧЕНИЕ(Справочник.НастройкиЗапускаТестирования.ПустаяСсылка)
	|				УПОРЯДОЧИТЬ ПО
	|					ЗапускТестирования.Дата УБЫВ))
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Ошибки КАК Ошибки
	|		ПО (Ветки.Тип В (ЗНАЧЕНИЕ(Перечисление.ТипыВеток.ВеткаТехническогоПроекта), ЗНАЧЕНИЕ(Перечисление.ТипыВеток.ВеткаДляИсправленияОшибок)))
	|			И (ИСТИНА В
	|					(ВЫБРАТЬ ПЕРВЫЕ 1
	|						ИСТИНА
	|					ИЗ
	|						Справочник.Ошибки.ИсправлениеВВетках КАК ОшибкиИсправлениеВВетках
	|					ГДЕ
	|						ОшибкиИсправлениеВВетках.Ссылка.Статус В (ЗНАЧЕНИЕ(Перечисление.СтатусыОшибок.Зарегистрирована), ЗНАЧЕНИЕ(Перечисление.СтатусыОшибок.Признана))
	|						И ОшибкиИсправлениеВВетках.СостояниеИсправления = ЗНАЧЕНИЕ(Перечисление.СостоянияИсправленияОшибок.ТребуетсяИсправление)
	|						И ОшибкиИсправлениеВВетках.Ссылка.Исправляется = ЗНАЧЕНИЕ(Перечисление.ВариантыИсправленияОшибок.ВРазныхветках)
	|						И ОшибкиИсправлениеВВетках.ВеткаИсправления = Ветки.Ссылка)
	|				ИЛИ ИСТИНА В
	|					(ВЫБРАТЬ ПЕРВЫЕ 1
	|						ИСТИНА
	|					ИЗ
	|						Справочник.Ошибки КАК ОшибкиОбнаруженныеВВетке
	|					ГДЕ
	|						ОшибкиОбнаруженныеВВетке.Статус В (ЗНАЧЕНИЕ(Перечисление.СтатусыОшибок.Зарегистрирована), ЗНАЧЕНИЕ(Перечисление.СтатусыОшибок.Признана))
	|						И ОшибкиОбнаруженныеВВетке.Исправляется = ЗНАЧЕНИЕ(Перечисление.ВариантыИсправленияОшибок.ТолькоВВеткеОбнаружения)
	|						И ОшибкиОбнаруженныеВВетке.ВеткаОбнаружения = Ветки.Ссылка))
	|ГДЕ
	|	Ветки.Статус = ЗНАЧЕНИЕ(Перечисление.СтатусыВеток.Тестируется)
	|	И Ветки.Владелец = &Проект
	|	И НЕ Ветки.ПометкаУдаления
	|	И НЕ Ветки.Ссылка В (&ВеткиНаТестировании)
	|
	|УПОРЯДОЧИТЬ ПО
	|	ПорядокПоПриоритету,
	|	ПорядокПоТипу,
	|	ДатаНачалаТестирования";

	Запрос.УстановитьПараметр("ТекущаяДата", ТекущаяДата); 
	Запрос.УстановитьПараметр("ДатаНачала", ДатаНачала);
	Запрос.УстановитьПараметр("ВеткиНаТестировании", ЗапускиДляТестирования.ВыгрузитьКолонку("Ветка"));
	Запрос.УстановитьПараметр("Проект", Проект);
	
	ВеткиДляЗапуска = Запрос.Выполнить().Выгрузить();
	ВеткиДляЗапуска.Колонки.Добавить("МожноВыполнятьТестирование", Новый ОписаниеТипов("Булево"));
	ВеткиДляЗапуска.Колонки.Добавить("СозданЗапускТестирования", Новый ОписаниеТипов("Булево"));
	АвторСообщения = Пользователи.ТекущийПользователь();
	
	ТекущаяДата = ТекущаяДата();
	НачалоЧаса = НачалоДня(ТекущаяДата) + Час(ТекущаяДата) * 60*60;
	
	ИндексТекущейСтрокиПоУмолчанию = 0;
	Пока ИндексТекущейСтрокиПоУмолчанию < ДоступноеВремя.Количество() И ДоступноеВремя[ИндексТекущейСтрокиПоУмолчанию].ДатаВремяЗапуска < НачалоЧаса Цикл
		ИндексТекущейСтрокиПоУмолчанию = ИндексТекущейСтрокиПоУмолчанию + 1;
	КонецЦикла;

	Для Каждого ВеткаДляЗапуска Из ВеткиДляЗапуска Цикл
		ВеткаДляЗапуска.СозданЗапускТестирования = Ложь;
		ВеткаДляЗапуска.МожноВыполнятьТестирование = Ложь;
		
		// Проверки, можно ли запускать тестирование.  
	
		ШаблонВеткаНеТестируется = НСтр("ru='не поставлена на тестирование'");
		СообщениеВеткаНеТестируется = СтрШаблон(НСтр("ru='Ветка %1 не поставлена на тестирование.'"), ВеткаДляЗапуска.ВеткаИмя) + Символы.ПС;

		// Проверка, заполнена ли настройка тестирования.
		Если НЕ ЗначениеЗаполнено(ВеткаДляЗапуска.НастройкаЗапускаТестирования) Тогда
			ТекстСообщения = СообщениеВеткаНеТестируется + НСтр("ru='В ветке не указана настройка запуска тестирования.'");
			ОтветственныйДляСообщения = ?(ЗначениеЗаполнено(ВеткаДляЗапуска.ПриемникОтветственный), 
															ВеткаДляЗапуска.ПриемникОтветственный, 
															ВеткаДляЗапуска.Ответственный);
			Тестирование.ДобавитьСообщениеПоОбъекту(ВеткаДляЗапуска.Ветка, 
									   ОтветственныйДляСообщения,
									   АвторСообщения,
									   ТекущаяДата() - 24*60*60,
									   ТекстСообщения,
									   ТекстСообщения);
			Продолжить;
		КонецЕсли;
		
		// Проверка, существует ли ветка на сервере.
		Если НЕ ВеткаСуществуетНаСервере(Проект, ВеткаДляЗапуска.ВеткаИмя) Тогда
			ТекстСообщения = СообщениеВеткаНеТестируется 
								+ СтрШаблон(НСтр("ru='Ветка с именем %1 не существует на сервере.'"), ВеткаДляЗапуска.ВеткаИмя);
			Тестирование.ДобавитьСообщениеПоОбъекту(ВеткаДляЗапуска.Ветка, 
									   ВеткаДляЗапуска.Ответственный,
									   АвторСообщения,
									   ТекущаяДата() - 24*60*60,
									   ТекстСообщения,
									   ТекстСообщения);
			Продолжить;
		КонецЕсли;

		// Проверка, есть ли изменения в ветке с последнего запуска.  
		ЕстьИзменения = ЕстьИзмененияВВетке(Проект, ВеткаДляЗапуска.ВеткаИмя, ВеткаДляЗапуска.ВеткаПриемникИмя, ВеткаДляЗапуска.ИдентификаторПоследнегоЗапуска);
		ВеткаДляЗапуска.МожноВыполнятьТестирование = ЕстьИзменения;
		Если НЕ ЕстьИзменения Тогда
			Продолжить;
		КонецЕсли; 
	
		МощностьДляЗапуска = ВеткаДляЗапуска.ЗанимаемаяМощность;
		ДатаЗапуска = Неопределено;

		ПредпочтительноеДатаВремяЗапуска = Неопределено;
		Если ЗначениеЗаполнено(ВеткаДляЗапуска.ПредпочтительноеВремяЗапуска) Тогда
			ПредпочтительноеДатаВремяЗапуска = НачалоДня(ТекущаяДата) + Час(ВеткаДляЗапуска.ПредпочтительноеВремяЗапуска) * 60*60; 
		КонецЕсли;
		
		// Запуск тестирования нужно поставить в расписание позже, он пропускается
		Если ПредпочтительноеДатаВремяЗапуска <> Неопределено
			И НачалоЧаса < ПредпочтительноеДатаВремяЗапуска Тогда
			Продолжить;
		КонецЕсли;
		ИндексТекущейСтроки = ИндексТекущейСтрокиПоУмолчанию;
		
		Пока МощностьДляЗапуска > 0 И ИндексТекущейСтроки < ДоступноеВремя.Количество() Цикл
			
			Если ПредпочтительноеДатаВремяЗапуска <> Неопределено
				И ДоступноеВремя[ИндексТекущейСтроки].ДатаВремяЗапуска < ПредпочтительноеДатаВремяЗапуска Тогда
				ИндексТекущейСтроки = ИндексТекущейСтроки + 1;
				Продолжить;
			КонецЕсли;
			
			Если ДоступноеВремя[ИндексТекущейСтроки].СвободнаяМощность <> 0 Тогда 
				Если ДатаЗапуска = Неопределено Тогда
					ДатаЗапуска = ДоступноеВремя[ИндексТекущейСтроки].ДатаВремяЗапуска;
				КонецЕсли;
				Если МощностьДляЗапуска <= ДоступноеВремя[ИндексТекущейСтроки].СвободнаяМощность Тогда
					ДоступноеВремя[ИндексТекущейСтроки].СвободнаяМощность = ДоступноеВремя[ИндексТекущейСтроки].СвободнаяМощность - МощностьДляЗапуска;
					МощностьДляЗапуска = 0;
				Иначе
					МощностьДляЗапуска = МощностьДляЗапуска - ДоступноеВремя[ИндексТекущейСтроки].СвободнаяМощность;
					ДоступноеВремя[ИндексТекущейСтроки].СвободнаяМощность = 0;
				КонецЕсли;
			КонецЕсли;
			
			Если ДоступноеВремя[ИндексТекущейСтроки].СвободнаяМощность = 0 Тогда
				ИндексТекущейСтроки = ИндексТекущейСтроки + 1;
			КонецЕсли;
		КонецЦикла;

		БудетСозданЗапуск = МощностьДляЗапуска = 0 И ДатаЗапуска <> Неопределено;
		ВеткаДляЗапуска.СозданЗапускТестирования = БудетСозданЗапуск;

		Если БудетСозданЗапуск Тогда
			ЗапланироватьЗапускТестирования(Проект, ВеткаДляЗапуска.Ветка,
											ВеткаДляЗапуска.НастройкаЗапускаТестирования, 
											ДатаЗапуска);
			
		Иначе

			Если ВеткаДляЗапуска.ВсеОшибкиИсправлены Тогда
				ТекстСообщения = СообщениеВеткаНеТестируется + НСтр("ru='Не хватило слотов на тестирование.'");
			Иначе
				ТекстСообщения = СообщениеВеткаНеТестируется + НСтр("ru='Есть неисправленные ошибки.'");
			КонецЕсли;   
			
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Запуск тестирования.Заполнить расписание'"),
										УровеньЖурналаРегистрации.Информация,,ВеткаДляЗапуска.Ветка,ТекстСообщения);
	
		КонецЕсли;
	КонецЦикла; 
	
	// Заполнение оставшихся неисользованных мощностей
	
	// Поиск веток, не поставленных на тестирование
	ВеткиДляЗапускаМожноТестировать = ВеткиДляЗапуска.НайтиСтроки(Новый Структура("МожноВыполнятьТестирование,СозданЗапускТестирования", Истина, Ложь));
	
	// Осталась свободная мощность для тестирования, она занимается ветками
	ДоступноеВремяТекущаяСтрока = ДоступноеВремя[ИндексТекущейСтрокиПоУмолчанию];
	Если ДоступноеВремяТекущаяСтрока.СвободнаяМощность > 0 
		И ВеткиДляЗапускаМожноТестировать.Количество() > 0 
		И ДоступноеВремяТекущаяСтрока.ДатаВремяЗапуска <= НачалоЧаса Тогда
		ИндексТекущейВеткиДляЗапуска = 0;
		Пока ДоступноеВремяТекущаяСтрока.СвободнаяМощность > 0 Цикл
			ВеткаДляЗапуска = ВеткиДляЗапускаМожноТестировать[ИндексТекущейВеткиДляЗапуска]; 
			
			Если ВеткаДляЗапуска.ЗанимаемаяМощность <= ДоступноеВремяТекущаяСтрока.СвободнаяМощность
				ИЛИ ВеткаДляЗапуска.ПриоритетТестирования = Перечисления.ПриоритетыТестированияВеток.Срочный Тогда
				
				ДоступноеВремяТекущаяСтрока.СвободнаяМощность = ДоступноеВремяТекущаяСтрока.СвободнаяМощность 
																- ВеткаДляЗапуска.ЗанимаемаяМощность;
				ЗапланироватьЗапускТестирования(Проект, ВеткаДляЗапуска.Ветка,
												ВеткаДляЗапуска.НастройкаЗапускаТестирования, 
												ДоступноеВремяТекущаяСтрока.ДатаВремяЗапуска);

			КонецЕсли; 
			
			ИндексТекущейВеткиДляЗапуска = ИндексТекущейВеткиДляЗапуска + 1;
			Если ИндексТекущейВеткиДляЗапуска >= ВеткиДляЗапускаМожноТестировать.Количество() Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

//Возвращает созданный запуск тестирования.
//
// Параметры:
//  Проект                - СправочникСсылка.Проекты  - Проект, для которого создастся запуск.
//  Ветка                 - СправочникСсылка.Ветка    - Ветка, для которой создастся запуск.
//  ДатаЗапуска           - Дата, Неопределено        - Дата запуска тестирования. 
//  Настройка             - СправочникСсылка.НастройкиЗапускаТестирования, Неопределено - Настройка тестирования.
//
// Возвращаемое значение:
//   ДокументСсылка.ЗапускТестирования - Созданный запуск тестирования
Функция ЗапланироватьЗапускТестирования(Проект, Ветка, Настройка=Неопределено, ДатаЗапуска=Неопределено) Экспорт
	Если НЕ ЗначениеЗаполнено(ДатаЗапуска) Тогда
		ДатаЗапуска = ТекущаяДата();
	КонецЕсли;
	ВариантЗапускаТестов = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ветка, "ВариантЗапускаТестов");
	
	ЗапускТестирования = Документы.ЗапускТестирования.СоздатьДокумент();
	ЗапускТестирования.Автор = Пользователи.ТекущийПользователь();
	ЗапускТестирования.Ветка = Ветка;
	ЗапускТестирования.Проект = Проект;
	ЗапускТестирования.Дата = ДатаЗапуска;
	ЗапускТестирования.Настройка = Настройка;
	Если ВариантЗапускаТестов = Перечисления.ВариантыЗапускаТестов.ТолькоВыполненныеНеУспешно Тогда
		ЗапускТестирования.ЗапуститьТестыВыполненныеСОшибкой = Истина;
	ИначеЕсли ВариантЗапускаТестов = Перечисления.ВариантыЗапускаТестов.ВсеТолькоВПервыйРаз Тогда
		Попытка
			ВеткаОбъект = Ветка.ПолучитьОбъект();
			ВеткаОбъект.ВариантЗапускаТестов = Перечисления.ВариантыЗапускаТестов.ТолькоВыполненныеНеУспешно;
			ВеткаОбъект.Записать();
		Исключение                 
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Запуск тестирования.Обновление варианта запуска'"),
										УровеньЖурналаРегистрации.Ошибка,,,ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));	
		КонецПопытки;
	КонецЕсли;
	ЗапускТестирования.Записать();
	Возврат ЗапускТестирования.Ссылка;
	
КонецФункции

//Возвращает таблицу с доступным временем и мощностями для тестирования.
//
// Параметры:
//  Проект                - СправочникСсылка.Проекты  - Проект, для которого формируется расписание.
//  ТекущаяДата           - Дата                      - Дата, на которую формируется расписание. 
//
// Возвращаемое значение:
//   ТаблицаЗначений - Доступное время и мощность для тестирования.
//       * ДатаВремяЗапуска   - Дата.
//       * ДоступнаяМощность  - Число.
//       * СвободнаяМощность  - Число.
Функция ДоступноеВремяИМощностьДляТестирования(Проект, ТекущаяДата=Неопределено) Экспорт
	
	// Определяется дата и время начала и окончания периода, для которого нужно получить мощность.
	Если ТекущаяДата = Неопределено Тогда
		ТекущаяДата = ТекущаяДата();
	КонецЕсли;
	ДатаНачала = ВремяНачалаТестированияПоДате(Проект, ТекущаяДата);
	ДатаОкончания = ВремяОкончанияТестированияПоДате(Проект, ДатаНачала);
	НомерДняНедели = ДеньНедели(ДатаНачала);
	
	// Заполняется таблица с доступной мощностью на период для формирования расписания.
	
	ДоступноеВремя = Новый ТаблицаЗначений; 
	ДоступноеВремя.Колонки.Добавить("ДатаВремяЗапуска");
	ДоступноеВремя.Колонки.Добавить("ДоступнаяМощность");
	ДоступноеВремя.Колонки.Добавить("СвободнаяМощность");
	
	Для Каждого Строка Из Проект.СлотыТестирования Цикл
		
		Если Строка.ДоступнаяМощность = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		РазницаВДнях = Строка.НомерДня - НомерДняНедели;
		Если РазницаВДнях < 0 Тогда
			РазницаВДнях = РазницаВДнях + 7;
		КонецЕсли;
		
		ДатаВремяСтроки = НачалоДня(ТекущаяДата) + Строка.НомерЧаса*60*60 + РазницаВДнях*24*60*60;
		Если ДатаВремяСтроки >= ДатаНачала И ДатаВремяСтроки < ДатаОкончания Тогда
			НоваяСтрока = ДоступноеВремя.Добавить();
			НоваяСтрока.ДоступнаяМощность = Строка.ДоступнаяМощность;
			НоваяСтрока.СвободнаяМощность = Строка.ДоступнаяМощность;
			НоваяСтрока.ДатаВремяЗапуска = ДатаВремяСтроки;
		КонецЕсли;
		
	КонецЦикла;
	
	ДоступноеВремя.Сортировать("ДатаВремяЗапуска");
	Возврат ДоступноеВремя;
	
КонецФункции

//Возвращает запланированные запуски тестирования по проекту.
//
// Параметры:
//  Проект                - СправочникСсылка.Проекты - Проект, для которого ищутся запуски тестирования.
//  ДоступноеВремя        - ТаблицаЗначений - Доступное время и мощность для тестирования.
//       * ДатаВремяЗапуска   - Дата.
//       * ДоступнаяМощность  - Число.
//       * СвободнаяМощность  - Число.
// 
// Возвращаемое значение:
//   ТаблицаЗначений - Запланированные запуски тестирования.
//       * ЗапускТестирования               - Документ.ЗапускТестирования.
//       * Ветка                            - Справочник.Ветки.
//       * ДатаВремяЗапуска                 - Дата.
//       * ИдентификаторЗапускаТестирования - Строка.
//       * Запущен                          - Булево.
//       * НастройкаЗапуска                 - Справочник.НастройкиЗапускаТестирования.
//       * ЗанимаемаяМощность               - Число.
//
Функция ЗапланированныеЗапускиТестирования(Проект, ДоступноеВремя=Неопределено) Экспорт
	Если ДоступноеВремя = Неопределено Тогда
		ДоступноеВремя = ДоступноеВремяИМощностьДляТестирования(Проект);
	КонецЕсли;
	Если ДоступноеВремя.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ДатаНачала = ВремяНачалаТестированияПоДате(Проект, ДоступноеВремя[0].ДатаВремяЗапуска);
	ДатаОкончания = ВремяОкончанияТестированияПоДате(Проект, ДатаНачала);
	
	// Считываются уже запланированные запуски тестирования на доступное время, чтобы определить оставшиеся ресурсы.
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ЗапускТестирования.Ссылка КАК ЗапускТестирования,
	|	ЗапускТестирования.Номер КАК Номер,
	|	ЗапускТестирования.Ветка КАК Ветка,
	|	ЗапускТестирования.Дата КАК ДатаВремяЗапуска,
	|	ЗапускТестирования.Pipeline_ID КАК ИдентификаторЗапускаТестирования,
	|	ЗапускТестирования.Проведен КАК Запущен,
	|	ЗапускТестирования.Настройка КАК НастройкаЗапуска,
	|	ЗапускТестирования.Настройка.ЗанимаемаяМощность КАК ЗанимаемаяМощность,
	|	0 КАК ДоступнаяМощность
	|ИЗ
	|	Документ.ЗапускТестирования КАК ЗапускТестирования
	|ГДЕ
	|	ЗапускТестирования.Настройка <> ЗНАЧЕНИЕ(Справочник.НастройкиЗапускаТестирования.ПустаяСсылка)
	|	И ЗапускТестирования.Проект = &Проект
	|	И НЕ ЗапускТестирования.ПометкаУдаления
	|	И ЗапускТестирования.Дата МЕЖДУ &ДатаНачала И &ДатаОкончания
	|
	|УПОРЯДОЧИТЬ ПО
	|	ЗапускТестирования.Дата";
	
	Запрос.УстановитьПараметр("ДатаНачала", ДатаНачала);
	Запрос.УстановитьПараметр("ДатаОкончания", ДатаОкончания);
	Запрос.УстановитьПараметр("Проект", Проект);
	ЗапланированныеЗапуски = Запрос.Выполнить().Выгрузить();
	ИндексТекущейСтроки = 0;
	
	Для Каждого ЗапланированныйЗапуск Из ЗапланированныеЗапуски Цикл
		Дата = ЗапланированныйЗапуск.ДатаВремяЗапуска;
		ДатаЧас = НачалоДня(Дата) + Час(Дата)*60*60;
		Пока ИндексТекущейСтроки < ДоступноеВремя.Количество() 
			И (ДоступноеВремя[ИндексТекущейСтроки].ДатаВремяЗапуска < ДатаЧас 
			ИЛИ ДоступноеВремя[ИндексТекущейСтроки].СвободнаяМощность = 0) Цикл
			ИндексТекущейСтроки = ИндексТекущейСтроки + 1;
		КонецЦикла;
		Если ИндексТекущейСтроки >= ДоступноеВремя.Количество() Тогда
			Прервать;
		КонецЕсли;
		Если ДоступноеВремя[ИндексТекущейСтроки].ДатаВремяЗапуска > ДатаЧас + 60*60 Тогда
			Продолжить;
		КонецЕсли;
		
		МощностьДляЗапуска = ЗапланированныйЗапуск.ЗанимаемаяМощность;
		ЗапланированныйЗапуск.ДоступнаяМощность = МощностьДляЗапуска;
		Пока МощностьДляЗапуска > 0 И ИндексТекущейСтроки < ДоступноеВремя.Количество() Цикл
			Если МощностьДляЗапуска <= ДоступноеВремя[ИндексТекущейСтроки].СвободнаяМощность Тогда
				ДоступноеВремя[ИндексТекущейСтроки].СвободнаяМощность = ДоступноеВремя[ИндексТекущейСтроки].СвободнаяМощность - МощностьДляЗапуска;
				МощностьДляЗапуска = 0;
			Иначе
				МощностьДляЗапуска = МощностьДляЗапуска - ДоступноеВремя[ИндексТекущейСтроки].СвободнаяМощность;
				ДоступноеВремя[ИндексТекущейСтроки].СвободнаяМощность = 0;
				ИндексТекущейСтроки = ИндексТекущейСтроки + 1;
			КонецЕсли;
		КонецЦикла;
		ЗапланированныйЗапуск.ДоступнаяМощность = ЗапланированныйЗапуск.ДоступнаяМощность - МощностьДляЗапуска;
	КонецЦикла;
	
	Возврат ЗапланированныеЗапуски;

КонецФункции

//Возвращает отмененные запуски тестирования по проекту.
//
// Параметры:
//  Проект                - СправочникСсылка.Проекты - Проект, для которого ищутся запуски тестирования.
//  ДоступноеВремя        - ТаблицаЗначений - Доступное время и мощность для тестирования.
//       * ДатаВремяЗапуска   - Дата.
//       * ДоступнаяМощность  - Число.
//       * СвободнаяМощность  - Число.
// 
// Возвращаемое значение:
//   ТаблицаЗначений - Запланированные запуски тестирования.
//       * ЗапускТестирования - Документ.ЗапускТестирования.
//       * Ветка              - Справочник.Ветки.
//
Функция ОтмененныеЗапускиТестирования(Проект, ДоступноеВремя=Неопределено) Экспорт
	Если ДоступноеВремя = Неопределено Тогда
		ДоступноеВремя = ДоступноеВремяИМощностьДляТестирования(Проект);
	КонецЕсли;
	Если ДоступноеВремя.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ДатаНачала = ВремяНачалаТестированияПоДате(Проект, ДоступноеВремя[0].ДатаВремяЗапуска);
	ДатаОкончания = ВремяОкончанияТестированияПоДате(Проект, ДатаНачала);
	
	// Считываются уже запланированные запуски тестирования на доступное время, чтобы определить оставшиеся ресурсы.
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ЗапускТестирования.Ссылка КАК ЗапускТестирования,
	|	ЗапускТестирования.Ветка КАК Ветка,
	|	ЗапускТестирования.Дата КАК ДатаВремяЗапуска
	|ИЗ
	|	Документ.ЗапускТестирования КАК ЗапускТестирования
	|ГДЕ
	|	ЗапускТестирования.Настройка = ЗНАЧЕНИЕ(Справочник.НастройкиЗапускаТестирования.ПустаяСсылка)
	|	И НЕ ЗапускТестирования.Проведен
	|	И НЕ ЗапускТестирования.ЗапуститьТестыВыполненныеСОшибкой
	|	И ЗапускТестирования.Проект = &Проект
	|	И НЕ ЗапускТестирования.ПометкаУдаления
	|	И ЗапускТестирования.Дата МЕЖДУ &ДатаНачала И &ДатаОкончания
	|
	|УПОРЯДОЧИТЬ ПО
	|	ЗапускТестирования.Дата";
	
	Запрос.УстановитьПараметр("ДатаНачала", ДатаНачала);
	Запрос.УстановитьПараметр("ДатаОкончания", ДатаОкончания);
	Запрос.УстановитьПараметр("Проект", Проект);
	Возврат Запрос.Выполнить().Выгрузить();

КонецФункции

//Проверяет, есть ли в ветке изменения после указанного запуска тестирования.
//
// Параметры:
//  Проект                - СправочникСсылка.Проекты - Владелец ветки.
//  ИмяВетки              - Строка - Имя ветки. 
//  ИдентификаторЗапуска  - Строка - Идентификатор запуска тестирования. 
// 
// Возвращаемое значение:
//  Булево - Есть или нет изменения в ветке после указанного запуска тестирования.
//
Функция ЕстьИзмененияВВетке(Проект, ИмяВетки, ИмяВеткиПриемника, ИдентификаторЗапуска=Неопределено) Экспорт
	Попытка
		КоммитВетки = ИнформацияОВетке(Проект, ИмяВетки)["commit"]["id"];
		
		Если ЗначениеЗаполнено(ИдентификаторЗапуска) Тогда
			КоммитЗапуска = ИнформацияОЗапуске(Проект, ИдентификаторЗапуска)["sha"];
			Ответ = РазницаМеждуВетками(Проект, КоммитЗапуска, КоммитВетки); 
		Иначе
			Ответ = РазницаМеждуВетками(Проект, ИмяВеткиПриемника, ИмяВетки);
		КонецЕсли;
		ЕстьРазличия = ЕстьРазличияМеждуКоммитами(Ответ, Проект);
		ИнформацияОКоммитеВетки = ИнформацияОКоммите(Проект, КоммитВетки);
		БылиКонфликты = СтрНайти(ИнформацияОКоммитеВетки["message"], "Conflicts") <> 0;
		ПоследнийКоммитЭтоМердж = ИнформацияОКоммитеВетки["parent_ids"].Найти(КоммитЗапуска) <> Неопределено
									И ИнформацияОКоммитеВетки["parent_ids"].Количество() > 1;
		Если ПоследнийКоммитЭтоМердж Тогда
			Возврат (ПоследнийКоммитЭтоМердж И БылиКонфликты) ИЛИ ЕстьРазличия;
		Иначе
			Возврат ЕстьРазличия;
		КонецЕсли;
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Запуск тестирования.Получение изменений по ветке'"),
										УровеньЖурналаРегистрации.Ошибка,,,ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));

		Возврат Истина;
	КонецПопытки;
	
КонецФункции

//Проверяет, существует ли ветка на сервере.
//
// Параметры:
//  Проект                - СправочникСсылка.Проекты - Владелец ветки.
//  ИмяВетки              - Строка - Имя ветки. 
// 
// Возвращаемое значение:
//  Булево - Есть или нет ветка с таким именем на сервере.
//
Функция ВеткаСуществуетНаСервере(Проект, ИмяВетки) Экспорт
	Соединение = GitLabСоединение(Проект.РезультатыВыполненияТестовАдресСервера);
	ВеткаСуществует = Истина;
	Попытка
		КоммитВетки = ИнформацияОВетке(Проект, ИмяВетки);
	Исключение
		ВеткаСуществует = Ложь;
	КонецПопытки;
	Соединение = Неопределено;
	Возврат ВеткаСуществует;
	
КонецФункции

//Возвращает данные открытого запроса на слияния по данной ветке, если он существует
//
// Параметры:
//  Проект                - СправочникСсылка.Проекты - Владелец ветки.
//  ИмяВетки              - Строка - Имя ветки. 
//  ИмяВеткиПриемник      - Строка - Имя ветки. 
// 
// Возвращаемое значение:
//  Структура или Неопределено
//
Функция ДанныеОткрытогоЗапросаНаСлияниеПоВетке(Проект, ИмяВетки, ИмяВеткиПриемник) Экспорт
	
	Соединение = GitLabСоединение(Проект.РезультатыВыполненияТестовАдресСервера);
	Возврат ДанныеОткрытогоЗапросаНаСлияниеПоВеткеСлужебный(Проект, ИмяВетки, ИмяВеткиПриемник);
	
КонецФункции

//Запускает тестирование на сервере.
//
// Параметры:
//  Проект                - СправочникСсылка.Проекты - Проект, для которого создается запуск.
//  ИмяВетки              - Строка - Имя ветки на сервере тестирования. 
//  Параметры             - Структура - Параметры, которые передаются созданному запуску. 
// 
// Возвращаемое значение:
//  Структура - 
//     * ЗапросВыполненУспешно  - Булево - Истина, если запуск успешно был создан и Ложь если нет;
//     * Ответ                  - Строка - Созданный запуск или текст исключения;
//   
Функция ЗапуститьТестирование(Проект, ИмяВетки, Параметры=Неопределено) Экспорт
	Если Параметры = Неопределено Тогда
		Параметры = Новый Структура;
	КонецЕсли;
	МассивПараметров = Новый Массив;
	Для Каждого Параметр Из Параметры Цикл
		МассивПараметров.Добавить(Новый Структура("key, value", Параметр.Ключ, Строка(Параметр.Значение)));
	КонецЦикла;
	
	Результат = Новый Структура;
	Результат.Вставить("ЗапросВыполненУспешно", Ложь);
	Результат.Вставить("Ответ", "");
	
	Соединение = GitLabСоединение(Проект.РезультатыВыполненияТестовАдресСервера, 180);
	КодСостояния = 200;
	Попытка
		ДанныеЗапроса = Новый Структура;
		ДанныеЗапроса.Вставить("ref", ИмяВетки);
		ДанныеЗапроса.Вставить("variables", МассивПараметров);
		
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Запуск тестирования.Создание запуска тестирования в GitLab'"),
			УровеньЖурналаРегистрации.Информация,,,ЗаписатьОбъектJSON(ДанныеЗапроса));
		
		Ресурс = СтрШаблон("/api/v4/projects/%1/pipeline", 
								Тестирование.ЭкранироватьСпецсимволыWeb(Проект.РезультатыВыполненияТестовИмяПроектаНаСервере));
		Ответ = GitLabЗапрос(Соединение, Ресурс, Проект.РезультатыВыполненияТестовТокен,"POST",ДанныеЗапроса,КодСостояния);
		Результат.ЗапросВыполненУспешно = Истина;
		Результат.Ответ  = XMLСтрока(Ответ.id);
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Запущена сборка %1.'"),XMLСтрока(Ответ.id));
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Запуск тестирования.Создание запуска тестирования в GitLab'"),
			УровеньЖурналаРегистрации.Информация,,,ТекстСообщения);
		Результат.Вставить("ПодробныеДанные", Ответ);
		
	Исключение
		Результат.ЗапросВыполненУспешно = Ложь;
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Если КодСостояния = 400 И СтрНайти(ТекстОшибки, "Reference not found") <> 0 Тогда
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						  НСтр("ru = 'Ветка ""%1"" не найдена на сервере.'"),
						  ИмяВетки);
		КонецЕсли;
		
		Результат.Ответ = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку( 
							НСтр("ru = 'Не удалось запустить тестирование. Возникла ошибка: %1'"),
							ТекстОшибки);

		ЗаписьЖурналаРегистрации(НСтр("ru = 'Запуск тестирования.Создание запуска тестирования в GitLab'"),
									УровеньЖурналаРегистрации.Ошибка,,,ТекстОшибки);

	КонецПопытки;
	Соединение = Неопределено;
	Возврат Результат;

КонецФункции

//Отменяет созданный запуск тестирования на сервере.
//
// Параметры:
//  Проект                - СправочникСсылка.Проекты - Проект, для которого отменяется запуск.
//  ИдентификаторЗапуска  - Строка - Идентификатор запуска на сервере. 
// 
// Возвращаемое значение:
//  Структура - 
//     * ЗапросВыполненУспешно  - Булево - Истина, если запуск успешно был отменен и Ложь если нет;
//     * Ответ                  - Строка - Текст исключения;
//  
Функция ОтменитьТестирование(Проект, ИдентификаторЗапуска) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ЗапросВыполненУспешно", Ложь);
	Результат.Вставить("Ответ", "");
	
	Соединение = GitLabСоединение(Проект.РезультатыВыполненияТестовАдресСервера, 180);
	КодСостояния = 200;
	Попытка
		Ресурс = СтрШаблон("/api/v4/projects/%1/pipelines/%2/cancel", 
							Тестирование.ЭкранироватьСпецсимволыWeb(Проект.РезультатыВыполненияТестовИмяПроектаНаСервере), ИдентификаторЗапуска);
		Ответ = GitLabЗапрос(Соединение, Ресурс, Проект.РезультатыВыполненияТестовТокен,"POST",,КодСостояния);
		Результат.ЗапросВыполненУспешно = Истина;
		Результат.Ответ  = XMLСтрока(Ответ.id);	
	Исключение
		Результат.ЗапросВыполненУспешно = Ложь;
		ТекстОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		Если КодСостояния = 404 ИЛИ КодСостояния = 400 Тогда
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						  НСтр("ru = 'Запуск %1 не существует на сервере.'"),
						  ИдентификаторЗапуска);
		КонецЕсли;
			
		Результат.Ответ = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку( 
							НСтр("ru = 'Не удалось запустить тестирование. %1'"),
							ТекстОшибки);
	КонецПопытки;
	Соединение = Неопределено;
	Возврат Результат;
	
КонецФункции

//Информация о проекте, полученная у сервера тестирования.
//
// Параметры:
//  Проект   - СправочникСсылка.Проекты - Проект, из которого берётся информация для авторизации
//  ИдентификаторПроекта - Строка
// 
// Возвращаемое значение:
//  Структура - данные о ветке, полученные у сервера тестирования.
//  
Функция ИнформацияОПроекте(Проект, ИдентификаторПроекта) Экспорт
	ДанныеПроекта = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Проект,
		"РезультатыВыполненияТестовАдресСервера, РезультатыВыполненияТестовИмяПроектаНаСервере,РезультатыВыполненияТестовТокен");
	
	Соединение = GitLabСоединение(ДанныеПроекта.РезультатыВыполненияТестовАдресСервера);
	Ресурс = СтрШаблон("/api/v4/projects/%1", XMLСтрока(ИдентификаторПроекта));
	Ответ = GitLabЗапрос(Соединение, Ресурс, ДанныеПроекта.РезультатыВыполненияТестовТокен);
	Соединение = Неопределено;
	Возврат Ответ;
	
КонецФункции

//Информация о ветке, полученная у сервера тестирования.
//
// Параметры:
//  Проект   - СправочникСсылка.Проекты - Проект, для которого считывается информация.
//  ИмяВетки - Строка                   - Имя ветки. 
// 
// Возвращаемое значение:
//  Структура - данные о ветке, полученные у сервера тестирования.
//  
Функция ИнформацияОВетке(Проект, ИмяВетки) Экспорт
	ДанныеПроекта = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Проект,
		"РезультатыВыполненияТестовАдресСервера, РезультатыВыполненияТестовИмяПроектаНаСервере,РезультатыВыполненияТестовТокен");
	
	Если НЕ ЗначениеЗаполнено(ДанныеПроекта.РезультатыВыполненияТестовТокен) Тогда
		ВызватьИсключение НСтр("ru='Не указан токен проекта.'");
	КонецЕсли;	
	
	Соединение = GitLabСоединение(ДанныеПроекта.РезультатыВыполненияТестовАдресСервера);
	Ресурс = СтрШаблон("/api/v4/projects/%1/repository/branches/%2", 
						Тестирование.ЭкранироватьСпецсимволыWeb(ДанныеПроекта.РезультатыВыполненияТестовИмяПроектаНаСервере),
						Тестирование.ЭкранироватьСпецсимволыWeb(ИмяВетки));
	Ответ = GitLabЗапрос(Соединение, Ресурс, ДанныеПроекта.РезультатыВыполненияТестовТокен);
	Соединение = Неопределено;
	Возврат Ответ;
	
КонецФункции

//Информация о коммите, полученная у сервера тестирования.
//
// Параметры:
//  Проект   - СправочникСсылка.Проекты - Проект, для которого считывается информация.
//  Коммит - Строка                   - Хеш коммита.
// 
// Возвращаемое значение:
//  Структура - данные о коммите, полученные у сервера тестирования.
//  
Функция ИнформацияОКоммите(Проект, Коммит) Экспорт
	
	Соединение = GitLabСоединение(Проект.РезультатыВыполненияТестовАдресСервера);
	Ресурс = СтрШаблон("/api/v4/projects/%1/repository/commits/%2", 
						Тестирование.ЭкранироватьСпецсимволыWeb(Проект.РезультатыВыполненияТестовИмяПроектаНаСервере), 
						Коммит);
	Ответ = GitLabЗапрос(Соединение, Ресурс, Проект.РезультатыВыполненияТестовТокен);
	Соединение = Неопределено;
	Возврат Ответ;
	
КонецФункции

//Информация о дате последнего изменения файла, полученная у сервера тестирования.
//
// Параметры:
//  Проект - СправочникСсылка.Проекты - Проект, для которого считывается информация.
//  Ветка - СправочникСсылка.Ветки
//  ПутьКФайлу - Строка
// 
// Возвращаемое значение:
//  Дата, Неопределено
//  
Функция ДатаПоследнегоИзмененияФайла(Проект, Ветка, ПутьКФайлу) Экспорт
	
	ДанныеПроекта = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Проект,
		"РезультатыВыполненияТестовАдресСервера,РезультатыВыполненияТестовИмяПроектаНаСервере,РезультатыВыполненияТестовТокен");
	ДанныеВетки = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Ветка,"Имя");
	
	Соединение = GitLabСоединение(ДанныеПроекта.РезультатыВыполненияТестовАдресСервера);
	Ресурс = СтрШаблон("/api/v4/projects/%1/repository/commits?ref_name=%2&path=%3", 
						Тестирование.ЭкранироватьСпецсимволыWeb(ДанныеПроекта.РезультатыВыполненияТестовИмяПроектаНаСервере), 
						ДанныеВетки.Имя,
						ПутьКФайлу);
	Ответ = GitLabЗапрос(Соединение, Ресурс, ДанныеПроекта.РезультатыВыполненияТестовТокен);
	Соединение = Неопределено;
	
	Если ТипЗнч(Ответ) = Тип("Массив") И Ответ.Количество() > 0 Тогда
		Возврат Ответ[0].committed_date;
	КонецЕсли;	
	
	Возврат Неопределено;
	
КонецФункции

//Информация о запуске тестирования, полученная у сервера тестирования.
//
// Параметры:
//  Проект   - СправочникСсылка.Проекты - Проект, для которого считывается информация.
//  ИдентификаторЗапуска  - Строка - Идентификатор запуска на сервере. 
// 
// Возвращаемое значение:
//  Структура - данные о запуске тестирования, полученные у сервера тестирования.
//  
Функция ИнформацияОЗапуске(Проект, ИдентификаторЗапуска) Экспорт
	ИдентификаторЗапускаXML = XMLСтрока(ИдентификаторЗапуска);
	
	Соединение = GitLabСоединение(Проект.РезультатыВыполненияТестовАдресСервера);
	Ресурс = СтрШаблон("/api/v4/projects/%1/pipelines/%2", 
						Тестирование.ЭкранироватьСпецсимволыWeb(Проект.РезультатыВыполненияТестовИмяПроектаНаСервере), 
						ИдентификаторЗапускаXML);
	Ответ = GitLabЗапрос(Соединение, Ресурс, Проект.РезультатыВыполненияТестовТокен);
	Соединение = Неопределено;
	Возврат Ответ;
	
КонецФункции

//Информация о запуске тестирования, полученная у сервера тестирования.
//
// Параметры:
//  Проект   - СправочникСсылка.Проекты - Проект, для которого считывается информация.
//  ИдентификаторПроекта  - Строка - Идентификатор проекта на сервере. 
//  ИдентификаторЗапуска  - Строка - Идентификатор запуска на сервере. 
// 
// Возвращаемое значение:
//  Структура - данные о запуске тестирования, полученные у сервера тестирования.
//  
Функция ИнформацияОЗапускеПоИдентификаторуПроекта(Проект, ИдентификаторПроекта, ИдентификаторЗапуска) Экспорт
	ИдентификаторЗапускаXML = XMLСтрока(ИдентификаторЗапуска);
	
	Соединение = GitLabСоединение(Проект.РезультатыВыполненияТестовАдресСервера);
	Ресурс = СтрШаблон("/api/v4/projects/%1/pipelines/%2", 
						Тестирование.ЭкранироватьСпецсимволыWeb(ИдентификаторПроекта), 
						ИдентификаторЗапускаXML);
	Ответ = GitLabЗапрос(Соединение, Ресурс, Проект.РезультатыВыполненияТестовТокен);
	Соединение = Неопределено;
	Возврат Ответ;
	
КонецФункции


//Информация о запуске тестирования, полученная у сервера тестирования.
//
// Параметры:
//  Проект   - СправочникСсылка.Проекты - Проект, для которого считывается информация.
//  ИдентификаторДочернегоПроекта  - Строка - Идентификатор дочернего проекта на сервере. 
//  ИдентификаторЗапуска  - Строка - Идентификатор запуска на сервере. 
// 
// Возвращаемое значение:
//  Структура - данные о запуске тестирования, полученные у сервера тестирования.
//  
Функция ИнформацияОЗапускеДочернегоПроекта(Проект, ИдентификаторДочернегоПроекта, ИдентификаторЗапуска) Экспорт
	ИдентификаторЗапускаXML = XMLСтрока(ИдентификаторЗапуска);

	Соединение = GitLabСоединение(Проект.РезультатыВыполненияТестовАдресСервера);
	Ресурс = СтрШаблон("/api/v4/projects/%1/pipelines/%2", 
						Тестирование.ЭкранироватьСпецсимволыWeb(XMLСтрока(ИдентификаторДочернегоПроекта)),
						ИдентификаторЗапускаXML);
	Ответ = GitLabЗапрос(Соединение, Ресурс, Проект.РезультатыВыполненияТестовТокен);
	Соединение = Неопределено;
	Возврат Ответ;
	
КонецФункции

//Информация о мердж реквестах, созданных от ветки, полученная у сервера тестирования.
//
// Параметры:
//  Проект            - СправочникСсылка.Проекты - Проект, для которого считывается информация.
//  ИмяВеткиИсточника - Строка                   - Имя ветки источника мердж реквеста.
//  ИмяВеткиПриемника - Строка                   - Имя ветки приемника мердж реквеста. 
// 
// Возвращаемое значение:
//  Массив - данные о мердж реквестах, полученные у сервера тестирования.
// 
Функция CписокМерджРеквестов(Проект, ИмяВеткиИсточника, ИмяВеткиПриемника=Неопределено, Статус=Неопределено) Экспорт
	
	Соединение = GitLabСоединение(Проект.РезультатыВыполненияТестовАдресСервера);
	Ресурс = СтрШаблон("/api/v4/projects/%1/merge_requests?source_branch=%2&order_by=updated_at", 
						Тестирование.ЭкранироватьСпецсимволыWeb(Проект.РезультатыВыполненияТестовИмяПроектаНаСервере),
						Тестирование.ЭкранироватьСпецсимволыWeb(ИмяВеткиИсточника));
	Если Статус <> Неопределено Тогда 
		Ресурс = Ресурс + "&state=" + Статус;
	КонецЕсли;
	Если ИмяВеткиПриемника <> Неопределено Тогда 
		Ресурс = Ресурс + "&target_branch=" + Тестирование.ЭкранироватьСпецсимволыWeb(ИмяВеткиПриемника);
	КонецЕсли;
	Ответ = GitLabЗапрос(Соединение, Ресурс, Проект.РезультатыВыполненияТестовТокен);
	Соединение = Неопределено;
	Возврат Ответ;
	
КонецФункции

//Информация о коммитах в мердж реквесте.
//
// Параметры:
//  Проект                     - СправочникСсылка.Проекты - Проект, для которого считывается информация.
//  ИдентификаторМерджРеквеста - Строка                   - Имя ветки источника мердж реквеста.
// 
// Возвращаемое значение:
//  Массив - данные о коммитах в мердж реквесте.
// 
Функция CписокКоммитовМерджРеквеста(Проект, ИдентификаторМерджРеквеста) Экспорт
	ИдентификаторМерджРеквеста = XMLСтрока(ИдентификаторМерджРеквеста);

	Соединение = GitLabСоединение(Проект.РезультатыВыполненияТестовАдресСервера);
	Ресурс = СтрШаблон("/api/v4/projects/%1/merge_requests/%2/commits", 
						Тестирование.ЭкранироватьСпецсимволыWeb(Проект.РезультатыВыполненияТестовИмяПроектаНаСервере),
						ИдентификаторМерджРеквеста);
	Ответ = GitLabЗапрос(Соединение, Ресурс, Проект.РезультатыВыполненияТестовТокен,,,,Истина);
	Соединение = Неопределено;
	Возврат Ответ;
	
КонецФункции

//Информация о различиях между двумя ветками, полученная у сервера тестирования.
//
// Параметры:
//  Проект      - СправочникСсылка.Проекты - Проект, для которого считывается информация.
//  ПерваяВетка - Строка                   - Имя ветки или хеш коммита для сравнения. 
//  ВтораяВетка - Строка                   - Имя ветки или хеш коммита для сравнения. 
// 
// Возвращаемое значение:
//  Структура - данные о различиях между ветками, полученные у сервера тестирования.
// 
Функция РазницаМеждуВетками(Проект, ПерваяВетка, ВтораяВетка) Экспорт
	РеквизитыПроекта = 
		ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Проект, "РезультатыВыполненияТестовАдресСервера, 
															|РезультатыВыполненияТестовИмяПроектаНаСервере, 
															|РезультатыВыполненияТестовТокен");
	Соединение = GitLabСоединение(РеквизитыПроекта.РезультатыВыполненияТестовАдресСервера);
	Ресурс = СтрШаблон("/api/v4/projects/%1/repository/compare?from=%2&to=%3", 
							Тестирование.ЭкранироватьСпецсимволыWeb(РеквизитыПроекта.РезультатыВыполненияТестовИмяПроектаНаСервере), 
							Тестирование.ЭкранироватьСпецсимволыWeb(ПерваяВетка), Тестирование.ЭкранироватьСпецсимволыWeb(ВтораяВетка));
	Ответ = GitLabЗапрос(Соединение, Ресурс, РеквизитыПроекта.РезультатыВыполненияТестовТокен);
	Соединение = Неопределено;
	Возврат Ответ;
	
КонецФункции

// Формирует гиперссылку на коммит в системе хранения кода по хешу коммита.
//
// Параметры:
//  Проект        - Тип - СправочникСсылка.Проекты.
//  Идентификатор - Тип - Строка.
//
// Возвращаемое значение:
//  Гиперссылка - Тип - Строка.
//
Функция АдресКоммита(Проект, Идентификатор) Экспорт
	
	Возврат СсылкаПоПроекту(Проект) + "-/commit/" + Идентификатор;
	
КонецФункции 

// Возвращает двоичные данные файла из репозитория
//
// Параметры:
//  Проект   - СправочникСсылка.Проекты - Проект, для которого считывается информация.
//  ПутьКФайлу - Строка                 - Относительный путь к файлу в репозитории.
//  ИдентификаторКоммита - Строка       - Коммит или имя ветки на который надо получать данные.
// 
// Возвращаемое значение:
//  Структура - данные о коммите, полученные у сервера тестирования.
//  
Функция ДвоичныеДанныеФайлаИзРепозитория(Проект, ПутьКФайлу, ИдентификаторКоммита) Экспорт
	
	ДанныеПодключенияПроекта = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(
		Проект,"РезультатыВыполненияТестовАдресСервера,РезультатыВыполненияТестовИмяПроектаНаСервере,КаталогТестовВРепозитории");
	Соединение = GitLabСоединение(ДанныеПодключенияПроекта.РезультатыВыполненияТестовАдресСервера);
	
	Ресурс = "/api/v4/projects/%ИмяПроекта/repository/files/%ПутьКФайлу?ref=%ИдентификаторКоммита";
	Ресурс = СтрЗаменить(Ресурс, "%ИмяПроекта",
		Тестирование.ЭкранироватьСпецсимволыWeb(ДанныеПодключенияПроекта.РезультатыВыполненияТестовИмяПроектаНаСервере));
	Ресурс = СтрЗаменить(Ресурс, "%ПутьКФайлу", Тестирование.ЭкранироватьСпецсимволыWeb(ПутьКФайлу));
		
	Ресурс = СтрЗаменить(Ресурс, "%ИдентификаторКоммита", Тестирование.ЭкранироватьСпецсимволыWeb(ИдентификаторКоммита));
	
	Ответ = GitLabЗапрос(Соединение, Ресурс, Проект.РезультатыВыполненияТестовТокен);
	Соединение = Неопределено;
	Возврат Base64Значение(Ответ.content);
	
КонецФункции

// Возвращает двоичные данные файла из репозитория
//
// Параметры:
//  Проект   - СправочникСсылка.Проекты - Проект, для которого считывается информация.
//  ПутьКФайлу - Строка                 - Относительный путь к файлу в репозитории.
//  ИдентификаторКоммита - Строка       - Коммит или имя ветки на который надо получать данные.
// 
// Возвращаемое значение:
//  Структура - данные о коммите, полученные у сервера тестирования.
//  
Функция ТекстФайлаИзРепозитория(Проект, ПутьКФайлу, ИдентификаторКоммита) Экспорт
	
	Попытка
		ДвоичныеДанные = ДвоичныеДанныеФайлаИзРепозитория(Проект, ПутьКФайлу, ИдентификаторКоммита);
	Исключение
		Возврат "";
	КонецПопытки;
	Поток = ДвоичныеДанные.ОткрытьПотокДляЧтения();
	ЧтениеТекста = Новый ЧтениеТекста(Поток, КодировкаТекста.UTF8);
	ТекстФайла = ЧтениеТекста.Прочитать();
	ЧтениеТекста.Закрыть(); 
	
	Возврат ТекстФайла;
	
КонецФункции

// Создает ветку в GitLab, если она не существует.
//
// Параметры:
//  Проект                - СправочникСсылка.Проекты - Владелец ветки.
//  ИмяВетки              - Строка - Имя ветки. 
//  ИмяВеткиИсточник      - Строка - Имя ветки источник. 
// 
// Возвращаемое значение:
//  Булево - Истина, если ветка создалась. Иначе выдает исключение.
//
Функция СоздатьВеткуВGitLab(Проект, ИмяВетки, ИмяВеткиИсточник) Экспорт
	
	ДанныеПроекта = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Проект,
		"РезультатыВыполненияТестовАдресСервера, РезультатыВыполненияТестовИмяПроектаНаСервере,РезультатыВыполненияТестовТокен");
	
	Если НЕ ЗначениеЗаполнено(ДанныеПроекта.РезультатыВыполненияТестовТокен) Тогда
		ВызватьИсключение НСтр("ru='Не указан токен проекта.'");
	КонецЕсли;
	
	Соединение = GitLabСоединение(ДанныеПроекта.РезультатыВыполненияТестовАдресСервера);
	Ресурс = "/api/v4/projects/%ИмяПроекта/repository/branches?branch=%ИмяВетки&ref=%ИмяВеткиИсточник";
	Ресурс = СтрЗаменить(Ресурс, "%ИмяПроекта",
		Тестирование.ЭкранироватьСпецсимволыWeb(ДанныеПроекта.РезультатыВыполненияТестовИмяПроектаНаСервере));
	Ресурс = СтрЗаменить(Ресурс, "%ИмяВеткиИсточник", Тестирование.ЭкранироватьСпецсимволыWeb(ИмяВеткиИсточник));
	Ресурс = СтрЗаменить(Ресурс, "%ИмяВетки", Тестирование.ЭкранироватьСпецсимволыWeb(ИмяВетки));
	
	Запрос = Новый HTTPЗапрос(Ресурс);
	Запрос.Заголовки.Вставить("PRIVATE-TOKEN", ДанныеПроекта.РезультатыВыполненияТестовТокен);
	Попытка
		Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	Исключение
		ВызватьИсключение ОписаниеОшибки();
	КонецПопытки;
	ОтветСтрокой = Ответ.ПолучитьТелоКакСтроку();
	Если Ответ.КодСостояния = 400 И СтрНайти(ОтветСтрокой, "Branch already exists") <> 0 Тогда
		ВызватьИсключение СтрШаблон(
			НСтр("ru = 'Ветка с именем %1 уже существует на сервере'"),
			ИмяВетки);
	КонецЕсли;
	Если Ответ.КодСостояния <> 201 Тогда 
		ВызватьИсключение СтрШаблон(
			НСтр("ru = 'При запросе: %1
			           |Сервер вернул код состояния: %2'"),
			Запрос.АдресРесурса,
			Строка(Ответ.КодСостояния) + Символы.ПС + Ответ.ПолучитьТелоКакСтроку());
	КонецЕсли;
	Возврат Истина;
КонецФункции

// Удаляет ветку в GitLab, если она существует.
//
// Параметры:
//  Проект                - СправочникСсылка.Проекты - Владелец ветки.
//  ИмяВетки              - Строка - Имя ветки.
// 
// Возвращаемое значение:
//  Булево - Истина, если ветка удалена. Иначе выдает исключение.
//
Функция УдалитьВеткуВGitLab(Проект, ИмяВетки) Экспорт
	
	ДанныеПроекта = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Проект,
		"РезультатыВыполненияТестовАдресСервера, РезультатыВыполненияТестовИмяПроектаНаСервере,РезультатыВыполненияТестовТокен");
	
	Если НЕ ЗначениеЗаполнено(ДанныеПроекта.РезультатыВыполненияТестовТокен) Тогда
		ВызватьИсключение НСтр("ru='Не указан токен проекта.'");
	КонецЕсли;
	
	Соединение = GitLabСоединение(ДанныеПроекта.РезультатыВыполненияТестовАдресСервера);
	Ресурс = "/api/v4/projects/%ИмяПроекта/repository/branches/%ИмяВетки";
	Ресурс = СтрЗаменить(Ресурс, "%ИмяПроекта",
		Тестирование.ЭкранироватьСпецсимволыWeb(ДанныеПроекта.РезультатыВыполненияТестовИмяПроектаНаСервере));
	Ресурс = СтрЗаменить(Ресурс, "%ИмяВетки", Тестирование.ЭкранироватьСпецсимволыWeb(ИмяВетки));
	
	Запрос = Новый HTTPЗапрос(Ресурс);
	Запрос.Заголовки.Вставить("PRIVATE-TOKEN", ДанныеПроекта.РезультатыВыполненияТестовТокен);
	Попытка
		Ответ = Соединение.Удалить(Запрос);
	Исключение
		ВызватьИсключение ОписаниеОшибки();
	КонецПопытки;
	ОтветСтрокой = Ответ.ПолучитьТелоКакСтроку();
	Если Ответ.КодСостояния = 404 И СтрНайти(ОтветСтрокой, "Branch Not Found") <> 0 Тогда
		ВызватьИсключение СтрШаблон(
			НСтр("ru = 'Ветка с именем %1 не существует на сервере'"),
			ИмяВетки);
	ИначеЕсли Ответ.КодСостояния > 299 Тогда 
		ВызватьИсключение СтрШаблон(
			НСтр("ru = 'При запросе: %1
			           |Сервер вернул код состояния: %2'"),
			Запрос.АдресРесурса,
			Строка(Ответ.КодСостояния) + Символы.ПС + Ответ.ПолучитьТелоКакСтроку());
	КонецЕсли;
	Возврат Истина;
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции
	
Процедура ЗапуститьОтложенныеЗапускиТестирования(Проект)
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ЗапускТестирования.Ссылка КАК Ссылка
	|ИЗ
	|	Документ.ЗапускТестирования КАК ЗапускТестирования
	|ГДЕ
	|	ЗапускТестирования.Проект = &Проект
	|	И НЕ ЗапускТестирования.Проведен
	|	И НЕ ЗапускТестирования.ПометкаУдаления
	|	И ПОДСТРОКА(ЗапускТестирования.Pipeline_ID, 1, 1) ПОДОБНО """"
	|	И ЗапускТестирования.Настройка <> ЗНАЧЕНИЕ(Справочник.НастройкиЗапускаТестирования.ПустаяСсылка)
	|	И ЗапускТестирования.Дата МЕЖДУ &ДеньНазад И &ТекущаяДата";
	
	ТекущаяДата = ТекущаяДата();
	Запрос.УстановитьПараметр("ТекущаяДата", ТекущаяДата);
	Запрос.УстановитьПараметр("ДеньНазад", ТекущаяДата-24*60*60);
	Запрос.УстановитьПараметр("Проект", Проект);
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Попытка
			ЗапускОбъект = Выборка.Ссылка.ПолучитьОбъект();
			ЗапускОбъект.Записать(РежимЗаписиДокумента.Проведение);
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Запуск тестирования.Проведение отложенного запуска тестирования'"),
										УровеньЖурналаРегистрации.Ошибка,,,ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
	КонецЦикла;

КонецПроцедуры

Функция ПроектыКОбработке()
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Проекты.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.Проекты КАК Проекты
		|ГДЕ
		|	Проекты.ЗапускатьАвтоматическоеТестирование";
	
	
	Возврат Запрос.Выполнить().Выгрузить();

КонецФункции	 

Функция GitLabСоединение(Сервер,Таймаут=360)
	УстановитьПривилегированныйРежим(Истина);	
	OpenSSL = Новый ЗащищенноеСоединениеOpenSSL;
	Соединение = Новый HTTPСоединение(Сервер,,,,, Таймаут, OpenSSL);
	
	Возврат Соединение;
	
КонецФункции

Функция GitLabЗапрос(Соединение, Ресурс, Токен, Метод="GET", Данные=Неопределено, 
					КодСостояния=Неопределено, ЦиклПоСтраницам=Ложь, МаксимумЗаписейПоСтраницам=500)
	УстановитьПривилегированныйРежим(Истина);					
	СчетчикСтраниц = 1;
	КоличествоЗаписейВСтранице = 100;
	Результат = Новый Массив;
	Пока Истина Цикл
		Запрос = Новый HTTPЗапрос;
		Запрос.АдресРесурса = Ресурс;
		Если ЦиклПоСтраницам Тогда
			ПервыйСимвол = "?";
			Если СтрНайти(Запрос.АдресРесурса, "?") > 0 Тогда
				ПервыйСимвол = "&";
			КонецЕсли;
			Запрос.АдресРесурса = Запрос.АдресРесурса + ПервыйСимвол + СтрШаблон("page=%1&per_page=%2", СчетчикСтраниц, КоличествоЗаписейВСтранице);
		КонецЕсли;
		Запрос.Заголовки.Вставить("PRIVATE-TOKEN", Токен);
		Если Данные<> Неопределено Тогда
			ЗаписьJSON = Новый ЗаписьJSON;
			ЗаписьJSON.УстановитьСтроку();
			ЗаписатьJSON(ЗаписьJSON, Данные);
			
			Запрос.Заголовки.Вставить("Content-Type", "application/json; charset=UTF-8");
			Запрос.УстановитьТелоИзСтроки(ЗаписьJSON.Закрыть());
			ЗаписьJSON = Неопределено;
		КонецЕсли;
		
		Ответ = Соединение.ВызватьHTTPМетод(Метод, Запрос);
		КодСостояния = Ответ.КодСостояния;
		СтрокаРезультата = Ответ.ПолучитьТелоКакСтроку();

		Запрос = Неопределено;
		Если Цел(Ответ.КодСостояния/100) <> 2 Тогда 
			ТекстИсключения = СтрокаРезультата;
			Попытка
				Результат = СтрокаJSONВСтруктуру(СтрокаРезультата);
				Если Результат.Свойство("error") Тогда
					ТекстИсключения = Результат.error;
				ИначеЕсли Результат.Свойство("message") Тогда 
					ТекстИсключения = Результат.message;
					Если ТипЗнч(ТекстИсключения) = Тип("Структура") 
						И ТекстИсключения.Свойство("base") Тогда
						ТекстИсключения = ТекстИсключения.base;
						Если ТипЗнч(ТекстИсключения) = Тип("Массив") Тогда
							ТекстИсключения = СтрСоединить(ТекстИсключения, Символы.ПС); 
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			Исключение
				ТекстИсключения = СтрокаРезультата;
			КонецПопытки;
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Запуск тестирования.Gitlab запрос'"),
								УровеньЖурналаРегистрации.Ошибка,,,
								СтрШаблон(
									НСтр("ru = 'При запросе: %1
									           |Сервер вернул код состояния: %2
											   |Строка результата: %3'"),
									Ресурс,
									Ответ.КодСостояния,
									СтрокаРезультата));
			
			ВызватьИсключение ТекстИсключения;
		КонецЕсли;
		
		ТекущийОтвет = СтрокаJSONВСтруктуру(СтрокаРезультата);
		Если НЕ ЦиклПоСтраницам Тогда
			Результат = ТекущийОтвет;
			Прервать;
		КонецЕсли;
		
		Если ТекущийОтвет.Количество() = 0 Тогда
			Прервать;
		КонецЕсли;
		Для Каждого Элемент Из ТекущийОтвет Цикл
			Результат.Добавить(Элемент);
		КонецЦикла;
		Если СчетчикСтраниц * КоличествоЗаписейВСтранице > МаксимумЗаписейПоСтраницам Тогда
			Прервать;
		КонецЕсли;
		
		СчетчикСтраниц = СчетчикСтраниц+ 1;
	
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

Функция СтрокаJSONВСтруктуру(Значение, ИменаСвойствСоЗначениямиДата = Неопределено)
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(Значение);
	
	Если ИменаСвойствСоЗначениямиДата = Неопределено Тогда
		ИменаСвойствСоЗначениямиДата = Новый Массив;
	КонецЕсли;	 
	ИменаСвойствСоЗначениямиДата.Добавить("created_at");
	ИменаСвойствСоЗначениямиДата.Добавить("ДатаПоследнейПроверки");
	
	Результат = ПрочитатьJSON(ЧтениеJSON,, ИменаСвойствСоЗначениямиДата);
	
	ИменаСвойствДатаНеопределено = Новый Массив;
	ИменаСвойствДатаНеопределено.Добавить("updated_at");
	ИменаСвойствДатаНеопределено.Добавить("finished_at");
	ИменаСвойствДатаНеопределено.Добавить("started_at");
	ИменаСвойствДатаНеопределено.Добавить("artifacts_expire_at");
	ИменаСвойствДатаНеопределено.Добавить("committed_date");
	
	РезультатМассив = Новый Массив;
	Если Тип("Структура") = ТипЗнч(Результат) Тогда
		РезультатМассив.Добавить(Результат);
	Иначе 
		РезультатМассив = Результат;
	КонецЕсли;
	Для Каждого ЭлементРезультата Из РезультатМассив Цикл
		Если НЕ Тип("Структура") = ТипЗнч(ЭлементРезультата) Тогда
			Продолжить;
		КонецЕсли;
		Для Каждого Имя Из ИменаСвойствДатаНеопределено Цикл
			Если ЭлементРезультата.Свойство(Имя) 
				И ЭлементРезультата[Имя] <> Неопределено Тогда
				ЭлементРезультата[Имя] = ПрочитатьДатуJSON(ЭлементРезультата[Имя], ФорматДатыJSON.ISO);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	ИменаСвойствСоЗначениямиДата = Неопределено;
	ИменаСвойствДатаНеопределено = Неопределено;
	
	ЧтениеJSON.Закрыть();
	
	Возврат Результат;
	
КонецФункции

//Возвращает время начала тестирования проекта по дате.
//
// Параметры:
//  Проект                - СправочникСсылка.Проекты  - Проект, для которого формируется расписание.
//  ТекущаяДата           - Дата                      - Дата, на которую формируется расписание. 
//
// Возвращаемое значение:
//   ДатаВремя - Время начала тестирования проекта.
Функция ВремяНачалаТестированияПоДате(Проект, ТекущаяДата=Неопределено)
	
	Если ТекущаяДата = Неопределено Тогда
		ТекущаяДата = ТекущаяДата();
	КонецЕсли;

	ДатаНачала = НачалоДня(ТекущаяДата);
	СдвигИндекса = (ДеньНедели(ДатаНачала)-1)*24;
	
	Количество = Проект.СлотыТестирования.Количество();
	Для Час = 0 По 12 Цикл
		Индекс = СдвигИндекса + Час;
		Если Индекс >= Количество ИЛИ Индекс < 0 Тогда
			Прервать;
		КонецЕсли;
		Если Проект.СлотыТестирования[Индекс].ДоступнаяМощность = 0 Тогда
			ДатаНачала = НачалоДня(ДатаНачала) + Час*60*60;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ДатаНачала;
	
КонецФункции

Функция ВремяОкончанияТестированияПоДате(Проект, ДатаНачала)
	
	СпустяСутки = ДатаНачала+24*60*60;
	ДатаОкончания = Макс(СпустяСутки, ВремяНачалаТестированияПоДате(Проект, СпустяСутки));
	Возврат ДатаОкончания;
	
КонецФункции

Функция СсылкаПоПроекту(Проект)
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Проекты.АдресGitСервера КАК АдресGitСервера
		|ИЗ
		|	Справочник.Проекты КАК Проекты
		|ГДЕ
		|	Проекты.Ссылка = &Ссылка";
	
	Запрос.УстановитьПараметр("Ссылка", Проект);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	ТекстСсылки = "";
	
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		ТекстСсылки = ВыборкаДетальныеЗаписи.АдресGitСервера;
	КонецЦикла;
	
	ТекстСсылки = СтрЗаменить(ТекстСсылки,"git@","");
	ТекстСсылки = СтрЗаменить(ТекстСсылки,":","/");
	ТекстСсылки = СтрЗаменить(ТекстСсылки,".git","");
	
	Если Прав(ТекстСсылки,1) <> "/" Тогда
		ТекстСсылки = ТекстСсылки + "/";
	КонецЕсли;	 
	
	ТекстСсылки = "https://" + ТекстСсылки;
	Возврат ТекстСсылки;
	
КонецФункции

Функция ЕстьРазличияМеждуКоммитами(ДанныеГитСервера, Проект)
	
	Возврат ЕстьРазличияПоДаннымИзмененийФайлов(ДанныеГитСервера, Проект);
	
КонецФункции	 

Функция ЕстьРазличияПоДаннымИзмененийФайлов(ДанныеГитСервера, Проект)
	
	ДанныеПоРазличиям = ДанныеГитСервера["diffs"];
	
	ПутьКПроектуВРепозитории = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Проект, "ПутьКПроектуВРепозитории");
	
	ПутьКИсходникам = ПутьКПроектуВРепозитории + "/src/";
	ПутиИсключения = ПутиИсключения();
	
	Для Каждого ТекИзменение Из ДанныеПоРазличиям Цикл
		ПутьКФайлуНРег = НРег(ТекИзменение.new_path);
		
		ИзмененныйФайл = Новый Файл(ПутьКФайлуНРег);
		ФайлРодительскогоКаталога = Новый Файл(ИзмененныйФайл.Путь);
		Если НРег(ФайлРодительскогоКаталога.Имя) = "help" Тогда
			// измененные файлы справки игнорируются
			Продолжить;
		КонецЕсли;	 
		
		Если Лев(ПутьКФайлуНРег, СтрДлина(ПутьКИсходникам)) = НРег(ПутьКИсходникам) Тогда
			ЭтоИсключение = Ложь;
			Для Каждого ТекИсключение Из ПутиИсключения Цикл
				Если Прав(ПутьКФайлуНРег, СтрДлина(ТекИсключение)) = НРег(ТекИсключение) Тогда
					ЭтоИсключение = Истина;
					Прервать;
				КонецЕсли;	 
			КонецЦикла;	 
			
			Если НЕ ЭтоИсключение Тогда
				// значит это изменения в коде конфигурации
				Возврат Истина;
			КонецЕсли;	 
			
		КонецЕсли;	 
		
	КонецЦикла;	 
	
	Возврат Ложь;
	
КонецФункции	

Функция ПутиИсключения()
	
	Массив = Новый Массив;
	Массив.Добавить("/src/Configuration/MobileClientSign.bin");
	
	Возврат Массив;
	
КонецФункции	 

Функция ДанныеОткрытогоЗапросаНаСлияниеПоВеткеСлужебный(Проект, ИмяВетки, ИмяВеткиПриемник) Экспорт
	
	Попытка
		ИнформацияОВетке = ИнформацияОВетке(Проект, ИмяВетки);
	Исключение
		ТекстОшибки = ОписаниеОшибки();
		Если Найти(НРег(ТекстОшибки), НРег("Branch Not Found")) > 0 Тогда
			ВызватьИсключение СтрШаблон(НСтр("ru='Ветка <%1> не найдена на гит сервере.'"), ИмяВетки);
		Иначе
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;	 
	КонецПопытки;
	
	Результат = CписокМерджРеквестов(Проект, ИмяВетки, ИмяВеткиПриемник);
	
	Если ТипЗнч(Результат) <> Тип("Массив") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если Результат.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Для Каждого ТекДанные Из Результат Цикл
		Если ТекДанные.state = "opened" Тогда
			Возврат ТекДанные; 
		КонецЕсли;	 
	КонецЦикла;	 
	
	Возврат Неопределено;
	
КонецФункции

Функция ЗаписатьОбъектJSON(ДанныеJSON)
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, ДанныеJSON);
	Возврат ЗаписьJSON.Закрыть();
КонецФункции

#КонецОбласти
