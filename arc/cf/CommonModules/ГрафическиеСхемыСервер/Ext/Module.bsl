# Область ПрограммныйИнтерфейс

// Формирует схему конечной функции
//
Функция СхемаКонечнойФункции(РеквизитыФункции, ВходящиеДанные, ДанныеУправления, Исполнители, ГиперссылкиСвязей) Экспорт
	
	ГиперссылкиСвязей = Новый Структура;
	
	МакетСхемы = Справочники.ФункцииСистемы.ПолучитьМакет("ФункцияБезСвязей");
	
	Сериализатор = Новый СериализаторXDTO(ФабрикаXDTO);
	ОбъектXDTOСхема = Сериализатор.ЗаписатьXDTO(МакетСхемы);
	
	ЭлементыСхемы = ОбъектXDTOСхема.ПолучитьСписок("item");
	
	Границы = Новый Структура;
	ЗаголовокСхемы = Неопределено;
	БлокФункции = Неопределено;
	
	Счетчики = Новый Структура;
	Счетчики.Вставить("МаксимальныйИдентификатор",0);
	Счетчики.Вставить("КоличествоСвязей", 0);
	Счетчики.Вставить("КоличествоЛиний", 0);
	Счетчики.Вставить("КоличествоФункций", 0);
	Счетчики.Вставить("Порядок", 0);
	
	MaкcИД = 0;
	Порядок = 0;
	
	ИнициализироватьЭлементыСхемыКонечнойФункции(ЭлементыСхемы, Границы, ЗаголовокСхемы,
	                                             БлокФункции, MaкcИД, Порядок, Счетчики);
	
	Настройки = НастройкиФорматированияСхем();
	
	УстановитьЗаголовокСхемы(ЗаголовокСхемы, РеквизитыФункции);
	УстановитьЗаголовокБлока(БлокФункции, РеквизитыФункции, Настройки);
	
	УстановитьОтображениеБлокаКонечнойФункции(БлокФункции, РеквизитыФункции, Настройки);
	
	Потребители = ПотребителиРезультатаКонечнойФункции(РеквизитыФункции.Ссылка);
	
	КоординатыГраниц =
	    РасчетныеКоординатыГраницКонечнойФункции(ВходящиеДанные, ДанныеУправления,
		                                         Исполнители, Потребители, Настройки);
	
	УстановитьКоординатыГраниц(Границы, КоординатыГраниц);
	УстановитьКоординатыБлокаКонечнойФункции(БлокФункции, КоординатыГраниц, Настройки);
	
	Связи = Новый Структура;
	Связи.Вставить("ВходящиеДанные", ВходящиеДанные);
	Связи.Вставить("ДанныеУправления", ДанныеУправления);
	Связи.Вставить("Исполнители", Исполнители);
	Связи.Вставить("Потребители", Потребители);
	
	АгрегатыИСвязи = АгрегатыИСвязиКонечнойФункции(РеквизитыФункции, Связи);
	
	Связи.Вставить("АгрегатыИСвязи", АгрегатыИСвязи);
	
	ДобавитьСвязиКонечнойФункции(ЭлементыСхемы, РеквизитыФункции, Связи, КоординатыГраниц,
	                             Настройки, Счетчики, ГиперссылкиСвязей);
	
	ОбъектXDTOСхема.EnableGrid = Истина;
	ОбъектXDTOСхема.DrawGridMode = РежимОтрисовкиСеткиГрафическойСхемы.НеРисовать;
	
	Схема = Сериализатор.ПрочитатьXDTO(ОбъектXDTOСхема);
	
	Возврат Схема;
	
КонецФункции

// Формирует схему неконечной функции
//
Функция СхемаНеконечнойФункции(РеквизитыФункции, ГиперссылкиСвязей) Экспорт
	
	ГиперссылкиСвязей = Новый Структура;
	
	МакетСхемы = Справочники.ФункцииСистемы.ПолучитьМакет("ФункцияБезБлока");
	
	Сериализатор = Новый СериализаторXDTO(ФабрикаXDTO);
	ОбъектXDTOСхема = Сериализатор.ЗаписатьXDTO(МакетСхемы);
	
	ЭлементыСхемы = ОбъектXDTOСхема.ПолучитьСписок("item");
	
	Границы = Новый Структура;
	ЗаголовокСхемы = Неопределено;
	БлокФункции = Неопределено;
	
	Счетчики = Новый Структура;
	Счетчики.Вставить("МаксимальныйИдентификатор",0);
	Счетчики.Вставить("КоличествоСвязей", 0);
	Счетчики.Вставить("КоличествоЛиний", 0);
	Счетчики.Вставить("КоличествоФункций", 0);
	Счетчики.Вставить("Порядок", 0);
	
	MaкcИД = 0;
	Порядок = 0;
	
	ИнициализироватьЭлементыСхемыНеконечнойФункции(ЭлементыСхемы, Границы, ЗаголовокСхемы,
	                                               MaкcИД, Порядок, Счетчики);
												   
	Настройки = НастройкиФорматированияСхем();
	
	УстановитьЗаголовокСхемы(ЗаголовокСхемы, РеквизитыФункции);
	
	ДанныеОФункцияхИСвязях = ДочерниеФункцииИСвязи(РеквизитыФункции.Ссылка, Настройки);
	
	ДочерниеФункции = ДанныеОФункцияхИСвязях.ДочерниеФункции;
	
	КоличествоДочернихФункций = ДочерниеФункции.Количество();
	
	ДанныеОКоличествеАгрегатовСвязей = КоличествоБлоковАгрегатовСвязей(ДанныеОФункцияхиСвязях);
	
	ДанныеОФункцияхИСвязях.Вставить("ДанныеОКоличествеАгрегатовСвязей", ДанныеОКоличествеАгрегатовСвязей);
	
	КоординатыГраниц = РасчетныеКоординатыГраницНеконечнойФункцииПоАгрегатам(КоличествоДочернихФункций,
	                                                                             ДанныеОКоличествеАгрегатовСвязей,
																				 Настройки);
	
	УстановитьКоординатыГраниц(Границы, КоординатыГраниц);
	
	ИнформацияОБлокахФункций = ДобавитьБлокиФункций(ЭлементыСхемы, ДанныеОФункцияхИСвязях, КоординатыГраниц,
	                                                         Счетчики, Настройки, ГиперссылкиСвязей);
	
	ДобавитьСвязиДочернихФункций(ЭлементыСхемы, ИнформацияОБлокахФункций, ДанныеОФункцияхИСвязях,
	                             КоординатыГраниц, Счетчики, Настройки, ГиперссылкиСвязей);
															 
	ОбъектXDTOСхема.EnableGrid = Истина;
	ОбъектXDTOСхема.DrawGridMode = РежимОтрисовкиСеткиГрафическойСхемы.НеРисовать;
	
	Схема = Сериализатор.ПрочитатьXDTO(ОбъектXDTOСхема);
	
	Возврат Схема;
	
КонецФункции

// Устанавливает отображение блока функции, являющейся учетным механизмом
//
// Параметры:
//  БлокФункции - объект XDTO - элемент, для которого устанавливается отображение
//
Процедура УстановитьОтображениеУчетногоМеханизма(БлокФункции)
	
	ЦветБлока =  WebЦвета.Хаки;
	БлокФункции.BackColor = ЦветБлока;
	
КонецПроцедуры

// Устанавливает отображение блока функции, являющейся отчетом
//
// Параметры:
//  БлокФункции - объект XDTO - элемент, для которого устанавливается отображение
//
Процедура УстановитьОтображениеОтчета(БлокФункции)
	
	ЦветБлока =  WebЦвета.Розовый;
	БлокФункции.BackColor = ЦветБлока;
	
КонецПроцедуры

Процедура УстановитьОтображениеСвязиБезСсылки(БлокФункции, ВидСвязи)
	
	Если ВидСвязи = "Исполнитель" Тогда
		БлокФункции.Transparent = Ложь;
	КонецЕсли;
	
	ЦветБлока =  WebЦвета.Желтый;
	БлокФункции.BackColor = ЦветБлока;
	
КонецПроцедуры

Процедура УстановитьОтображениеБлокаКонечнойФункции(БлокФункции, РеквизитыФункции, Настройки)
	
	Если БлокФункции = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если НЕ Настройки.ОтображатьБлокКонечнойФункции Тогда
		БлокФункции.Shape = ФигурыГрафическойСхемы.Нет;
	КонецЕсли;
	
	Если РеквизитыФункции.ТипФункции = Перечисления.ТипыФункций.УчетныйМеханизм Тогда
		УстановитьОтображениеУчетногоМеханизма(БлокФункции);
	ИначеЕсли РеквизитыФункции.ТипФункции = Перечисления.ТипыФункций.Отчет Тогда
		УстановитьОтображениеОтчета(БлокФункции);
	Иначе
		Если НЕ Настройки.ОтображатьБлокКонечнойФункции Тогда
			БлокФункции.Transparent = Истина;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

# КонецОбласти

# Область СлужебныеПроцедурыИФункции

# Область СлужебныеПроцедурыИФункцииДляРаботыСоСхемамиПосредствомXDTO

Функция СписокЭлементовМакета(МакетСхемы)
	
	Сериализатор = Новый СериализаторXDTO(ФабрикаXDTO);
	ОбъектXDTOСхема = Сериализатор.ЗаписатьXDTO(МакетСхемы);
	
	Возврат ОбъектXDTOСхема.ПолучитьСписок("item");
	
КонецФункции

Процедура УстановитьСвойстваБлокаФункции(ЭлементСхемы, Ссылка, СвойстваФункции, Счетчики)
	
	Счетчики.МаксимальныйИдентификатор = Счетчики.МаксимальныйИдентификатор + 1;
	Счетчики.Порядок = Счетчики.Порядок + 1;
	
	ЭлементСхемы.ItemID = Счетчики.МаксимальныйИдентификатор;
	ЭлементСхемы.ItemTabOrder = Счетчики.Порядок;
	
	Счетчики.КоличествоФункций = Счетчики.КоличествоФункций + 1;
	ЭлементСхемы.ItemCode = "Функция" + Счетчики.КоличествоФункций;
	
	УстановитьЗаголовокЭлементаСхемы(ЭлементСхемы.ItemTitle, СвойстваФункции.Наименование);
	
	Если ЗначениеЗаполнено(Ссылка) Тогда
		ЭлементСхемы.TextFont.Underline = Истина;
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьЗаголовокЭлементаСхемы(ОбъектXDTOЭлемент, Знач ЗаголовокЭлемента)
	
	СписокЭлементов = ОбъектXDTOЭлемент.ПолучитьСписок("item");
	
	Попытка
		Элемент = СписокЭлементов[0];
		Элемент.Content = Строка(ЗаголовокЭлемента);
	Исключение
	КонецПопытки;
	
КонецПроцедуры

Процедура УстановитьРазмерЗаголовкаСхемы(ЭлементСхемы, ЗаголовокСхемы)
	
	ЭлементСхемы.RectRight = Мин(СтрДлина(ЗаголовокСхемы)*10 + 10, 1000);
	
КонецПроцедуры

# Область СлужебныеПроцедурыИФункцииФорматированияСхем

Функция НастройкиФорматированияСхем()
	
	Структура = Новый Структура;
	
	Структура.Вставить("МаксимумБлоковПоВертикали",7);
	Структура.Вставить("МаксимумБлоковПоГоризонтали",7);
	Структура.Вставить("ОтступПоВертикали",15);
	Структура.Вставить("ОтступПоГоризонтали",15);
	Структура.Вставить("ОтступМеждуФункциямиПоВертикали",30);
	Структура.Вставить("ОтступМеждуФункциямиПоГоризонтали",30);
	Структура.Вставить("ВысотаСвязи",60);
	Структура.Вставить("ШиринаСвязи",90);
	Структура.Вставить("ВысотаФункции",60);
	Структура.Вставить("ШиринаФункции",120);
	Структура.Вставить("ОтступОтГраницСхемы",30);
	Структура.Вставить("ОтступОтГраницФункции",30);
	Структура.Вставить("ВысотаЗаголовка",30);
	Структура.Вставить("РазмерСетки",15);
	Структура.Вставить("МаксимумСвязейКонечнойФункции",5);
	Структура.Вставить("ОтображатьБлокКонечнойФункции",Ложь);
	Структура.Вставить("ШиринаКонечнойФункцииБезОтображенияБлока",240);
	Структура.Вставить("ВысотаКонечнойФункцииБезОтображенияБлока",180);
	
	Возврат Структура;
	
КонецФункции

Процедура УстановитьКоординатыГраницы(Граница, X1, Y1, X2, Y2)
	
	Если Граница = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	СписокТочек = Граница.Point;
	
	СписокТочек[0].X = X1;
	СписокТочек[0].Y = Y1;
	
	СписокТочек[1].X = X2;
	СписокТочек[1].Y = Y2;
	
КонецПроцедуры

# КонецОбласти

# КонецОбласти

Процедура ИнициализироватьЭлементыСхемыКонечнойФункции(ЭлементыСхемы, Границы, ЗаголовокСхемы, БлокФункции, MaкcИД, Порядок, Счетчики)
	
	Для Каждого ЭлементСхемы из ЭлементыСхемы Цикл
		
		Если ЭлементСхемы.ItemID > MaкcИД Тогда
			MaкcИД = ЭлементСхемы.ItemID;
		КонецЕсли;
		
		Если ЭлементСхемы.ItemTabOrder > Порядок Тогда
			Порядок = ЭлементСхемы.ItemTabOrder;
		КонецЕсли;
		
		ИмяЭлемента = ЭлементСхемы.ItemCode;
		
		Если ИмяЭлемента = "ЗаголовокСхемы" Тогда
			
			ЗаголовокСхемы = ЭлементСхемы;
			
		ИначеЕсли ИмяЭлемента = "БлокФункции" Тогда
			
			БлокФункции = ЭлементСхемы;
			
		ИначеЕсли ИмяЭлемента = "ЛеваяГраницаФункции" Тогда
			Границы.Вставить("Левая", ЭлементСхемы);
		ИначеЕсли ИмяЭлемента = "ПраваяГраницаФункции" Тогда
			Границы.Вставить("Правая", ЭлементСхемы);
		ИначеЕсли ИмяЭлемента = "НижняяГраницаФункции" Тогда
			Границы.Вставить("Нижняя", ЭлементСхемы);
		ИначеЕсли ИмяЭлемента = "ВерхняяГраницаФункции" Тогда
		    Границы.Вставить("Верхняя", ЭлементСхемы);
		КонецЕсли;
		
	КонецЦикла;
	
	Счетчики.Вставить("МаксимальныйИдентификатор", MaкcИД);
	Счетчики.Вставить("Порядок", Порядок);
	
КонецПроцедуры

Процедура ИнициализироватьЭлементыСхемыНеконечнойФункции(ЭлементыСхемы, Границы, ЗаголовокСхемы, MaкcИД, Порядок, Счетчики)
	
	Для Каждого ЭлементСхемы из ЭлементыСхемы Цикл
		
		Если ЭлементСхемы.ItemID > MaкcИД Тогда
			MaкcИД = ЭлементСхемы.ItemID;
		КонецЕсли;
		
		Если ЭлементСхемы.ItemTabOrder > Порядок Тогда
			Порядок = ЭлементСхемы.ItemTabOrder;
		КонецЕсли;
		
		ИмяЭлемента = ЭлементСхемы.ItemCode;
		
		Если ИмяЭлемента = "ЗаголовокСхемы" Тогда
			
			ЗаголовокСхемы = ЭлементСхемы;
			ЭлементСхемы.zOrder =1;
			
		ИначеЕсли ИмяЭлемента = "ЛеваяГраницаФункции" Тогда
			Границы.Вставить("Левая", ЭлементСхемы);
			ЭлементСхемы.zOrder =1;
		ИначеЕсли ИмяЭлемента = "ПраваяГраницаФункции" Тогда
			Границы.Вставить("Правая", ЭлементСхемы);
			ЭлементСхемы.zOrder =1;
		ИначеЕсли ИмяЭлемента = "НижняяГраницаФункции" Тогда
			Границы.Вставить("Нижняя", ЭлементСхемы);
			ЭлементСхемы.zOrder =1;
		ИначеЕсли ИмяЭлемента = "ВерхняяГраницаФункции" Тогда
		    Границы.Вставить("Верхняя", ЭлементСхемы);
			ЭлементСхемы.zOrder =1;
		КонецЕсли;
		
	КонецЦикла;
	
	Счетчики.Вставить("МаксимальныйИдентификатор", MaкcИД);
	Счетчики.Вставить("Порядок", Порядок);
	
КонецПроцедуры

Процедура УстановитьЗаголовокСхемы(ЗаголовокСхемы, РеквизитыФункции)
	
	Если ЗаголовокСхемы <> Неопределено Тогда
		ТекстЗаголовка = РеквизитыФункции.ПолныйКод + " " + РеквизитыФункции.Наименование;
		УстановитьЗаголовокЭлементаСхемы(ЗаголовокСхемы.ItemTitle, ТекстЗаголовка);
		УстановитьРазмерЗаголовкаСхемы(ЗаголовокСхемы, ТекстЗаголовка);
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьЗаголовокБлока(БлокФункции, РеквизитыФункции, Настройки)
	
	Если БлокФункции <> Неопределено Тогда
		
		Если Настройки.ОтображатьБлокКонечнойФункции Тогда
			ЗаголовокБлока = РеквизитыФункции.Наименование;
		Иначе
			ЗаголовокБлока = ?(ЗначениеЗаполнено(РеквизитыФункции.Описание),
			                   РеквизитыФункции.Описание, РеквизитыФункции.Наименование);
		КонецЕсли;
		УстановитьЗаголовокЭлементаСхемы(БлокФункции.ItemTitle, ЗаголовокБлока);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьСвязиКонечнойФункции(ЭлементыСхемы, РеквизитыФункции, Связи, КоординатыГраницФункции, Настройки, Счетчики, ГиперссылкиСвязей)
	
	МакетВхода            = Справочники.ФункцииСистемы.ПолучитьМакет("Вход");
	МакетУправления       = Справочники.ФункцииСистемы.ПолучитьМакет("Управление");
	МакетИсполнителя      = Справочники.ФункцииСистемы.ПолучитьМакет("Исполнитель");
	МакетПотребителя      = Справочники.ФункцииСистемы.ПолучитьМакет("ПотребительКонечнойФункции");
	МакетВыхода           = Справочники.ФункцииСистемы.ПолучитьМакет("Выход");
	МакетЛинииВхода       = Справочники.ФункцииСистемы.ПолучитьМакет("ЛинияВход");
	МакетЛинииУправления  = Справочники.ФункцииСистемы.ПолучитьМакет("ЛинияУправление");
	
	КоординатыБлоковВходящихДанных =
	    РасчетныеКоординатыБлоковВходящихДанных(Связи, КоординатыГраницФункции, Настройки);
		
	КоординатыБлоковУправления =
	    РасчетныеКоординатыБлоковУправления(Связи, КоординатыГраницФункции, Настройки);
		
	КоординатыБлокаВыхода = РасчетныеКоординатыБлокаВыхода(КоординатыГраницФункции, Настройки);
	
	КоординатыБлоковПотребителей = РасчетныеКоординатыБлоковПотребителей(Связи, КоординатыГраницФункции,
	                                                                     КоординатыБлокаВыхода, Настройки);
	
	КоординатыБлоковИсполнителей =
	    РасчетныеКоординатыБлоковИсполнителей(Связи.Исполнители, КоординатыГраницФункции, Настройки);
	
	
	ДанныеВхода = Новый Структура;
	ДанныеВхода.Вставить("ВидСвязи", "Вход");
	ДанныеВхода.Вставить("КоординатыБлоков", КоординатыБлоковВходящихДанных);
	ДанныеВхода.Вставить("Макет", МакетВхода);
	ДанныеВхода.Вставить("МакетЛинииСвязи", МакетЛинииВхода);
	ДанныеВхода.Вставить("Количество", Связи.ВходящиеДанные.Количество());
	ДанныеВхода.Вставить("Связи", Связи.ВходящиеДанные);
	ДанныеВхода.Вставить("АгрегатыИСвязи", Связи.АгрегатыИСвязи.Вход);
	
	ДанныеУправления = Новый Структура;
	ДанныеУправления.Вставить("ВидСвязи", "Управление");
	ДанныеУправления.Вставить("КоординатыБлоков", КоординатыБлоковУправления);
	ДанныеУправления.Вставить("Макет", МакетУправления);
	ДанныеУправления.Вставить("МакетЛинииСвязи", МакетЛинииУправления);
	ДанныеУправления.Вставить("Количество", Связи.ДанныеУправления.Количество());
	ДанныеУправления.Вставить("Связи", Связи.ДанныеУправления);
	ДанныеУправления.Вставить("АгрегатыИСвязи", Связи.АгрегатыИСвязи.Управление);
	
	ДанныеВыхода = Новый Структура;
	ДанныеВыхода.Вставить("ВидСвязи", "Выход");
	ДанныеВыхода.Вставить("КоординатыБлоков", КоординатыБлоковПотребителей);
	ДанныеВыхода.Вставить("Макет", МакетПотребителя);
	ДанныеВыхода.Вставить("МакетЛинииСвязи", МакетЛинииВхода);
	ДанныеВыхода.Вставить("Количество", Связи.Потребители.Количество());
	ДанныеВыхода.Вставить("Связи", Связи.Потребители);
	ДанныеВыхода.Вставить("АгрегатыИСвязи", Связи.АгрегатыИСвязи.Выход);
	
	ДанныеИсполнителей = Новый Структура;
	ДанныеИсполнителей.Вставить("ВидСвязи", "Исполнитель");
	ДанныеИсполнителей.Вставить("КоординатыБлоков", КоординатыБлоковИсполнителей);
	ДанныеИсполнителей.Вставить("Макет", МакетИсполнителя);
	ДанныеИсполнителей.Вставить("Количество", Связи.Исполнители.Количество());
	ДанныеИсполнителей.Вставить("Связи", Связи.Исполнители);
	
	
	ИнформацияоБлокеВыхода = ДобавитьБлокВыхода(ЭлементыСхемы, КоординатыГраницФункции, КоординатыБлокаВыхода, 
	                                            РеквизитыФункции, МакетВыхода, Счетчики);
	
	ДобавитьБлокиДанных(ЭлементыСхемы, КоординатыГраницФункции, ДанныеВхода, ИнформацияоБлокеВыхода,
	                    Счетчики, ГиперссылкиСвязей, Настройки);
								
	ДобавитьБлокиДанных(ЭлементыСхемы, КоординатыГраницФункции, ДанныеУправления, ИнформацияоБлокеВыхода,
	                    Счетчики, ГиперссылкиСвязей, Настройки);
						
	ДобавитьБлокиДанных(ЭлементыСхемы, КоординатыГраницФункции, ДанныеВыхода, ИнформацияоБлокеВыхода,
	                    Счетчики, ГиперссылкиСвязей, Настройки);
						
	ДобавитьБлокиИсполнителей(ЭлементыСхемы, КоординатыГраницФункции, ДанныеИсполнителей, ИнформацияоБлокеВыхода,
	                    Счетчики, ГиперссылкиСвязей, Настройки);
	
КонецПроцедуры

Функция ДобавитьБлокВыхода(ЭлементыСхемы, КоординатыГраницФункции, КоординатыБлокаВыхода, РеквизитыФункции, Макет, Счетчики)
	
	ИнформацияОБлоке = Новый Структура;
	
	ДобавляемыеЭлементы = СписокЭлементовМакета(Макет);
	ЗаголовокБлока = РеквизитыФункции.Результат;
	
	Если НЕ ЗначениеЗаполнено(ЗаголовокБлока) Тогда
		ЗаголовокБлока = НСтр("ru='<Описание результата отсутствует>'");
	КонецЕсли;
	
	ИдентификаторДекорации = Неопределено;
	
	БлокВыхода = Неопределено;
	ДобавленнаяЛиния = Неопределено;
	
	Для Каждого ЭлементСхемы из ДобавляемыеЭлементы Цикл
		
		ДобавленныйЭлемент = ЭлементыСхемы.Добавить(ЭлементСхемы);
		
		УстановитьСвойстваСвязиФункции(ЭлементСхемы, ЗаголовокБлока, "Выход", Счетчики, Ложь);
		
		Если ДобавленныйЭлемент.ItemType = 0 Тогда //Декорация
			ИдентификаторДекорации = ДобавленныйЭлемент.ItemID;
			БлокВыхода = ДобавленныйЭлемент;
		ИначеЕсли ДобавленныйЭлемент.ItemType = 1 Тогда //Декоративная линия
			ДобавленнаяЛиния = ДобавленныйЭлемент;
		КонецЕсли;
		
	КонецЦикла;
	
	Если ДобавленнаяЛиния <> Неопределено Тогда
		
		Если ЗначениеЗаполнено(РеквизитыФункции.Результат) Тогда
			ТекстПодсказки = РеквизитыФункции.Результат;
		Иначе
			ТекстПодсказки = "";
		КонецЕсли;
		
		Если ИдентификаторДекорации <> Неопределено Тогда
			ДобавленнаяЛиния.ConnectToItemID = ИдентификаторДекорации;
		КонецЕсли;
		
		УстановитьПодсказкуЛинии(ДобавленнаяЛиния, ТекстПодсказки);
			
	КонецЕсли;
	
	Если БлокВыхода <> Неопределено Тогда
		УстановитьКоординатыБлока(БлокВыхода, КоординатыБлокаВыхода);
		БлокВыхода.Shape = ФигурыГрафическойСхемы.Нет;
	КонецЕсли;
	
	Если ДобавленнаяЛиния <> Неопределено Тогда
		УстановитьКоординатыЛинии(ДобавленнаяЛиния, КоординатыБлокаВыхода, КоординатыГраницФункции, "Выход")
	КонецЕсли;
	
	ИнформацияОБлоке.Вставить("Блок", БлокВыхода);
	ИнформацияОБлоке.Вставить("Координаты", КоординатыБлокаВыхода);
	
	Возврат ИнформацияОБлоке;
	
КонецФункции

Процедура ДобавитьБлокиДанных(ЭлементыСхемы, КоординатыГраниц, ДанныеСвязей, ИнформацияоБлокеВыхода, Счетчики, ГиперссылкиСвязей, Настройки)
	
	Макет            = ДанныеСвязей.Макет;
	МакетЛинииСвязи  = ДанныеСвязей.МакетЛинииСвязи;
	ВидСвязи         = ДанныеСвязей.ВидСвязи;
	КоличествоСвязей = ДанныеСвязей.Количество;
	Связи            = ДанныеСвязей.Связи;
	
	КоординатыБлоковСвязей = ДанныеСвязей.КоординатыБлоков.Связи;
	КоординатыБлоковАгрегатов = ДанныеСвязей.КоординатыБлоков.Агрегаты;
	
	КоординатыБлокаВыхода = ИнформацияОБлокеВыхода.Координаты;
	
	АгрегатыИСвязи = ДанныеСвязей.АгрегатыИСвязи;
	
	КоличествоАгрегатов = АгрегатыИСвязи.Количество();
	КоличествоСвязей = КоличествоСвязейАгрегатов(АгрегатыИСвязи);
	
	КоличествоБлоковСвязей = КоординатыБлоковСвязей.Количество();
	КоличествоБлоковАгрегатов = КоординатыБлоковАгрегатов.Количество();
	
	СвернутыеАгрегатыИСвязи = СвернутыеАгрегатыИСвязи(АгрегатыИСвязи, КоличествоБлоковАгрегатов,
	                                                  КоличествоБлоковСвязей, КоличествоАгрегатов, КоличествоСвязей);
												  
	СвернутыеАгрегаты = СвернутыеАгрегатыИСвязи.Агрегаты;
	СвернутыеСвязи = СвернутыеАгрегатыИСвязи.Связи;
	
	ИндексАгрегата = 0;
	ИндексСвязи = 0;
	
	Для Каждого ДанныеАгрегата из АгрегатыИСвязи Цикл
		
		ЗаголовокБлока = ДанныеАгрегата.Наименование;
		ДобавлятьГиперссылки = ЗначениеЗаполнено(ДанныеАгрегата.Ссылка);;
		ДанныеГиперссылок = ДанныеАгрегата.Ссылка;
		
		Если КоличествоАгрегатов > КоличествоБлоковАгрегатов
			И (ИндексАгрегата + 1)  = КоличествоБлоковАгрегатов Тогда
			// В последнем выводимом блоке, если агрегатов больше, чем
			// допустимо блоков, оставшиеся агрегаты помещаются в "+ еще...."
			СкрытоБлоков = Строка(КоличествоАгрегатов - КоличествоБлоковАгрегатов);
			ДополнениеЗаголовка = НСтр("ru='(+ еще %Блоков%)'");
			ДополнениеЗаголовка = СтрЗаменить(ДополнениеЗаголовка, "%Блоков%", СкрытоБлоков);
			
			ЗаголовокБлока = ЗаголовокБлока + " " + ДополнениеЗаголовка;
			
			Если СвернутыеАгрегаты.Количество()>0 Тогда
				ДобавлятьГиперссылки = Истина;
				ДанныеГиперссылок = СвернутыеАгрегаты;
			КонецЕсли;
			
		КонецЕсли;
		
		ДобавляемыеЭлементы = СписокЭлементовМакета(Макет);
		
		БлокАгрегата = ДобавитьБлокАгрегатаКонечнойФункции(ЭлементыСхемы, ДобавляемыеЭлементы, ВидСвязи,
		                                                   ЗаголовокБлока, Счетчики, ДобавлятьГиперссылки);
														   
		Если НЕ (КоличествоАгрегатов > КоличествоБлоковАгрегатов
			И (ИндексАгрегата + 1)  = КоличествоБлоковАгрегатов) Тогда
			// Если блок отображает только одну связь, без объединения,
			// проверяется необходимость отображения учетного механизма
			Если ДанныеАгрегата.ТипФункции = Перечисления.ТипыФункций.УчетныйМеханизм Тогда
				УстановитьОтображениеУчетногоМеханизма(БлокАгрегата);
			ИначеЕсли ДанныеАгрегата.ТипФункции = Перечисления.ТипыФункций.Отчет Тогда
				УстановитьОтображениеОтчета(БлокАгрегата);
			КонецЕсли;
			
		КонецЕсли;
		
		Если ДобавлятьГиперссылки Тогда
			ГиперссылкиСвязей.Вставить(БлокАгрегата.ItemCode, ДанныеГиперссылок);
		Иначе
			УстановитьОтображениеСвязиБезСсылки(БлокАгрегата, ВидСвязи);
		КонецЕсли;
		
		КоординатыАгрегата = КоординатыБлоковАгрегатов[ИндексАгрегата];
		УстановитьКоординатыБлока(БлокАгрегата, КоординатыАгрегата);
		
		Если ВидСвязи = "Вход" ИЛИ ВидСвязи = "Управление"  Тогда
			
			Для Каждого СвойстваСвязи из ДанныеАгрегата.Связи Цикл
				
				ДобавляемыеЭлементы = СписокЭлементовМакета(Макет);
				
				ЗаголовокБлока = ЗаголовокБлокаСвязи(СвойстваСвязи, ВидСвязи);
				
				ДанныеГиперссылок = СвойстваСвязи.Ссылка;
				ДобавлятьГиперссылки = ЗначениеЗаполнено(СвойстваСвязи.Ссылка);
				
				// Если количество блоков больше определенного в настройках,
				// выводится максимальное количество блоков, для последнего блока
				// при этом указывается, сколько еще блоков не отображено
				Если КоличествоСвязей > КоличествоБлоковСвязей
					И (ИндексСвязи + 1) = КоличествоБлоковСвязей Тогда
					
					СкрытоСвязей = Строка(КоличествоСвязей - КоличествоБлоковСвязей);
					СтрокаДополнения = НСтр("ru='(+ еще %Блоков%)'");
					СтрокаДополнения = СтрЗаменить(СтрокаДополнения, "%Блоков%", СкрытоСвязей);
					
					ЗаголовокБлока = ЗаголовокБлока + " " + СтрокаДополнения;
					
					Если СвернутыеСвязи.Количество()>0 Тогда
						ДобавлятьГиперссылки = Истина;
						ДанныеГиперссылок = СвернутыеСвязи;
					КонецЕсли;
					
				КонецЕсли;
				
				ИнформацияОСвязи = Новый Структура;
				ИнформацияОСвязи.Вставить("ВидСвязи", ВидСвязи);
				ИнформацияОСвязи.Вставить("СвойстваСвязи", СвойстваСвязи);
				
				ЭлементыСвязи = ДобавитьБлокСвязиКонечнойФункции(ЭлементыСхемы, ДобавляемыеЭлементы, ЗаголовокБлока, ИнформацияОСвязи,
				                                                 ИнформацияОБлокеВыхода, Счетчики, ДобавлятьГиперссылки);
				
				Если ЭлементыСвязи.Блок <> Неопределено Тогда
					
					КоординатыСвязи = КоординатыБлоковСвязей[ИндексСвязи];
					УстановитьКоординатыБлока(ЭлементыСвязи.Блок, КоординатыСвязи);
					
					Если ДобавлятьГиперссылки Тогда
						ГиперссылкиСвязей.Вставить(ЭлементыСвязи.Блок.ItemCode, ДанныеГиперссылок);
					КонецЕсли;
					
					ЭлементыСвязи.Блок.Shape = ФигурыГрафическойСхемы.Нет;
					
					Если ЭлементыСвязи.Линия <> Неопределено Тогда
						УстановитьКоординатыЛинии(ЭлементыСвязи.Линия, КоординатыБлоковСвязей[ИндексСвязи], КоординатыГраниц, ВидСвязи);
					КонецЕсли;
					
					// Добавление линии связи блока агрегата и блока связи
					ДобавляемыеЭлементы = СписокЭлементовМакета(МакетЛинииСвязи);
					ЛинияСвязи = ДобавитьЛиниюСвязиДляКонечнойФункции(ЭлементыСхемы, ДобавляемыеЭлементы, БлокАгрегата,
					                                                  ЭлементыСвязи.Блок, ВидСвязи, СвойстваСвязи, Счетчики);
					
					УстановитьКоординатыЛинииСвязиСАгрегатом(ЛинияСвязи, ВидСвязи, КоординатыАгрегата, КоординатыСвязи, Настройки);
				КонецЕсли;
				
				ИндексСвязи = ИндексСвязи + 1;
				
				Если (ИндексСвязи + 1) > КоличествоБлоковСвязей Тогда
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
		
		ИначеЕсли ВидСвязи = "Выход" Тогда
			// Добавление линии связи выходного блока (результата) конечной функции
			// и блоков агрегатов
			ДобавляемыеЭлементы = СписокЭлементовМакета(МакетЛинииСвязи);
			ЛинияСвязи = ДобавитьЛиниюСвязиДляКонечнойФункции(ЭлементыСхемы, ДобавляемыеЭлементы, ИнформацияОБлокеВыхода.Блок,
					                                          БлокАгрегата, ВидСвязи, ДанныеАгрегата, Счетчики);
												 
			УстановитьКоординатыЛинииСвязиСАгрегатом(ЛинияСвязи, ВидСвязи, КоординатыБлокаВыхода, КоординатыАгрегата, Настройки);
		КонецЕсли;
													 
		ИндексАгрегата = ИндексАгрегата + 1;
		
		Если (ИндексАгрегата + 1) > КоличествоБлоковАгрегатов Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция СвернутыеАгрегатыИСвязи(АгрегатыИСвязи, КоличествоБлоковАгрегатов, КоличествоБлоковСвязей, КоличествоАгрегатов, КоличествоСвязей)
	
	СвернутыеАгрегаты = Новый Массив;
	СвернутыеСвязи = Новый Массив;
	
	СчетчикАгрегатов = 1;
	СчетчикСвязей = 1;
	
	Для Каждого ДанныеАгрегата из АгрегатыИСвязи Цикл
		
		Если КоличествоАгрегатов > КоличествоБлоковАгрегатов Тогда
			Если СчетчикАгрегатов >= КоличествоБлоковАгрегатов Тогда
				Если ЗначениеЗаполнено(ДанныеАгрегата.Ссылка) Тогда
					СвернутыеАгрегаты.Добавить(ДанныеАгрегата.Ссылка);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Для Каждого СвойстваСвязи из ДанныеАгрегата.Связи Цикл
			Если КоличествоСвязей > КоличествоБлоковСвязей Тогда
				Если СчетчикСвязей >= КоличествоБлоковСвязей Тогда
					Если ЗначениеЗаполнено(СвойстваСвязи.Ссылка) Тогда
						СвернутыеСвязи.Добавить(свойстваСвязи.Ссылка);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			СчетчикСвязей = СчетчикСвязей + 1;
		КонецЦикла;
		
		СчетчикАгрегатов = СчетчикАгрегатов + 1;
		
	КонецЦикла;
	
	Результат = Новый Структура;
	Результат.Вставить("Агрегаты", СвернутыеАгрегаты);
	Результат.Вставить("Связи", СвернутыеСвязи);
	
	Возврат Результат;
	
КонецФункции

Функция КоличествоСвязейАгрегатов(АгрегатыИСвязи)
	
	КоличествоСвязей = 0;
	
	Для Каждого ДанныеАгрегата из АгрегатыИСвязи Цикл
		КоличествоСвязей = КоличествоСвязей + ДанныеАгрегата.Связи.Количество();
	КонецЦикла;
	
	Возврат КоличествоСвязей;
	
КонецФункции

Процедура ДобавитьБлокиИсполнителей(ЭлементыСхемы, КоординатыГраниц, ДанныеСвязей, ИнформацияоБлокеВыхода, Счетчики, ГиперссылкиСвязей, Настройки)
	
	Макет            = ДанныеСвязей.Макет;
	ВидСвязи         = ДанныеСвязей.ВидСвязи;
	КоличествоСвязей = ДанныеСвязей.Количество;
	Связи            = ДанныеСвязей.Связи;
	
	КоординатыБлоковСвязей = ДанныеСвязей.КоординатыБлоков;
	КоличествоБлоковСвязей = КоординатыБлоковСвязей.Количество();
	
	Для Каждого ЭлементКоллекции из КоординатыБлоковСвязей Цикл
		
		ДобавляемыеЭлементы = СписокЭлементовМакета(Макет);
		
		НомерСтрокиСвязи = ЭлементКоллекции.Ключ;
		
		КоординатыБлока = ЭлементКоллекции.Значение;
		НомерБлока = КоординатыБлока.НомерБлока;
		
		СвойстваСвязи = СвойстваСвязиПоНомеруСтроки(НомерСтрокиСвязи, Связи);
		
		ЗаголовокБлока = ЗаголовокБлокаСвязи(СвойстваСвязи, ВидСвязи);
		
		ДанныеГиперссылок = СвойстваСвязи.Ссылка;
		ДобавлятьГиперссылки = ЗначениеЗаполнено(СвойстваСвязи.Ссылка);
		
		// Если количество блоков больше определенного в настройках,
		// выводится максимальное количество блоков, для последнего блока
		// при этом указывается, сколько еще блоков не отображено
		Если КоличествоСвязей > КоличествоБлоковСвязей Тогда
			
			Если НомерБлока = КоличествоБлоковСвязей Тогда
				
				СтрокаДополнения = НСтр("ru='(+ еще %Блоков%)'");
				СтрокаДополнения = СтрЗаменить(СтрокаДополнения, "%Блоков%", Строка(КоличествоСвязей-КоличествоБлоковСвязей));
				ЗаголовокБлока = ЗаголовокБлока + " " + СтрокаДополнения;
				
				МассивСсылок = Новый Массив;
					
				Для Каждого СтруктураСвязи из Связи Цикл
					Связь = СтруктураСвязи.Ссылка;
					Если ЗначениеЗаполнено(Связь)
						И (КоординатыБлоковСвязей.Получить(Связь) = Неопределено ИЛИ СтруктураСвязи.НомерСтроки = НомерСтрокиСвязи) Тогда
						МассивСсылок.Добавить(Связь);
					КонецЕсли;
				КонецЦикла;
				
				ДанныеГиперссылок = МассивСсылок;
				ДобавлятьГиперссылки = (МассивСсылок.Количество()>0);
				
			КонецЕсли;
			
		КонецЕсли;
		
		ИнформацияОСвязи = Новый Структура;
	    ИнформацияОСвязи.Вставить("ВидСвязи", ВидСвязи);
	    ИнформацияОСвязи.Вставить("СвойстваСвязи", СвойстваСвязи);
	
		ЭлементыСвязи = ДобавитьБлокСвязиКонечнойФункции(ЭлементыСхемы, ДобавляемыеЭлементы, ЗаголовокБлока, ИнформацияОСвязи,
		                                                 ИнформацияОБлокеВыхода, Счетчики, ДобавлятьГиперссылки);
		
		Если ЭлементыСвязи.Блок <> Неопределено Тогда
			
			УстановитьКоординатыБлока(ЭлементыСвязи.Блок, КоординатыБлока);
			
			Если ДобавлятьГиперссылки Тогда
				ГиперссылкиСвязей.Вставить(ЭлементыСвязи.Блок.ItemCode, ДанныеГиперссылок);
			Иначе
				УстановитьОтображениеСвязиБезСсылки(ЭлементыСвязи.Блок, ВидСвязи);
			КонецЕсли;
			
		КонецЕсли;
		
		Если ЭлементыСвязи.Линия <> Неопределено Тогда
			УстановитьКоординатыЛинии(ЭлементыСвязи.Линия, КоординатыБлока, КоординатыГраниц, ВидСвязи)
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ЗаголовокБлокаСвязи(СвойстваСвязи, ВидСвязи)
	
	Если ВидСвязи = "Вход" ИЛИ ВидСвязи = "Управление" Тогда
		Если ЗначениеЗаполнено(СвойстваСвязи.Результат) Тогда
			Возврат СвойстваСвязи.Результат;
		Иначе
			Возврат СвойстваСвязи.Наименование;
		КонецЕсли;
	ИначеЕсли ВидСвязи = "Исполнитель" Тогда
		Если ЗначениеЗаполнено(СвойстваСвязи.Наименование) Тогда
			Возврат СвойстваСвязи.Наименование;
		Иначе
			Возврат СвойстваСвязи.Комментарий;
		КонецЕсли;	
	КонецЕсли;
		
КонецФункции

Функция СвойстваСвязиПоНомеруСтроки(НомерСтроки, Связи)
	
	Для Каждого СтруктураСвязи из Связи Цикл
		Если СтруктураСвязи.НомерСтроки = НомерСтроки Тогда
			Возврат СтруктураСвязи;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

Функция ДобавитьБлокАгрегатаКонечнойФункции(ЭлементыСхемы, ДобавляемыеЭлементы, ВидСвязи, ЗаголовокБлока, Счетчики, ДобавлятьГиперссылки=Ложь)
	
	БлокСвязи = Неопределено;
	
	Для Каждого ЭлементСхемы из ДобавляемыеЭлементы Цикл
		
		Если ЭлементСхемы.ItemType = 0 Тогда //Декорация
			БлокСвязи = ЭлементыСхемы.Добавить(ЭлементСхемы);
			УстановитьСвойстваСвязиФункции(ЭлементСхемы, ЗаголовокБлока, ВидСвязи, Счетчики, ДобавлятьГиперссылки);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат БлокСвязи;
	
КонецФункции

Функция ДобавитьЛиниюСвязиДляКонечнойФункции(ЭлементыСхемы, ДобавляемыеЭлементы, БлокИсточник, БлокПриемник, ВидСвязи, СвойстваСвязи, Счетчики)
	
	ДобавленнаяЛиния = Неопределено;
	
	Для Каждого ЭлементСхемы из ДобавляемыеЭлементы Цикл
		Если ЭлементСхемы.ItemType = 1 Тогда //Декоративная линия
			ДобавленнаяЛиния = ЭлементыСхемы.Добавить(ЭлементСхемы);
		КонецЕсли;		
	КонецЦикла;
	
	Если ДобавленнаяЛиния <> Неопределено Тогда
		
		Если ВидСвязи = "Выход" Тогда
			ТекстПодсказки = СвойстваСвязи.РезультатПотребляемойФункции;
		ИначеЕсли ВидСвязи = "Вход" ИЛИ  ВидСвязи = "Управление" Тогда
			ТекстПодсказки = СвойстваСвязи.Результат;
		Иначе
			ТекстПодсказки = "";
		КонецЕсли;
		
		ДобавленнаяЛиния.ConnectFromItemID = БлокИсточник.ItemID;
		ДобавленнаяЛиния.ConnectToItemID   = БлокПриемник.ItemID;
		
		//Установка привязки линии
		Если ВидСвязи = "Вход" Тогда
			ДобавленнаяЛиния.PortIndexFrom = 3;
			ДобавленнаяЛиния.PortIndexTo = 1;
		ИначеЕсли ВидСвязи = "Управление" Тогда
			ДобавленнаяЛиния.PortIndexFrom = 4;
			ДобавленнаяЛиния.PortIndexTo = 2;
		ИначеЕсли ВидСвязи = "Исполнитель" Тогда
			ДобавленнаяЛиния.PortIndexFrom = 2;
			ДобавленнаяЛиния.PortIndexTo = 4;
		ИначеЕсли ВидСвязи = "Выход" Тогда
			ДобавленнаяЛиния.PortIndexFrom = 3;
			ДобавленнаяЛиния.PortIndexTo = 1;
		КонецЕсли;
		
		УстановитьПодсказкуЛинии(ДобавленнаяЛиния, ТекстПодсказки);
			
	КонецЕсли;
	
	Возврат ДобавленнаяЛиния;
	
КонецФункции

Функция ДобавитьБлокСвязиКонечнойФункции(ЭлементыСхемы, ДобавляемыеЭлементы, ЗаголовокБлока, ИнформацияОСвязи, ИнформацияОБлокеВыхода, Счетчики, ДобавлятьГиперссылки =Ложь)
	
	ВидСвязи = ИнформацияОСвязи.ВидСвязи;
	СвойстваСвязи = ИнформацияОСвязи.СвойстваСвязи;
	
	ИдентификаторДекорации = Неопределено;
	ДобавленнаяЛиния = Неопределено;
	
	БлокВыхода = ИнформацияОБлокеВыхода.Блок;
	
	ЭлементыСвязи = Новый Структура;
	ЭлементыСвязи.Вставить("Блок", Неопределено);
	ЭлементыСвязи.Вставить("Линия", Неопределено);
	
	Для Каждого ЭлементСхемы из ДобавляемыеЭлементы Цикл
		
		ДобавленныйЭлемент = ЭлементыСхемы.Добавить(ЭлементСхемы);
		
		УстановитьСвойстваСвязиФункции(ЭлементСхемы, ЗаголовокБлока, ВидСвязи, Счетчики, ДобавлятьГиперссылки);
		
		Если ДобавленныйЭлемент.ItemType = 0 Тогда //Декорация
			ИдентификаторДекорации = ДобавленныйЭлемент.ItemID;
			ЭлементыСвязи.Вставить("Блок", ДобавленныйЭлемент);
		ИначеЕсли ДобавленныйЭлемент.ItemType = 1 Тогда //Декоративная линия
			ДобавленнаяЛиния = ДобавленныйЭлемент;
			ЭлементыСвязи.Вставить("Линия", ДобавленныйЭлемент);
		КонецЕсли;
		
	КонецЦикла;
	
	Если ДобавленнаяЛиния <> Неопределено Тогда
		
		Если ВидСвязи = "Выход" Тогда
			ТекстПодсказки = СвойстваСвязи.РезультатПотребляемойФункции;
		ИначеЕсли ВидСвязи = "Вход" ИЛИ  ВидСвязи = "Управление" Тогда
			ТекстПодсказки = СвойстваСвязи.Результат;
		Иначе
			ТекстПодсказки = "";
		КонецЕсли;
		
		Если ИдентификаторДекорации <> Неопределено Тогда
			
			Если ВидСвязи = "Выход" Тогда
				ДобавленнаяЛиния.ConnectToItemID = ИдентификаторДекорации;
			Иначе
				ДобавленнаяЛиния.ConnectFromItemID = ИдентификаторДекорации;
			КонецЕсли;
			
		КонецЕсли;
		
		// Линия связи с потребителем присоединяется к блоку выхода,
		// а не к границе функции.
		
		Если ВидСвязи = "Выход" Тогда
			ДобавленнаяЛиния.ConnectFromItemID = БлокВыхода.ItemID;
		КонецЕсли;
		
		//Установка привязки линии
		Если ВидСвязи = "Вход" Тогда
			ДобавленнаяЛиния.PortIndexTo = 1;
		ИначеЕсли ВидСвязи = "Управление" Тогда
			ДобавленнаяЛиния.PortIndexTo = 2;
		ИначеЕсли ВидСвязи = "Исполнитель" Тогда
			ДобавленнаяЛиния.PortIndexTo = 4;
		ИначеЕсли ВидСвязи = "Выход" Тогда
			ДобавленнаяЛиния.PortIndexFrom = 3;
		КонецЕсли;
		
		УстановитьПодсказкуЛинии(ДобавленнаяЛиния, ТекстПодсказки);
			
	КонецЕсли;
	
	Возврат ЭлементыСвязи;
	
КонецФункции

Функция ДобавитьБлокСвязиДочернейФункции(ЭлементыСхемы, ДобавляемыеЭлементы, ЗаголовокБлока, ИнформацияОСвязях, Счетчики, ЭлементБлокаФункции = Неопределено, ДобавлятьГиперссылки =Ложь)
	
	ВидСвязи = ИнформацияОСвязях.ВидСвязи;
	СвойстваСвязей = ИнформацияОСвязях.СвойстваСвязей;
	
	ИдентификаторДекорации = Неопределено;
	ДобавленнаяЛиния = Неопределено;
	
	ЭлементыСвязи = Новый Структура;
	ЭлементыСвязи.Вставить("Блок", Неопределено);
	ЭлементыСвязи.Вставить("Линия", Неопределено);
	
	Для Каждого ЭлементСхемы из ДобавляемыеЭлементы Цикл
		
		ДобавленныйЭлемент = ЭлементыСхемы.Добавить(ЭлементСхемы);
		
		УстановитьСвойстваСвязиФункции(ЭлементСхемы, ЗаголовокБлока, ВидСвязи, Счетчики, ДобавлятьГиперссылки);
		
		Если ДобавленныйЭлемент.ItemType = 0 Тогда //Декорация
			ИдентификаторДекорации = ДобавленныйЭлемент.ItemID;
			ДобавленныйЭлемент.zOrder =1;
			ЭлементыСвязи.Вставить("Блок", ДобавленныйЭлемент);
		ИначеЕсли ДобавленныйЭлемент.ItemType = 1 Тогда //Декоративная линия
			ДобавленнаяЛиния = ДобавленныйЭлемент;
			ЭлементыСвязи.Вставить("Линия", ДобавленныйЭлемент);
		КонецЕсли;
		
	КонецЦикла;
	
	Если ДобавленнаяЛиния <> Неопределено Тогда
		
		СвойстваСвязи = СвойстваСвязей[0];
		
		Если ВидСвязи = "Выход" Тогда
			ТекстПодсказки = СвойстваСвязи.РезультатПотребляемойФункции;
		ИначеЕсли ВидСвязи = "Вход" ИЛИ  ВидСвязи = "Управление" Тогда
			ТекстПодсказки = СвойстваСвязи.Результат;
		Иначе
			ТекстПодсказки = "";
		КонецЕсли;
		
		Если ИдентификаторДекорации <> Неопределено Тогда
			
			Если ВидСвязи = "Выход" Тогда
				ДобавленнаяЛиния.ConnectToItemID = ИдентификаторДекорации;
			Иначе
				ДобавленнаяЛиния.ConnectFromItemID = ИдентификаторДекорации;
			КонецЕсли;
			
		КонецЕсли;
		
		Если ЭлементБлокаФункции <> Неопределено Тогда
			Если ВидСвязи = "Выход" Тогда
				ДобавленнаяЛиния.ConnectFromItemID = ЭлементБлокаФункции.ItemID;
			Иначе
				ДобавленнаяЛиния.ConnectToItemID = ЭлементБлокаФункции.ItemID;
			КонецЕсли;
		КонецЕсли;
		
		//Установка привязки линии
		Если ВидСвязи = "Вход" Тогда
			ДобавленнаяЛиния.PortIndexTo = 1;
		ИначеЕсли ВидСвязи = "Управление" Тогда
			ДобавленнаяЛиния.PortIndexTo = 2;
		ИначеЕсли ВидСвязи = "Исполнитель" Тогда
			ДобавленнаяЛиния.PortIndexTo = 4;
		ИначеЕсли ВидСвязи = "Выход" Тогда
			ДобавленнаяЛиния.PortIndexFrom = 3;
		КонецЕсли;
		
		УстановитьПодсказкуЛинии(ДобавленнаяЛиния, ТекстПодсказки);
			
	КонецЕсли;
	
	Возврат ЭлементыСвязи;
	
КонецФункции

Процедура УстановитьКоординатыБлока(Блок, КоординатыБлока)
	
	Блок.RectLeft   = КоординатыБлока.Левая;
	Блок.RectRight  = КоординатыБлока.Правая;
	Блок.RectTop    = КоординатыБлока.Верхняя;
	Блок.RectBottom = КоординатыБлока.Нижняя;
	
КонецПроцедуры

Процедура УстановитьКоординатыЛинии(Линия, КоординатыБлока, КоординатыГраниц, ВидСвязи)
	
	СписокТочек = Линия.Point;
	КоличествоТочек = СписокТочек.Количество();
	
	Если КоличествоТочек<2 Тогда
		Возврат;
	КонецЕсли;
	
	// Удаление лишних точек
	Если КоличествоТочек>2 Тогда
		
		Сч = КоличествоТочек;
		Пока Сч>2 Цикл
			СписокТочек.Удалить(Сч-1);
			Сч = Сч - 1;
		КонецЦикла;
		
	КонецЕсли;
	
	Если ВидСвязи = "Исполнитель" Тогда
		ТочкаНачала = СписокТочек[СписокТочек.Количество()-1];
		ТочкаОкончания = СписокТочек[0];
	Иначе
		ТочкаНачала = СписокТочек[0];
		ТочкаОкончания = СписокТочек[СписокТочек.Количество()-1];
	КонецЕсли;
	
	X1=0;
	Y1=0;
	X2=0;
	Y2=0;
	
	Если ВидСВязи = "Вход" Тогда
		
		X1 = КоординатыБлока.Правая;
		Y1 = КоординатыБлока.ЦентрПоВертикали;
		X2 = КоординатыГраниц.Левая;
		Y2 = КоординатыБлока.ЦентрПоВертикали;
		
	ИначеЕсли ВидСвязи = "Выход" Тогда
		
		X1 = КоординатыГраниц.Правая;
		Y1 = КоординатыБлока.ЦентрПоВертикали;
		X2 = КоординатыБлока.Левая;
		Y2 = КоординатыБлока.ЦентрПоВертикали;
		
	ИначеЕсли ВидСвязи = "Управление" Тогда
		
	    X1 = КоординатыБлока.ЦентрПоГоризонтали;
		Y1 = КоординатыБлока.Нижняя;
		X2 = КоординатыБлока.ЦентрПоГоризонтали;
		Y2 = КоординатыГраниц.Верхняя;
		
	ИначеЕсли ВидСвязи = "Исполнитель" Тогда
		
		X1 = КоординатыБлока.ЦентрПоГоризонтали;
		Y1 = КоординатыГраниц.Нижняя;
		X2 = КоординатыБлока.ЦентрПоГоризонтали;
		Y2 = КоординатыБлока.Верхняя;
		
	КонецЕсли;
	
	ТочкаНачала.X = X1;
	ТочкаНачала.Y = Y1;
	
	ТочкаОкончания.X = X2;
	ТочкаОкончания.Y = Y2;
	
КонецПроцедуры
	
Процедура УстановитьСвойстваСвязиФункции(ЭлементСхемы, ЗаголовокБлока, ВидСвязи, Счетчики, ДобавлятьГиперссылки=Ложь)
	
	Счетчики.МаксимальныйИдентификатор = Счетчики.МаксимальныйИдентификатор + 1;
	Счетчики.Порядок = Счетчики.Порядок + 1;
	
	ЭлементСхемы.ItemID = Счетчики.МаксимальныйИдентификатор;
	ЭлементСхемы.ItemTabOrder = Счетчики.Порядок;
	
	ТипЭлемента = ЭлементСхемы.ItemType;
	
	Если ТипЭлемента = 0 Тогда // Лекорация
		
		Счетчики.КоличествоСвязей = Счетчики.КоличествоСвязей + 1;
		ЭлементСхемы.ItemCode = "Декорация" + Счетчики.КоличествоСвязей;
		
		УстановитьЗаголовокЭлементаСхемы(ЭлементСхемы.ItemTitle, ЗаголовокБлока);
		
		Если ДобавлятьГиперссылки Тогда
			ЭлементСхемы.TextFont.Underline = Истина;
		КонецЕсли;
		
	ИначеЕсли ТипЭлемента = 1 Тогда // декоративная линия
		
		Счетчики.КоличествоЛиний = Счетчики.КоличествоЛиний + 1;
		ЭлементСхемы.ItemCode = "ДекоративнаяЛиния" + Счетчики.КоличествоЛиний;
		
		//Установка привязки линии
		Если ВидСвязи = "Вход" Тогда
			ЭлементСхемы.PortIndexFrom = 3;
		ИначеЕсли ВидСвязи = "Управление" Тогда
			ЭлементСхемы.PortIndexFrom = 4;
		ИначеЕсли ВидСвязи = "Исполнитель" Тогда
			ЭлементСхемы.PortIndexFrom = 2;
		ИначеЕсли ВидСвязи = "Выход" Тогда
			ЭлементСхемы.PortIndexTo = 1;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

Функция РасчетныеКоординатыБлоковВходящихДанных(ИнформацияОСвязях, КоординатыГраницФункции, Настройки)
	
	ДанныеАгрегатов = ИнформацияоСвязях.АгрегатыИСвязи.Вход;
	ДанныеОКоличествеБлоков = ДанныеОКоличествеБлоковСвязиКонечнойФункции(ДанныеАгрегатов, Настройки, Истина);
	
	КоличествоБлоковАгрегатов = ДанныеОКоличествеБлоков.КоличествоАгрегатов;
	КоличествоБлоковСвязей = ДанныеОКоличествеБлоков.КоличествоСвязей;
	
	КоординатыБлоковАгрегатов = Новый Массив;
	КоординатыБлоковСвязей = Новый Массив;
	
	ВысотаБлоков = Настройки.ВысотаФункции*КоличествоБлоковСвязей; 
	
	Если КоличествоБлоковСвязей>0 Тогда
		КоличествоПромежутков = КоличествоБлоковСвязей-1;
	Иначе
		КоличествоПромежутков = 0;
	КонецЕсли;
	
	ОбщаяВысота = ВысотаБлоков + КоличествоПромежутков*Настройки.ОтступМеждуФункциямиПоВертикали;
	
	Лево  = КоординатыГраницФункции.Левая - Настройки.ОтступОтГраницФункции - Настройки.ШиринаФункции;
	Право = Лево + Настройки.ШиринаФункции;
	
	ЦентрПоГоризонтали = (Право - Лево)/2 + Лево;
	ЦентрПоГоризонтали = Цел(Цел(ЦентрПоГоризонтали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	ЛевоАгрегат  = Лево - Настройки.ОтступМеждуФункциямиПоГоризонтали - Настройки.ШиринаФункции;
	ПравоАгрегат = ЛевоАгрегат + Настройки.ШиринаФункции;
	
	ЦентрПоГоризонталиАгрегат = (ПравоАгрегат - ЛевоАгрегат)/2 + ЛевоАгрегат;
	ЦентрПоГоризонталиАгрегат = Цел(Цел(ЦентрПоГоризонталиАгрегат/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	НачальнаяВысота = КоординатыГраницФункции.ЦентрПоВертикали - ОбщаяВысота/2;
	НачальнаяВысота = Цел(Цел(НачальнаяВысота/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	ТекущаяВысота = НачальнаяВысота;
	
	НомерБлока  = 0;
	НомерБлокаАгрегата = 0;
	
	Для Каждого ДанныеАгрегата из ДанныеАгрегатов Цикл
		
		НомерБлокаАгрегата = НомерБлокаАгрегата + 1;
		
		КоличествоСвязей = 0;
		НачальнаяВысотаВРамкахАгрегата = ТекущаяВысота;
		
		Для Каждого Связь из ДанныеАгрегата.Связи Цикл
			
			НомерБлока = НомерБлока + 1;
			
			Верх = ТекущаяВысота;
			Низ  = ТекущаяВысота + Настройки.ВысотаФункции;
			
			ЦентрПоВертикали = (Низ - Верх)/2 + Верх;
			ЦентрПоВертикали = Цел(Цел(ЦентрПоВертикали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
			
			КоординатыБлока = Новый Структура;
			
			КоординатыБлока.Вставить("Левая", Лево);
			КоординатыБлока.Вставить("Правая", Право);
			КоординатыБлока.Вставить("Верхняя",Верх);
			КоординатыБлока.Вставить("Нижняя", Низ);
			КоординатыБлока.Вставить("ЦентрПоГоризонтали", ЦентрПоГоризонтали);
			КоординатыБлока.Вставить("ЦентрПоВертикали", ЦентрПоВертикали);
			КоординатыБлока.Вставить("НомерБлока", НомерБлока);
			
			КоординатыБлоковСвязей.Добавить(КоординатыБлока);
			
			ТекущаяВысота = Низ + Настройки.ОтступМеждуФункциямиПоВертикали;
			
			КоличествоСвязей = КоличествоСвязей + 1;
			
			Если НомерБлока >= КоличествоБлоковСвязей Тогда
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		КонечнаяВысотаВРамкахАгрегата = Низ;
		
		// Рассчитываются координаты блока агрегата
		
		ЦентрПоВертикалиАгрегат = (КонечнаяВысотаВРамкахАгрегата - НачальнаяВысотаВРамкахАгрегата)/2
		                          + НачальнаяВысотаВРамкахАгрегата;
		ЦентрПоВертикалиАгрегат = Цел(Цел(ЦентрПоВертикалиАгрегат/Настройки.РазмерСетки)*Настройки.РазмерСетки);
		
		ВерхАгрегат = ЦентрПоВертикалиАгрегат - Настройки.ВысотаФункции/2;
		ВерхАгрегат = Цел(Цел(ВерхАгрегат/Настройки.РазмерСетки)*Настройки.РазмерСетки);
		
		НизАгрегат = ВерхАгрегат + Настройки.ВысотаФункции;
		
		КоординатыБлокаАгрегата = Новый Структура;
			
		КоординатыБлокаАгрегата.Вставить("Левая", ЛевоАгрегат);
		КоординатыБлокаАгрегата.Вставить("Правая", ПравоАгрегат);
		КоординатыБлокаАгрегата.Вставить("Верхняя",ВерхАгрегат);
		КоординатыБлокаАгрегата.Вставить("Нижняя", НизАгрегат);
		КоординатыБлокаАгрегата.Вставить("ЦентрПоГоризонтали", ЦентрПоГоризонталиАгрегат);
		КоординатыБлокаАгрегата.Вставить("ЦентрПоВертикали", ЦентрПоВертикалиАгрегат);
		
		КоординатыБлоковАгрегатов.Добавить(КоординатыБлокаАгрегата);
			
		Если НомерБлока >= КоличествоБлоковСвязей Тогда
			Прервать;
		КонецЕсли;
			
	КонецЦикла;
	
	КоординатыБлоков = Новый Структура;
	КоординатыБлоков.Вставить("Агрегаты", КоординатыБлоковАгрегатов);
	КоординатыБлоков.Вставить("Связи", КоординатыБлоковСвязей);
	
	Возврат КоординатыБлоков;
	
КонецФункции

Функция РасчетныеКоординатыБлоковУправления(ИнформацияОСвязях, КоординатыГраницФункции, Настройки)
	
	ДанныеАгрегатов = ИнформацияоСвязях.АгрегатыИСвязи.Управление;
	ДанныеОКоличествеБлоков = ДанныеОКоличествеБлоковСвязиКонечнойФункции(ДанныеАгрегатов, Настройки, Истина);
	
	КоличествоБлоковАгрегатов = ДанныеОКоличествеБлоков.КоличествоАгрегатов;
	КоличествоБлоковСвязей = ДанныеОКоличествеБлоков.КоличествоСвязей;
	
	КоординатыБлоковАгрегатов = Новый Массив;
	КоординатыБлоковСвязей = Новый Массив;
	
	ШиринаБлоков = Настройки.ШиринаФункции*КоличествоБлоковСвязей; 
	
	Если КоличествоБлоковСвязей>0 Тогда
		КоличествоПромежутков = КоличествоБлоковСвязей-1;
	Иначе
		КоличествоПромежутков = 0;
	КонецЕсли;
	
	ОбщаяШирина = ШиринаБлоков + КоличествоПромежутков*Настройки.ОтступМеждуФункциямиПоГоризонтали;
	
	Верх  = КоординатыГраницФункции.Верхняя - Настройки.ОтступОтГраницФункции - Настройки.ВысотаФункции;
	Низ = Верх + Настройки.ВысотаФункции;
	
	ЦентрПоВертикали = (Низ - Верх)/2 + Верх;
	ЦентрПоВертикали = Цел(Цел(ЦентрПоВертикали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	ВерхАгрегат  = Верх - Настройки.ОтступМеждуФункциямиПоВертикали - Настройки.ВысотаФункции;
	НизАгрегат = ВерхАгрегат + Настройки.ВысотаФункции;
	
	ЦентрПоВертикалиАгрегат = (НизАгрегат - ВерхАгрегат)/2 + ВерхАгрегат;
	ЦентрПоВертикалиАгрегат = Цел(Цел(ЦентрПоВертикалиАгрегат/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	НачальнаяШирина = КоординатыГраницФункции.ЦентрПоГоризонтали - ОбщаяШирина/2;
	НачальнаяШирина = Цел(Цел(НачальнаяШирина/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	ТекущаяШирина = НачальнаяШирина;
	
	НомерБлока  = 0;
	НомерБлокаАгрегата = 0;
	
	Для Каждого ДанныеАгрегата из ДанныеАгрегатов Цикл
		
		НомерБлокаАгрегата = НомерБлокаАгрегата + 1;
		
		КоличествоСвязей = 0;
		НачальнаяШиринаВРамкахАгрегата = ТекущаяШирина;
		
		Для Каждого Связь из ДанныеАгрегата.Связи Цикл
			
			НомерБлока = НомерБлока + 1;
			
			Лево = ТекущаяШирина;
			Право  = ТекущаяШирина + Настройки.ШиринаФункции;
			
			ЦентрПоГоризонтали = (Право - Лево)/2 + Лево;
			ЦентрПоГоризонтали = Цел(Цел(ЦентрПоГоризонтали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
			
			КоординатыБлока = Новый Структура;
			
			КоординатыБлока.Вставить("Левая", Лево);
			КоординатыБлока.Вставить("Правая", Право);
			КоординатыБлока.Вставить("Верхняя",Верх);
			КоординатыБлока.Вставить("Нижняя", Низ);
			КоординатыБлока.Вставить("ЦентрПоГоризонтали", ЦентрПоГоризонтали);
			КоординатыБлока.Вставить("ЦентрПоВертикали", ЦентрПоВертикали);
			КоординатыБлока.Вставить("НомерБлока", НомерБлока);
			
			КоординатыБлоковСвязей.Добавить(КоординатыБлока);
			
			ТекущаяШирина = Право + Настройки.ОтступМеждуФункциямиПоГоризонтали;
			
			КоличествоСвязей = КоличествоСвязей + 1;
			
			Если НомерБлока >= КоличествоБлоковСвязей Тогда
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		КонечнаяШиринаВРамкахАгрегата = Право;
		
		// Рассчитываются координаты блока агрегата
		
		ЦентрПоГоризонталиАгрегат = (КонечнаяШиринаВРамкахАгрегата - НачальнаяШиринаВРамкахАгрегата)/2
		                          + НачальнаяШиринаВРамкахАгрегата;
		ЦентрПоГоризонталиАгрегат = Цел(Цел(ЦентрПоГоризонталиАгрегат/Настройки.РазмерСетки)*Настройки.РазмерСетки);
		
		ЛевоАгрегат = ЦентрПоГоризонталиАгрегат - Настройки.ШиринаФункции/2;
		ЛевоАгрегат = Цел(Цел(ЛевоАгрегат/Настройки.РазмерСетки)*Настройки.РазмерСетки);
		
		ПравоАгрегат = ЛевоАгрегат + Настройки.ШиринаФункции;
		
		КоординатыБлокаАгрегата = Новый Структура;
			
		КоординатыБлокаАгрегата.Вставить("Левая", ЛевоАгрегат);
		КоординатыБлокаАгрегата.Вставить("Правая", ПравоАгрегат);
		КоординатыБлокаАгрегата.Вставить("Верхняя",ВерхАгрегат);
		КоординатыБлокаАгрегата.Вставить("Нижняя", НизАгрегат);
		КоординатыБлокаАгрегата.Вставить("ЦентрПоГоризонтали", ЦентрПоГоризонталиАгрегат);
		КоординатыБлокаАгрегата.Вставить("ЦентрПоВертикали", ЦентрПоВертикалиАгрегат);
		
		КоординатыБлоковАгрегатов.Добавить(КоординатыБлокаАгрегата);
			
		Если НомерБлока >= КоличествоБлоковСвязей Тогда
			Прервать;
		КонецЕсли;
			
	КонецЦикла;
	
	КоординатыБлоков = Новый Структура;
	КоординатыБлоков.Вставить("Агрегаты", КоординатыБлоковАгрегатов);
	КоординатыБлоков.Вставить("Связи", КоординатыБлоковСвязей);
	
	Возврат КоординатыБлоков;
	
КонецФункции

Функция РасчетныеКоординатыБлоковИсполнителей(Исполнители, КоординатыГраницФункции, Настройки)
	
	СоответствиеКоординат = Новый Соответствие;
	
	МаксимумСвязей = Настройки.МаксимумСвязейКонечнойФункции;
	
	КоличествоБлоков = Мин(Исполнители.Количество(), МаксимумСвязей);
	
	ШиринаБлоков = Настройки.ШиринаФункции*КоличествоБлоков; 
	
	Если КоличествоБлоков>0 Тогда
		КоличествоПромежутков = КоличествоБлоков-1;
	Иначе
		КоличествоПромежутков = 0;
	КонецЕсли;
	
	ОбщаяШирина = ШиринаБлоков + КоличествоПромежутков*Настройки.ОтступМеждуФункциямиПоГоризонтали;
	
	Верх  = КоординатыГраницФункции.Нижняя + Настройки.ОтступОтГраницФункции;
	Низ = Верх + Настройки.ВысотаФункции;
	
	ЦентрПоВертикали = (Низ - Верх)/2 + Верх;
	ЦентрПоВертикали = Цел(Цел(ЦентрПоВертикали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	НачальнаяШирина = КоординатыГраницФункции.ЦентрПоГоризонтали - ОбщаяШирина/2;
	НачальнаяШирина = Цел(Цел(НачальнаяШирина/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	ТекущаяШирина = НачальнаяШирина;
	
	НомерБлока = 0;
	
	Для Каждого СтруктураСвязи из Исполнители Цикл
		
		НомерБлока = НомерБлока + 1;
		
		Лево = ТекущаяШирина;
		Право = ТекущаяШирина + Настройки.ШиринаФункции;
		
		ЦентрПоГоризонтали = (Право - Лево)/2 + Лево;
		ЦентрПоГоризонтали = Цел(Цел(ЦентрПоГоризонтали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
		
		КоординатыБлока = Новый Структура;
		
		КоординатыБлока.Вставить("Левая", Лево);
		КоординатыБлока.Вставить("Правая", Право);
		КоординатыБлока.Вставить("Верхняя",Верх);
		КоординатыБлока.Вставить("Нижняя", Низ);
		КоординатыБлока.Вставить("ЦентрПоГоризонтали", ЦентрПоГоризонтали);
		КоординатыБлока.Вставить("ЦентрПоВертикали", ЦентрПоВертикали);
		КоординатыБлока.Вставить("НомерБлока", НомерБлока);
		
		СоответствиеКоординат.Вставить(СтруктураСвязи.НомерСтроки, КоординатыБлока);
		
		ТекущаяШирина = Право + Настройки.ОтступМеждуФункциямиПоГоризонтали;
		
		Если НомерБлока >= КоличествоБлоков Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат СоответствиеКоординат;
	
КонецФункции

Функция РасчетныеКоординатыБлоковПотребителей(ИнформацияоСвязях, КоординатыГраницФункции, КоординатыБлокаВыхода, Настройки)
	
	КоординатыБлоковАгрегатов = Новый Массив;
	КоординатыБлоковСвязей = Новый Массив;
	
	ДанныеАгрегатов = ИнформацияоСвязях.АгрегатыИСвязи.Выход;
	ДанныеОКоличествеБлоков = ДанныеОКоличествеБлоковСвязиКонечнойФункции(ДанныеАгрегатов, Настройки, Ложь);
	
	КоличествоБлоковАгрегатов = ДанныеОКоличествеБлоков.КоличествоАгрегатов;
	
	ВысотаБлоков = Настройки.ВысотаФункции*КоличествоБлоковАгрегатов;
	
	Если КоличествоБлоковАгрегатов>0 Тогда
		КоличествоПромежутков = КоличествоБлоковАгрегатов-1;
	Иначе
		КоличествоПромежутков = 0;
	КонецЕсли;
	
	ОбщаяВысота = ВысотаБлоков + КоличествоПромежутков*Настройки.ОтступМеждуФункциямиПоВертикали;
	
	Лево  = КоординатыБлокаВыхода.Правая + Настройки.ОтступМеждуФункциямиПоГоризонтали;
	Право = Лево + Настройки.ШиринаФункции;
	
	ЦентрПоГоризонтали = (Право - Лево)/2 + Лево;
	ЦентрПоГоризонтали = Цел(Цел(ЦентрПоГоризонтали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	НачальнаяВысота = КоординатыГраницФункции.ЦентрПоВертикали - ОбщаяВысота/2;
	НачальнаяВысота = Цел(Цел(НачальнаяВысота/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	ТекущаяВысота = НачальнаяВысота;
	
	НомерБлока = 0;
	
	Для Каждого ДанныеАгрегата из ДанныеАгрегатов Цикл
		
		НомерБлока = НомерБлока + 1;
		
		Верх = ТекущаяВысота;
		Низ  = ТекущаяВысота + Настройки.ВысотаФункции;
		
		ЦентрПоВертикали = (Низ - Верх)/2 + Верх;
		ЦентрПоВертикали = Цел(Цел(ЦентрПоВертикали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
		
		КоординатыБлока = Новый Структура;
		
		КоординатыБлока.Вставить("Левая", Лево);
		КоординатыБлока.Вставить("Правая", Право);
		КоординатыБлока.Вставить("Верхняя",Верх);
		КоординатыБлока.Вставить("Нижняя", Низ);
		КоординатыБлока.Вставить("ЦентрПоГоризонтали", ЦентрПоГоризонтали);
		КоординатыБлока.Вставить("ЦентрПоВертикали", ЦентрПоВертикали);
		КоординатыБлока.Вставить("НомерБлока", НомерБлока);
		
		КоординатыБлоковАгрегатов.Добавить(КоординатыБлока);
		
		ТекущаяВысота = Низ + Настройки.ОтступМеждуФункциямиПоВертикали;
		
		Если НомерБлока >= КоличествоБлоковАгрегатов Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	КоординатыБлоков = Новый Структура;
	КоординатыБлоков.Вставить("Агрегаты", КоординатыБлоковАгрегатов);
	КоординатыБлоков.Вставить("Связи", КоординатыБлоковСвязей);
	
	Возврат КоординатыБлоков;
	
КонецФункции

Функция РасчетныеКоординатыБлокаВыхода(КоординатыГраницФункции, Настройки)
	
	Лево  = КоординатыГраницФункции.Правая + Настройки.ОтступОтГраницФункции;
	Право = Лево + Настройки.ШиринаФункции;
	
	ЦентрПоГоризонтали = (Право - Лево)/2 + Лево;
	ЦентрПоГоризонтали = Цел(Цел(ЦентрПоГоризонтали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	Верх = КоординатыГраницФункции.ЦентрПоВертикали - Настройки.ВысотаФункции/2;
	Верх = Цел(Цел(Верх/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	Низ  = Верх + Настройки.ВысотаФункции;
		
	ЦентрПоВертикали = (Низ - Верх)/2 + Верх;
	ЦентрПоВертикали = Цел(Цел(ЦентрПоВертикали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
		
	КоординатыБлока = Новый Структура;
		
	КоординатыБлока.Вставить("Левая",  Лево);
	КоординатыБлока.Вставить("Правая", Право);
	КоординатыБлока.Вставить("Верхняя",Верх);
	КоординатыБлока.Вставить("Нижняя", Низ);
	КоординатыБлока.Вставить("ЦентрПоГоризонтали", ЦентрПоГоризонтали);
	КоординатыБлока.Вставить("ЦентрПоВертикали",   ЦентрПоВертикали);
	
	Возврат КоординатыБлока;
	
КонецФункции

Функция ДанныеОКоличествеБлоковСвязиКонечнойФункции(ДанныеАгрегатов, Настройки, ВыводятсяСвязи)
	
	МаксимумСвязей = Настройки.МаксимумСвязейКонечнойФункции;
	
	КоличествоАгрегатов = 0;
	КоличествоСвязей = 0;
	
	Для Каждого СтрокаТаблицы из ДанныеАгрегатов Цикл
		
		КоличествоАгрегатов = КоличествоАгрегатов + 1;
		КоличествоСвязей = КоличествоСвязей + СтрокаТаблицы.Связи.Количество();
		
		Если ВыводятсяСвязи И КоличествоСвязей >= МаксимумСвязей Тогда
			Прервать;
		КонецЕсли;
		
		Если КоличествоАгрегатов >= МаксимумСвязей Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Результат = Новый Структура;
	Результат.Вставить("КоличествоАгрегатов", КоличествоАгрегатов);
	Результат.Вставить("КоличествоСвязей", Мин(МаксимумСвязей, КоличествоСвязей));
	
	Возврат Результат;
	
КонецФункции

Функция ПотребителиРезультатаКонечнойФункции(ФункцияИсточник)
	
	Потребители = Новый Массив;
	
	Если Не ЗначениеЗаполнено(ФункцияИсточник) Тогда
		Возврат Потребители;
	КонецЕсли;
	
	ТекстЗапроса = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ФункцииСистемыВходящиеДанные.Ссылка КАК Ссылка,
	|	ФункцииСистемыВходящиеДанные.Ссылка.Наименование КАК Наименование,
	|	ФункцииСистемыВходящиеДанные.Ссылка.ПолныйКод КАК ПолныйКод,
	|	ФункцииСистемыВходящиеДанные.Ссылка.ТипФункции КАК ТипФункции,
	|	ФункцииСистемыВходящиеДанные.Ссылка.Результат КАК Результат,
	|	ФункцииСистемыВходящиеДанные.Функция.Результат КАК РезультатПотребляемойФункции
	|ИЗ
	|	Справочник.ФункцииСистемы.ВходящиеДанные КАК ФункцииСистемыВходящиеДанные
	|ГДЕ
	|	ФункцииСистемыВходящиеДанные.Функция = &ФункцияИсточник
	|	И НЕ ФункцииСистемыВходящиеДанные.Ссылка.ПометкаУдаления
	|
	|УПОРЯДОЧИТЬ ПО
	|	ПолныйКод";
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("ФункцияИсточник", ФункцияИсточник);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	НомерСтроки = 0;
	
	Пока Выборка.Следующий() Цикл
		
		НомерСтроки = НомерСтроки +1;
		
		Структура = Новый Структура;
		Структура.Вставить("Ссылка", Выборка.Ссылка);
		Структура.Вставить("Наименование", Выборка.Наименование);
		Структура.Вставить("ПолныйКод", Выборка.Наименование);
		Структура.Вставить("ТипФункции", Выборка.ТипФункции);
		Структура.Вставить("Результат", Выборка.Результат);
		Структура.Вставить("РезультатПотребляемойФункции",    Выборка.РезультатПотребляемойФункции);
		Структура.Вставить("НомерСтроки", НомерСтроки);
		Структура.Вставить("Комментарий", "");
		
		Потребители.Добавить(Структура);
		
	КонецЦикла;
	
	Возврат Потребители;
	
КонецФункции

Функция РасчетныеКоординатыГраницКонечнойФункции(ВходящиеДанные, ДанныеУправления, Исполнители, Потребители, Настройки)
	
	Границы = Новый Структура;
	
	Границы.Вставить("Левая", 0);
	Границы.Вставить("Правая", 0);
	Границы.Вставить("Верхняя", 0);
	Границы.Вставить("Нижняя", 0);
	
	// Расчет верхней границы
	Верх = Настройки.ВысотаЗаголовка
		   + Настройки.ОтступПоВертикали
		   + Настройки.ВысотаФункции*2
		   + Настройки.ОтступМеждуФункциямиПоВертикали
		   + Настройки.ОтступОтГраницФункции;
			
	// Расчет левой границы
	Лево = Настройки.ОтступОтГраницСхемы
		   + Настройки.ШиринаФункции*2
		   + Настройки.ОтступМеждуФункциямиПоГоризонтали
		   + Настройки.ОтступОтГраницФункции;
		   
	// Расчет правой границы
	Если Настройки.ОтображатьБлокКонечнойФункции Тогда
		МинимальнаяШирина = Настройки.ОтступОтГраницФункции*2 + Настройки.ШиринаФункции;
	Иначе
		МинимальнаяШирина = Настройки.ОтступОтГраницФункции*2 + Настройки.ШиринаКонечнойФункцииБезОтображенияБлока;
	КонецЕсли;
	
	МаксимумСвязей = Настройки.МаксимумСвязейКонечнойФункции;
	
	КоличествоБлоковУправления = Мин(ДанныеУправления.Количество(), МаксимумСвязей);
	
	Если КоличествоБлоковУправления>0 Тогда
		КоличествоПромежутков = КоличествоБлоковУправления-1;
	Иначе
		КоличествоПромежутков = 0;
	КонецЕсли;
		
	ШиринаПоУправлению = КоличествоБлоковУправления*Настройки.ШиринаФункции
						 + КоличествоПромежутков*Настройки.ОтступМеждуФункциямиПоГоризонтали
						 + Настройки.ОтступМеждуФункциямиПоГоризонтали*2;
						 
	КоличествоБлоковИсполнителей = Мин(Исполнители.Количество(), МаксимумСвязей);
	
	Если КоличествоБлоковИсполнителей>0 Тогда
		КоличествоПромежутков = КоличествоБлоковисполнителей-1;
	Иначе
		КоличествоПромежутков = 0;
	КонецЕсли;
		
	ШиринаПоИсполнителям = КоличествоБлоковИсполнителей*Настройки.ШиринаФункции
	                       + КоличествоПромежутков*Настройки.ОтступМеждуФункциямиПоГоризонтали
						   + Настройки.ОтступМеждуФункциямиПоГоризонтали*2;
						 
	Ширина = МАКС(ШиринаПоУправлению, ШиринаПоИсполнителям, МинимальнаяШирина);
	
	Право = Лево + Ширина;
	
	Остаток = Ширина%(Настройки.РазмерСетки*2);
	Если Остаток> 0 Тогда
		Право = Право + Настройки.РазмерСетки;
	КонецЕсли;
	
	// Расчет нижней границы
	Если Настройки.ОтображатьБлокКонечнойФункции Тогда
		МинимальнаяВысота = Настройки.ОтступОтГраницФункции*2 + Настройки.ВысотаФункции;
	Иначе
		МинимальнаяВысота = Настройки.ОтступОтГраницФункции*2 + Настройки.ВысотаКонечнойФункцииБезОтображенияБлока;
	КонецЕсли;
	
	КоличествоБлоковВходов = Мин(ВходящиеДанные.Количество(), МаксимумСвязей);
	
	Если КоличествоБлоковВходов>0 Тогда
		КоличествоПромежутков = КоличествоБлоковВходов-1;
	Иначе
		КоличествоПромежутков = 0;
	КонецЕсли;
	
	ВысотаПоВходам = КоличествоБлоковВходов*Настройки.ВысотаФункции
	                 + КоличествоПромежутков*Настройки.ОтступМеждуФункциямиПоВертикали
					 + Настройки.ОтступМеждуФункциямиПоВертикали*2;
					 
	КоличествоБлоковПотребителей = Мин(Потребители.Количество(), МаксимумСвязей);
	
	Если КоличествоБлоковПотребителей>0 Тогда
		КоличествоПромежутков = КоличествоБлоковПотребителей-1;
	Иначе
		КоличествоПромежутков = 0;
	КонецЕсли;
	
	ВысотаПоПотребителям = КоличествоБлоковПотребителей*Настройки.ВысотаФункции
	                       + КоличествоПромежутков*Настройки.ОтступМеждуФункциямиПоВертикали
						   + Настройки.ОтступМеждуФункциямиПоВертикали*2;
	
	Высота = МАКС(ВысотаПоВходам, ВысотаПоПотребителям, МинимальнаяВысота);
	
	Низ = Верх + Высота;
	
	Остаток = Высота%(Настройки.РазмерСетки*2);
	Если Остаток> 0 Тогда
		Низ = Низ + Настройки.РазмерСетки;
	КонецЕсли;
	
	ЦентрПоГоризонтали = Цел(Цел((Право - Лево)/2)/Настройки.РазмерСетки)*Настройки.РазмерСетки + Лево;
	ЦентрПоВертикали = Цел(Цел((Низ - Верх)/2)/Настройки.РазмерСетки)*Настройки.РазмерСетки + Верх;
	
	Границы.Вставить("Левая", Лево);
	Границы.Вставить("Правая", Право);
	Границы.Вставить("Верхняя", Верх);
	Границы.Вставить("Нижняя", Низ);
	Границы.Вставить("ЦентрПоГоризонтали", ЦентрПоГоризонтали);
	Границы.Вставить("ЦентрПоВертикали", ЦентрПоВертикали);
	
	Возврат Границы;
		   
КонецФункции

Процедура УстановитьКоординатыГраниц(Границы, КоординатыГраниц)
	
	// Левая граница
	УстановитьКоординатыГраницы(Границы.Левая, КоординатыГраниц.Левая, КоординатыГраниц.Верхняя,
	                            КоординатыГраниц.Левая, КоординатыГраниц.Нижняя);
								
	// Правая граница
	УстановитьКоординатыГраницы(Границы.Правая, КоординатыГраниц.Правая, КоординатыГраниц.Верхняя,
	                            КоординатыГраниц.Правая, КоординатыГраниц.Нижняя);
								
	// Верхняя граница
	УстановитьКоординатыГраницы(Границы.Верхняя, КоординатыГраниц.Левая, КоординатыГраниц.Верхняя,
	                            КоординатыГраниц.Правая, КоординатыГраниц.Верхняя);
								
	// Нижгяя граница
	УстановитьКоординатыГраницы(Границы.Нижняя, КоординатыГраниц.Левая, КоординатыГраниц.Нижняя,
	                            КоординатыГраниц.Правая, КоординатыГраниц.Нижняя);
											
КонецПроцедуры

Процедура УстановитьКоординатыБлокаКонечнойФункции(БлокФункции, КоординатыГраниц, Настройки)
	
	Если БлокФункции = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если Настройки.ОтображатьБлокКонечнойФункции Тогда
		
		ШиринаБлока = Настройки.ШиринаФункции;
		ВысотаБлока = Настройки.ВысотаФункции;
		
		ПоловинаШирины = Цел(Цел((ШиринаБлока)/2)/Настройки.РазмерСетки)*Настройки.РазмерСетки;
		ПоловинаВысоты = Цел(Цел((ВысотаБлока)/2)/Настройки.РазмерСетки)*Настройки.РазмерСетки;
		
		Лево   = КоординатыГраниц.ЦентрПоГоризонтали - ПоловинаШирины;
		Право  = КоординатыГраниц.ЦентрПоГоризонтали + ПоловинаШирины;
		Верх   = КоординатыГраниц.ЦентрПоВертикали   - ПоловинаВысоты;
		Низ    = КоординатыГраниц.ЦентрПоВертикали   + ПоловинаВысоты;
		
	Иначе
		
		Лево   = КоординатыГраниц.Левая;
		Право  = КоординатыГраниц.Правая;
		Верх   = КоординатыГраниц.Верхняя;
		Низ    = КоординатыГраниц.Нижняя;
		
	КонецЕсли;
	
	БлокФункции.RectLeft   = Лево;
	БлокФункции.RectRight  = Право;
	БлокФункции.RectTop    = Верх;
	БлокФункции.RectBottom = Низ;
	
КонецПроцедуры

Функция АгрегатыИСвязиКонечнойФункции(РеквизитыФункции, ИнформацияОСвязях)
	
	ТаблицаСвязей = Новый ТаблицаЗначений;
	ТаблицаСвязей.Колонки.Добавить("Связь", Новый ОписаниеТипов("СправочникСсылка.ФункцииСистемы"));
	ТаблицаСвязей.Колонки.Добавить("Наименование", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(100)));
	ТаблицаСвязей.Колонки.Добавить("Комментарий", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(100)));
	ТаблицаСвязей.Колонки.Добавить("ПолныйКод", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(100)));
	ТаблицаСвязей.Колонки.Добавить("Результат", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(1000)));
	ТаблицаСвязей.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число"));
	ТаблицаСвязей.Колонки.Добавить("Вход", Новый ОписаниеТипов("Булево"));
	ТаблицаСвязей.Колонки.Добавить("Управление", Новый ОписаниеТипов("Булево"));
	ТаблицаСвязей.Колонки.Добавить("Потребитель", Новый ОписаниеТипов("Булево"));
	ТаблицаСвязей.Колонки.Добавить("ТипФункции", Новый ОписаниеТипов("ПеречислениеСсылка.ТипыФункций"));
	
	Для Каждого ЭлементСтруктуры из ИнформацияОСвязях Цикл
		
		Если ЭлементСтруктуры.Ключ <> "Исполнители" Тогда
			
			Для Каждого РеквизитыСвязи из ЭлементСтруктуры.Значение Цикл
					
					НоваяСтрока = ТаблицаСвязей.Добавить();
					НоваяСтрока.Связь        = РеквизитыСвязи.Ссылка;
					НоваяСтрока.Наименование = РеквизитыСвязи.Наименование;
					НоваяСтрока.ПолныйКод    = РеквизитыСвязи.ПолныйКод;
					НоваяСтрока.Комментарий  = РеквизитыСвязи.Комментарий;
					НоваяСтрока.НомерСтроки  = РеквизитыСвязи.НомерСтроки;
					НоваяСтрока.ТипФункции   = РеквизитыСвязи.ТипФункции;
					НоваяСтрока.Результат    = РеквизитыСвязи.Результат;
					
					Если НЕ ЗначениеЗаполнено(НоваяСтрока.ТипФункции) Тогда
						НоваяСтрока.ТипФункции = Перечисления.ТипыФункций.Функция;
					КонецЕсли;
					
					Если ЭлементСтруктуры.Ключ = "ВходящиеДанные" Тогда
						НоваяСтрока.Вход = Истина;
					ИначеЕсли ЭлементСтруктуры.Ключ = "ДанныеУправления" Тогда
						НоваяСтрока.Управление = Истина;
					ИначеЕсли ЭлементСтруктуры.Ключ = "Потребители" Тогда
						НоваяСтрока.Потребитель = Истина;
					КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
	
	КонецЦикла;
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ТаблицаСвязей.Связь КАК Связь,
	|	ТаблицаСвязей.Комментарий КАК Комментарий,
	|	ТаблицаСвязей.НомерСтроки КАК НомерСтроки,
	|	ТаблицаСвязей.Вход КАК Вход,
	|	ТаблицаСвязей.Управление КАК Управление,
	|	ТаблицаСвязей.Потребитель КАК Потребитель
	|ПОМЕСТИТЬ ВТСвязи
	|ИЗ
	|	&ТаблицаСвязей КАК ТаблицаСвязей
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	|	ФункцииСистемы.Ссылка КАК Связь,
	|	ФункцииСистемы.Наименование КАК Наименование,
	|	ФункцииСистемы.ПолныйКод КАК ПолныйКод,
	|	ВТСвязи.НомерСтроки КАК НомерСтроки,
	|	ФункцииСистемы.Результат КАК Результат,
	|	ФункцииСистемы.ТипФункции КАК ТипФункции,
	|	ИСТИНА КАК ЭтоСвязь,
	|	ВТСвязи.Вход КАК Вход,
	|	ВТСвязи.Управление КАК Управление,
	|	ВТСвязи.Потребитель КАК Потребитель
	|ИЗ
	|	ВТСвязи КАК ВТСвязи
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ФункцииСистемы КАК ФункцииСистемы
	|		ПО ВТСвязи.Связь = ФункцииСистемы.Ссылка
	|
	|УПОРЯДОЧИТЬ ПО
	|	ПолныйКод,
	|	НомерСтроки
	|ИТОГИ ПО
	|	Связь ИЕРАРХИЯ"
	;
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("ТаблицаСвязей", ТаблицаСвязей);
	
	ДеревоСвязей = Запрос.Выполнить().Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
	
	ИерархияФункции = ИерархияФункции(РеквизитыФункции.Ссылка);
		
	// Формируется цепочка элементов дерева от функции вверх по иерархии
	ЭлементыИерархии = Новый Массив;
	ЗаполнитьЭлементыИерархии(ЭлементыИерархии, ИерархияФункции.Строки, РеквизитыФункции.Ссылка);
	
	СвязиИАгрегаты = ФункцииАгрегатыИСвязи(ДеревоСвязей, ЭлементыИерархии);
	СвязиИАгрегатыВерхнегоУровня = СвязиИАгрегатыВерхнегоУровня(ДеревоСвязей);
	
	АгрегатыВходы = ТаблицаДляАгрегатов();
	АгрегатыУправление = ТаблицаДляАгрегатов();
	АгрегатыПотребители = ТаблицаДляАгрегатов();
	
	Для Каждого СтрокаТаблицы из ТаблицаСвязей Цикл
		
		Если СтрокаТаблицы.Вход Тогда
			ДанныеАгрегатов = АгрегатыВходы;
		ИначеЕсли СтрокаТаблицы.Управление Тогда
			ДанныеАгрегатов = АгрегатыУправление;
		ИначеЕсли СтрокаТаблицы.Потребитель Тогда
			ДанныеАгрегатов = АгрегатыПотребители;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(СтрокаТаблицы.Связь) Тогда
			СвойстваАгрегата = СвязиИАгрегаты.Получить(СтрокаТаблицы.Связь);
			
			Если СвойстваАгрегата = Неопределено Тогда
				СвойстваАгрегата = СвязиИАгрегатыВерхнегоУровня.Получить(СтрокаТаблицы.Связь);
			КонецЕсли;
		Иначе
			СвойстваАгрегата = Неопределено;
		КонецЕсли;
		
		Если СвойстваАгрегата = Неопределено Тогда
			СвойстваАгрегата = Новый Структура;
			СвойстваАгрегата.Вставить("Ссылка", СтрокаТаблицы.Связь);
			
			Если ЗначениеЗаполнено(СтрокаТаблицы.Наименование) Тогда
				СвойстваАгрегата.Вставить("Наименование", СтрокаТаблицы.Наименование);
			Иначе
				СвойстваАгрегата.Вставить("Наименование", СтрокаТаблицы.Комментарий);
			КонецЕсли;
			
			СвойстваАгрегата.Вставить("ПолныйКод", СтрокаТаблицы.ПолныйКод);
			СвойстваАгрегата.Вставить("Результат", СтрокаТаблицы.Результат);
		КонецЕсли;
		
		СвойстваАгрегата.Вставить("РезультатПотребляемойФункции", РеквизитыФункции.Результат);
		
		СвойстваСвязи = Новый Структура;
		СвойстваСвязи.Вставить("Ссылка", СтрокаТаблицы.Связь);
		
		Если ЗначениеЗаполнено(СтрокаТаблицы.Наименование) Тогда
			СвойстваСвязи.Вставить("Наименование", СтрокаТаблицы.Наименование);
		Иначе
			СвойстваСвязи.Вставить("Наименование", СтрокаТаблицы.Комментарий);
		КонецЕсли;
		
		СвойстваСвязи.Вставить("ПолныйКод", СтрокаТаблицы.ПолныйКод);
		СвойстваСвязи.Вставить("Результат", СтрокаТаблицы.Результат);
		СвойстваСвязи.Вставить("ТипФункции", СтрокаТаблицы.ТипФункции);
		СвойстваСвязи.Вставить("РезультатПотребляемойФункции", РеквизитыФункции.Результат);
		
		ИндексСвязи = ТаблицаСвязей.Индекс(СтрокаТаблицы);
		
		Если ЗначениеЗаполнено(СвойстваАгрегата.Ссылка) Тогда
			ДанныеПоАгрегату = ДанныеАгрегатов.Найти(СвойстваАгрегата.Ссылка, "Ссылка");
		Иначе
			ДанныеПоАгрегату = ДанныеАгрегатов.Найти(ИндексСвязи, "ИндексСвязи");
		КонецЕсли;
		
		Если ДанныеПоАгрегату = Неопределено Тогда
			
			ДанныеПоАгрегату = ДанныеАгрегатов.Добавить();
			ЗаполнитьЗначенияСвойств(ДанныеПоАгрегату, СвойстваАгрегата);
			ДанныеПоАгрегату.ИндексСвязи = ИндексСвязи;
			
			Связи = Новый Массив;
			Связи.Добавить(СвойстваСвязи);
			
			ДанныеПоАгрегату.Связи = Связи;
		Иначе
			ДанныеПоАгрегату.Связи.Добавить(СвойстваСвязи);
		КонецЕсли;
		
	КонецЦикла;
	
	АгрегатыВходы.Сортировать("ПолныйКод");
	АгрегатыУправление.Сортировать("ПолныйКод");
	АгрегатыПотребители.Сортировать("ПолныйКод");
	
	ИнформацияПоАгрегатамИСвязям = Новый Структура;
	ИнформацияПоАгрегатамИСвязям.Вставить("Вход", АгрегатыВходы);
	ИнформацияПоАгрегатамИСвязям.Вставить("Управление", АгрегатыУправление);
	ИнформацияПоАгрегатамИСвязям.Вставить("Выход", АгрегатыПотребители);
	
	Возврат ИнформацияПоАгрегатамИСвязям;
	
КонецФункции

Функция ДочерниеФункцииИСвязи(ФункцияРодитель, Настройки)
	
    ДанныеСвязейИДочерних = СвязиИДанныеДочернихФункций(ФункцияРодитель);
	
	ДеревоФункций = ДанныеСвязейИДочерних.ДеревоФункций;
	ДочерниеФункции = ДанныеСвязейИДочерних.ДочерниеФункции;
	СвойстваДочерних = ДанныеСвязейИДочерних.СвойстваДочерних;
	
	// Заполняется информация о внешних связях дочерних функций
	
	СоответствиеДочерних = Новый Соответствие;
	СвязиИИсточники = Новый Соответствие;
		
	ИерархияФункции = ИерархияФункции(ФункцияРодитель);
		
	// Формируется цепочка элементов дерева от функции-родителя вверх по иерархии
	ЭлементыИерархии = Новый Массив;
	ЗаполнитьЭлементыИерархии(ЭлементыИерархии, ИерархияФункции.Строки, ФункцияРодитель);
	
	СвязиИАгрегаты = ФункцииАгрегатыИСвязи(ДанныеСвязейИДочерних.ИерархияСвязей, ЭлементыИерархии);
	СвязиИАгрегатыВерхнегоУровня = ДанныеСвязейИДочерних.СвязиИАгрегатыВерхнегоУровня;
	
	ИнформацияОСвязяхИАгрегатах = Новый Структура;
	ИнформацияОСвязяхИАгрегатах.Вставить("СвязиИАгрегаты", СвязиИАгрегаты);
	ИнформацияОСвязяхИАгрегатах.Вставить("СвязиИАгрегатыВерхнегоУровня", СвязиИАгрегатыВерхнегоУровня);
		
	Для Каждого ДочерняяФункция из ДочерниеФункции Цикл
		
		ВходыСАгрегатами       = ТаблицаДляАгрегатов();
		УправлениеСАгрегатами  = ТаблицаДляАгрегатов();
		ПотребителиСАгрегатами = ТаблицаДляАгрегатов();
		
		Исполнители = Новый Массив;
		
		СтруктураОтбораДочерней = Новый Структура;
		СтруктураОтбораДочерней.Вставить("ИспользующаяФункция", ДочерняяФункция);
		СтруктураОтбораДочерней.Вставить("Связь", NULL);
		
		СтрокиДочерней = ДеревоФункций.Строки.НайтиСтроки(СтруктураОтбораДочерней, Истина);
		
		Если СтрокиДочерней.Количество()>0 Тогда
			СтрокаДочернейФункции = СтрокиДочерней[0];
		Иначе
			СтрокаДочернейФункции = Неопределено;
		КонецЕсли;
		
		СтруктураОтбораВнутренних = Новый Структура("ВнутренняяСвязь", Истина);
		
		СтруктураОтбораВнешних = Новый Структура;
		СтруктураОтбораВнешних.Вставить("ВнешняяСвязь", Истина);
		
		Если СтрокаДочернейФункции = Неопределено Тогда
			СтрокиВнешнихСвязей = Новый Массив;
			СтрокиВнутреннихСвязей = Новый Массив;
		Иначе
			СтрокиВнешнихСвязей = СтрокаДочернейФункции.Строки.НайтиСтроки(СтруктураОтбораВнешних, Истина);
			СтрокиВнутреннихСвязей = СтрокаДочернейФункции.Строки.НайтиСтроки(СтруктураОтбораВнутренних, Истина);
		КонецЕсли;
		
		СвойстваСвязей = Новый Соответствие;
		
		СтруктураСвязей = Новый Структура;
		
		СтруктураСвязей.Вставить("ВходыСАгрегатами", ВходыСАгрегатами);
		СтруктураСвязей.Вставить("УправлениеСАгрегатами", УправлениеСАгрегатами);
		СтруктураСвязей.Вставить("ПотребителиСАгрегатами", ПотребителиСАгрегатами);
		СтруктураСвязей.Вставить("Исполнители", Исполнители);
		
		ЗаполнитьВнешниеСвязи(СтруктураСвязей, СтрокиВнешнихСвязей,
		                      СвойстваСвязей, ИнформацияОСвязяхИАгрегатах, Настройки);
		
		ИнформацияОВходах = Новый Соответствие;
		ИнформацияОбУправлении = Новый Соответствие;
		
		ЗаполнитьВнутренниеСвязи(ИнформацияОВходах, ИнформацияОбУправлении, ДочерняяФункция, СтрокиВнутреннихСвязей, СвязиИИсточники);
		
		СтруктураСвязей.Вставить("ИнформацияоВходах", ИнформацияоВходах);
		СтруктураСвязей.Вставить("ИнформацияОбУправлении", ИнформацияОбУправлении);
		
		СоответствиеДочерних.Вставить(ДочерняяФункция, СтруктураСвязей);
		
	КонецЦикла;
	
	КоличествоДочерних = ДочерниеФункции.Количество();
	
	// Для каждой из дочерних функций определяется, какие другие
	// из дочерних функций являются выходами для внутренних связей этой дочерней функции
	
	Для Каждого ЭлементСоответствия из СоответствиеДочерних Цикл
		
		ДочерняяФункция = ЭлементСоответствия.Ключ;
		ИнформацияОДочерней = ЭлементСоответствия.Значение;
		
		ВнутренниеВходы = Новый Соответствие;
		ВнутреннееУправление = Новый Соответствие;
		
		ИнформацияОВходах = ИнформацияоДочерней.ИнформацияОВходах;
		ИнформацияОбУправлении = ИнформацияоДочерней.ИнформацияОбУправлении;
		
		ДополнитьИнформациюОСвязяхВыходами(ИнформацияОВходах, СвязиИИсточники, ДочерняяФункция, ВнутренниеВходы);
		ДополнитьИнформациюОСвязяхВыходами(ИнформацияОбУправлении, СвязиИИсточники, ДочерняяФункция, ВнутреннееУправление);
		
		ИнформацияОДочерней.Вставить("ВнутренниеВходы", ВнутренниеВходы);
		ИнформацияОДочерней.Вставить("ВнутреннееУправление", ВнутреннееУправление);
		
	КонецЦикла;
	
	СтруктураРезультата = Новый Структура;
	СтруктураРезультата.Вставить("ДочерниеФункции", ДочерниеФункции);
	СтруктураРезультата.Вставить("СвязиФункций", СоответствиеДочерних);
	СтруктураРезультата.Вставить("СвойстваФункций", СвойстваДочерних);
	
	Возврат СтруктураРезультата;
	
КонецФункции

Функция ТаблицаДляАгрегатов()
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Ссылка", Новый ОписаниеТипов("СправочникСсылка.ФункцииСистемы"));
	Таблица.Колонки.Добавить("Наименование");
	Таблица.Колонки.Добавить("ПолныйКод");
	Таблица.Колонки.Добавить("Результат");
	Таблица.Колонки.Добавить("РезультатПотребляемойФункции");
	Таблица.Колонки.Добавить("ТипФункции", Новый ОписаниеТипов("ПеречислениеСсылка.ТипыФункций"));
	Таблица.Колонки.Добавить("ИндексСвязи");
	Таблица.Колонки.Добавить("Связи");
	
	Возврат Таблица;
	
КонецФункции

Функция СвязиИДанныеДочернихФункций(ФункцияРодитель)
	
	ТекстЗапроса=
	"ВЫБРАТЬ
	|	ФункцииСистемы.Ссылка КАК Функция,
	|	ФункцииСистемы.Наименование КАК Наименование,
	|	ФункцииСистемы.ПолныйКод КАК ПолныйКод,
	|	ФункцииСистемы.ТипФункции КАК ТипФункции,
	|	ФункцииСистемы.Результат КАК Результат
	|ПОМЕСТИТЬ ВТДочерниеФункции
	|ИЗ
	|	Справочник.ФункцииСистемы КАК ФункцииСистемы
	|ГДЕ
	|	НЕ ФункцииСистемы.ПометкаУдаления
	|	И ФункцииСистемы.Родитель = &ФункцияРодитель
	|	И &ФункцияРодитель <> ЗНАЧЕНИЕ(Справочник.ФункцииСистемы.ПустаяСсылка) 
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	|	ФункцииСистемыВходящиеДанные.Функция КАК Вход,
	|	ФункцииСистемыВходящиеДанные.Ссылка КАК ИспользующаяФункция,
	|	ФункцииСистемыВходящиеДанные.Функция.ПолныйКод КАК ПолныйКод,
	|	ФункцииСистемыВходящиеДанные.Функция.Наименование КАК Наименование,
	|	ФункцииСистемыВходящиеДанные.Функция.ТипФункции КАК ТипФункции,
	|	ФункцииСистемыВходящиеДанные.Функция.Результат КАК Результат,
	|	ВЫБОР
	|		КОГДА ФункцииСистемыВходящиеДанные.Функция В ИЕРАРХИИ (&ФункцияРодитель)
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ ЛОЖЬ
	|	КОНЕЦ КАК ВнутренняяСвязь
	|ПОМЕСТИТЬ ВТВходы
	|ИЗ
	|	Справочник.ФункцииСистемы.ВходящиеДанные КАК ФункцииСистемыВходящиеДанные
	|ГДЕ
	|	ФункцииСистемыВходящиеДанные.Ссылка В ИЕРАРХИИ(&ФункцияРодитель)
	|	И НЕ ФункцииСистемыВходящиеДанные.Ссылка.ПометкаУдаления
	|	И НЕ ФункцииСистемыВходящиеДанные.Функция.ПометкаУдаления
	|	И ФункцииСистемыВходящиеДанные.ВидСвязи = ЗНАЧЕНИЕ(Перечисление.ВидыВходящихСвязейФункций.Вход)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	|	ФункцииСистемыВходящиеДанные.Функция КАК Управление,
	|	ФункцииСистемыВходящиеДанные.Ссылка КАК ИспользующаяФункция,
	|	ФункцииСистемыВходящиеДанные.Функция.ПолныйКод КАК ПолныйКод,
	|	ФункцииСистемыВходящиеДанные.Функция.Наименование КАК Наименование,
	|	ФункцииСистемыВходящиеДанные.Функция.ТипФункции КАК ТипФункции,
	|	ФункцииСистемыВходящиеДанные.Функция.Результат КАК Результат,
	|	ВЫБОР
	|		КОГДА ФункцииСистемыВходящиеДанные.Функция В ИЕРАРХИИ (&ФункцияРодитель)
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ ЛОЖЬ
	|	КОНЕЦ КАК ВнутренняяСвязь
	|ПОМЕСТИТЬ ВТУправление
	|ИЗ
	|	Справочник.ФункцииСистемы.ВходящиеДанные КАК ФункцииСистемыВходящиеДанные
	|ГДЕ
	|	ФункцииСистемыВходящиеДанные.Ссылка В ИЕРАРХИИ(&ФункцияРодитель)
	|	И НЕ ФункцииСистемыВходящиеДанные.Ссылка.ПометкаУдаления
	|	И НЕ ФункцииСистемыВходящиеДанные.Функция.ПометкаУдаления
	|	И ФункцииСистемыВходящиеДанные.ВидСвязи = ЗНАЧЕНИЕ(Перечисление.ВидыВходящихСвязейФункций.Управление)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	|	ФункцииСистемыИсполнители.Исполнитель,
	|	ФункцииСистемыИсполнители.Ссылка КАК ИспользующаяФункция,
	|	ФункцииСистемыИсполнители.Исполнитель.ПолныйКод КАК ПолныйКод,
	|	ФункцииСистемыИсполнители.Исполнитель.Наименование КАК Наименование,
	|	ЗНАЧЕНИЕ(Перечисление.ТипыФункций.ПустаяСсылка) КАК ТипФункции,
	|	"""" КАК Результат
	|ПОМЕСТИТЬ ВТИсполнители
	|ИЗ
	|	Справочник.ФункцииСистемы.Исполнители КАК ФункцииСистемыИсполнители
	|ГДЕ
	|	ФункцииСистемыИсполнители.Ссылка В ИЕРАРХИИ(&ФункцияРодитель)
	|	И НЕ ФункцииСистемыИсполнители.Ссылка.ПометкаУдаления
	|	И НЕ ФункцииСистемыИсполнители.Исполнитель.ПометкаУдаления
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	|	ФункцииСистемыВходящиеДанные.Функция КАК ПотребляемаяФункция,
	|	ФункцииСистемыВходящиеДанные.Ссылка КАК ИспользующаяФункция,
	|	ФункцииСистемыВходящиеДанные.Ссылка.ПолныйКод КАК ПолныйКод,
	|	ФункцииСистемыВходящиеДанные.Ссылка.наименование КАК Наименование,
	|	ФункцииСистемыВходящиеДанные.Ссылка.ТипФункции КАК ТипФункции,
	|	ФункцииСистемыВходящиеДанные.Ссылка.Результат КАК Результат,
	|	ФункцииСистемыВходящиеДанные.Функция.Результат КАК РезультатПотребляемойФункции,
	|	ВЫБОР
	|		КОГДА ФункцииСистемыВходящиеДанные.Ссылка В ИЕРАРХИИ (&ФункцияРодитель)
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ ЛОЖЬ
	|	КОНЕЦ КАК ВнутренняяСвязь
	|ПОМЕСТИТЬ ВТПотребители
	|ИЗ
	|	Справочник.ФункцииСистемы.ВходящиеДанные КАК ФункцииСистемыВходящиеДанные
	|ГДЕ
	|	ФункцииСистемыВходящиеДанные.Функция В ИЕРАРХИИ(&ФункцияРодитель)
	|	И НЕ ФункцииСистемыВходящиеДанные.Ссылка.ПометкаУдаления
	|	И НЕ ФункцииСистемыВходящиеДанные.Функция.ПометкаУдаления
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТВходы.Вход КАК Связь,
	|	ВТВходы.ИспользующаяФункция КАК ИспользующаяФункция,
	|	ВТВходы.ПолныйКод КАК ПолныйКод,
	|	ВТВходы.Наименование КАК Наименование,
	|	ВТВходы.ТипФункции КАК ТипФункции,
	|	ВТВходы.Результат КАК Результат,
	|   """" КАК РезультатПотребляемойФункции,
	|	ВТВходы.ВнутренняяСвязь КАК ВнутренняяСвязь,
	|	НЕ ВТВходы.ВнутренняяСвязь КАК ВнешняяСвязь,
	|	ИСТИНА КАК Вход,
	|	ЛОЖЬ КАК Управление,
	|	ЛОЖЬ КАК Исполнитель,
	|	ЛОЖЬ КАК Потребитель
	|ИЗ
	|	ВТВходы КАК ВТВходы
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	ВТУправление.Управление,
	|	ВТУправление.ИспользующаяФункция,
	|	ВТУправление.ПолныйКод,
	|	ВТУправление.Наименование,
	|	ВТУправление.ТипФункции,
	|	ВТУправление.Результат,
	|   """" КАК РезультатПотребляемойФункции,
	|	ВТУправление.ВнутренняяСвязь,
	|	НЕ ВТУправление.ВнутренняяСвязь,
	|	ЛОЖЬ,
	|	ИСТИНА,
	|	ЛОЖЬ,
	|	ЛОЖЬ
	|ИЗ
	|	ВТУправление КАК ВТУправление
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	ВТИсполнители.Исполнитель,
	|	ВТИсполнители.ИспользующаяФункция,
	|	ВТИсполнители.ПолныйКод,
	|	ВТИсполнители.Наименование,
	|	ВТИсполнители.ТипФункции,
	|	ВТИсполнители.Результат,
	|   """" КАК РезультатПотребляемойФункции,
	|	ЛОЖЬ,
	|   ИСТИНА,
	|	ЛОЖЬ,
	|	ЛОЖЬ,
	|	ИСТИНА,
	|	ЛОЖЬ
	|ИЗ
	|	ВТИсполнители КАК ВТИсполнители
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	ВТПотребители.ИспользующаяФункция,
	|	ВТПотребители.ПотребляемаяФункция,
	|	ВТПотребители.ПолныйКод,
	|	ВТПотребители.Наименование,
	|	ВТПотребители.ТипФункции,
	|	ВТПотребители.Результат,
	|   ВТПотребители.РезультатПотребляемойФункции КАК РезультатПотребляемойФункции,
	|	ВТПотребители.ВнутренняяСвязь,
	|	НЕ ВТПотребители.ВнутренняяСвязь,
	|	ЛОЖЬ,
	|	ЛОЖЬ,
	|	ЛОЖЬ,
	|	ИСТИНА
	|ИЗ
	|	ВТПотребители КАК ВТПотребители
	|
	|УПОРЯДОЧИТЬ ПО
	|	ПолныйКод
	|ИТОГИ ПО
	|	ИспользующаяФункция ИЕРАРХИЯ"
	;

	Запрос = Новый Запрос(ТекстЗапроса);
	
	МенеджерВТ = Новый МенеджерВременныхТаблиц;
	Запрос.УстановитьПараметр("ФункцияРодитель", ФункцияРодитель);
	Запрос.МенеджерВременныхТаблиц = МенеджерВТ;
	
	ДеревоФункций = Запрос.Выполнить().Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
	
	ТаблицаДочерних = Запрос.МенеджерВременныхТаблиц.Таблицы["ВТДочерниеФункции"].ПолучитьДанные().Выгрузить();
	ТаблицаДочерних.Сортировать("ПолныйКод");
	
	ДочерниеФункции = ТаблицаДочерних.ВыгрузитьКолонку("Функция");
	
	СвойстваДочерних = Новый Соответствие;
	Для Каждого СтрокаТаблицы из ТаблицаДочерних Цикл
		СвойстваФункции = Новый Структура;
		СвойстваФункции.Вставить("Наименование", СтрокаТаблицы.Наименование);
		СвойстваФункции.Вставить("Результат", СтрокаТаблицы.Результат);
		СвойстваФункции.Вставить("ТипФункции", СтрокаТаблицы.ТипФункции);
		СвойстваДочерних.Вставить(СтрокаТаблицы.Функция, СвойстваФункции);
	КонецЦикла;
	
	ИерархияСвязей = ИерархияСвязей(МенеджерВТ);
	СвязиИАгрегатыВерхнегоУровня = СвязиИАгрегатыВерхнегоУровня(ИерархияСвязей);
	
	Результат = Новый Структура;
	Результат.Вставить("ДеревоФункций", ДеревоФункций);
	Результат.Вставить("ИерархияСвязей", ИерархияСвязей); 
	Результат.Вставить("ДочерниеФункции", ДочерниеФункции);
	Результат.Вставить("СвойстваДочерних", СвойстваДочерних);
	Результат.Вставить("СвязиИАгрегатыВерхнегоУровня", СвязиИАгрегатыВерхнегоУровня);
	
	Возврат Результат;
	
КонецФункции

Функция ИерархияСвязей(МенеджерВТ)
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ВТВходы.Вход КАК Связь,
	|	ВТВходы.Вход.Наименование КАК Наименование,
	|	ВТВходы.Вход.ПолныйКод КАК ПолныйКод,
	|	ВТВходы.ИспользующаяФункция КАК ИспользующаяФункция,
	|	ИСТИНА КАК Вход,
	|	ЛОЖЬ КАК Управление,
	|	ЛОЖЬ КАК Потребитель,
	|   ИСТИНА КАК ЭтоСвязь
	|ИЗ
	|	ВТВходы КАК ВТВходы
	|ГДЕ
	|	НЕ ВТВходы.ВнутренняяСвязь
	|
	|ОБЪЕДИНИТЬ
	|
	|ВЫБРАТЬ
	|	ВТУправление.Управление,
	|	ВТУправление.Управление.Наименование,
	|	ВТУправление.Управление.ПолныйКод,
	|	ВТУправление.ИспользующаяФункция,
	|	ЛОЖЬ,
	|	ИСТИНА,
	|	ЛОЖЬ,
	|   ИСТИНА
	|ИЗ
	|	ВТУправление КАК ВТУправление
	|ГДЕ
	|	НЕ ВТУправление.ВнутренняяСвязь
	|
	|ОБЪЕДИНИТЬ
	|
	|ВЫБРАТЬ
	|	ВТПотребители.ИспользующаяФункция,
	|	ВТПотребители.ИспользующаяФункция.Наименование,
	|	ВТПотребители.ИспользующаяФункция.ПолныйКод,
	|	ВТПотребители.ПотребляемаяФункция,
	|	ЛОЖЬ,
	|	ЛОЖЬ,
	|	ИСТИНА,
	|   ИСТИНА
	|ИЗ
	|	ВТПотребители КАК ВТПотребители
	|ГДЕ
	|	НЕ ВТПотребители.ВнутренняяСвязь
	|ИТОГИ ПО
	|	Связь ИЕРАРХИЯ"
	;
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.МенеджерВременныхТаблиц = МенеджерВТ;
	
	Возврат Запрос.Выполнить().Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
	
КонецФункции

Функция СвязиИАгрегатыВерхнегоУровня(ИерархияСвязей)
	
	СвязиИАгрегаты = Новый Соответствие;
	
	СтруктураОтбора = Новый Структура("ЭтоСвязь", Истина);
	
	СсылкиВерхнегоУровня = Новый Массив;
	Для Каждого СтрокаДерева из ИерархияСвязей.Строки Цикл
		Если ЗначениеЗаполнено(СтрокаДерева.Связь) Тогда
			СсылкиВерхнегоУровня.Добавить(СтрокаДерева.Связь);
		КонецЕсли;
	КонецЦикла;
	
	Реквизиты = "Ссылка,Наименование,ПолныйКод,Результат,ТипФункции";
	РеквизитыФункций = ОбщегоНазначения.ЗначенияРеквизитовОбъектов(СсылкиВерхнегоУровня, Реквизиты);
	
	Для Каждого СтрокаДерева из ИерархияСвязей.Строки Цикл
		
		СтрокиСвязей = СтрокаДерева.Строки.НайтиСтроки(СтруктураОтбора, Истина);
		
		СвойстваАгрегата = ШаблонСвойствФункции();
		СвойстваАгрегата.Ссылка = СтрокаДерева.Связь;
		
		РеквизитыФункции = РеквизитыФункций.Получить(СтрокаДерева.Связь);
		
		Если РеквизитыФункции <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(СвойстваАгрегата, РеквизитыФункции);
		КонецЕсли;
		
		Для Каждого СтрокаСвязи из СтрокиСвязей Цикл
			Если (СтрокаСвязи.Вход ИЛИ СтрокаСвязи.Управление ИЛИ СтрокаСвязи.Потребитель)
				И ЗначениеЗаполнено (СтрокаСвязи.Связь) Тогда
				СвязиИАгрегаты.Вставить(СтрокаСвязи.Связь, СвойстваАгрегата);
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат СвязиИАгрегаты;
	
КонецФункции

Функция ШаблонСвойствФункции()
	
	СвойстваФункции = Новый Структура;
	
	СвойстваФункции.Вставить("Наименование", "");
	СвойстваФункции.Вставить("ПолныйКод", "");
	СвойстваФункции.Вставить("Результат", "");
	СвойстваФункции.Вставить("РезультатПотребляемойФункции", "");
	СвойстваФункции.Вставить("ТипФункции", Перечисления.ТипыФункций.ПустаяСсылка());
	СвойстваФункции.Вставить("Ссылка", Справочники.ФункцииСистемы.ПустаяСсылка());
	
	Возврат СвойстваФункции;
			
КонецФункции

Функция ИерархияФункции(Ссылка)
	
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	Функции.Ссылка КАК Функция
	|ИЗ
	|	Справочник.ФункцииСистемы КАК Функции
	|ГДЕ
	|	Функции.Ссылка = &Функция
	|ИТОГИ ПО
	|	Функция ИЕРАРХИЯ"
	;
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("Функция", Ссылка);
	
	Возврат Запрос.Выполнить().Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
	
КонецФункции

Функция ФункцииАгрегатыИСвязи(ИерархияСвязей, ЭлементыИерархии)
	
	КоличествоЭлементов = ЭлементыИерархии.Количество();
	
	СвязиИАгрегаты = Новый Соответствие;
	
	Если КоличествоЭлементов=0 Тогда
		Возврат СвязиИАгрегаты;
	КонецЕсли;
		
	СтруктураОтбораСвязей = Новый Структура("ЭтоСвязь", Истина);
	
	ОбработанныйЭлементИерархии = Неопределено;
	
	Сч = КоличествоЭлементов-1;
	Пока Сч>=0 Цикл
		
		ЭлементИерархииФункции = ЭлементыИерархии[Сч];
		
		// Выполняется поиск элемента иерархии в иерархии связей
		СтруктураОтбора = Новый Структура;
		СтруктураОтбора.Вставить("Связь", ЭлементИерархииФункции);
		
		СтрокиДерева = ИерархияСвязей.Строки.НайтиСтроки(СтруктураОтбора, Истина);
		
		Если СтрокиДерева.Количество()>0 Тогда
			
			// Обходятся строки, подчиненные элементу иерархии, если они есть
			// Если подчиненная строка- это строка связи, она принимается за агрегатную,
			// иначе анализируется, содержит ли она ниже по иерархии связи и, если
			// содержит, тогда берется за агрегатную.
			
			Для Каждого ПодчиненнаяСтрока из СтрокиДерева[0].Строки Цикл
				
				Если ПодчиненнаяСтрока.Связь = ОбработанныйЭлементИерархии Тогда
					// При движениии вверх по иерархии, если элемент иерархии уже обработан,
					// то при анализа вышестоящего элемента данная ветвь не рассматривается
					Продолжить;
				КонецЕсли;
				
				Если ТипЗнч(ПодчиненнаяСтрока.ЭтоСвязь) = Тип("Булево") И ПодчиненнаяСтрока.ЭтоСвязь Тогда
					
					// Сама связь берется за агрегат
					
					Если ПодчиненнаяСтрока.Вход ИЛИ ПодчиненнаяСтрока.Управление ИЛИ ПодчиненнаяСтрока.Потребитель Тогда
						
						СвойстваАгрегата = Новый Структура;
						СвойстваАгрегата.Вставить("Ссылка", ПодчиненнаяСтрока.Связь);
						СвойстваАгрегата.Вставить("Наименование", ПодчиненнаяСтрока.Наименование);
						СвойстваАгрегата.Вставить("ПолныйКод", ПодчиненнаяСтрока.ПолныйКод);
						
						СвязиИАгрегаты.Вставить(ПодчиненнаяСтрока.Связь, СвойстваАгрегата);
					КонецЕсли;
					
				Иначе
					
					СтрокиСвязей = ПодчиненнаяСтрока.Строки.НайтиСтроки(СтруктураОтбораСвязей, Истина);
					
					Если СтрокиСвязей.Количество()>0 Тогда
						
						Для Каждого СтрокаСвязи из СтрокиСвязей Цикл
							
							Если ТипЗнч(СтрокаСвязи.ЭтоСвязь) = Тип("Булево") И СтрокаСвязи.ЭтоСвязь Тогда
								
								Если СтрокаСвязи.Вход ИЛИ СтрокаСвязи.Управление ИЛИ СтрокаСвязи.Потребитель Тогда
									
									СвойстваАгрегата = Новый Структура;
									СвойстваАгрегата.Вставить("Ссылка", ПодчиненнаяСтрока.Связь);
									СвойстваАгрегата.Вставить("Наименование", ПодчиненнаяСтрока.Наименование);
									СвойстваАгрегата.Вставить("ПолныйКод", ПодчиненнаяСтрока.ПолныйКод);
						
									СвязиИАгрегаты.Вставить(СтрокаСвязи.Связь, СвойстваАгрегата);
								КонецЕсли;
								
							КонецЕсли;
					
						КонецЦикла;
						
					КонецЕсли;
				КонецЕсли;
			
			КонецЦикла;
			
		КонецЕсли;
		
		ОбработанныйЭлементИерархии = ЭлементИерархииФункции;
		Сч = Сч-1;
		
	КонецЦикла;
	
	Возврат СвязиИАгрегаты;
	
КонецФункции

Процедура ЗаполнитьЭлементыИерархии(ЭлементыИерархии, СтрокиДерева, ФункцияРодитель)
	
	Для Каждого СтрокаДерева из СтрокиДерева Цикл
		
		ЭлементыИерархии.Добавить(СтрокаДерева.Функция);
		
		Если СтрокаДерева.Функция = ФункцияРодитель Тогда
			Возврат;
		КонецЕсли;
		
		ЗаполнитьЭлементыИерархии(ЭлементыИерархии, СтрокаДерева.Строки, ФункцияРодитель);
	КонецЦикла;
	
КонецПроцедуры

Процедура ДополнитьИнформациюОСвязяхВыходами(ИнформацияОСвязях, СвязиИИсточники, ДочерняяФункция, СоответствиеСвязей)
	
	Для Каждого ДанныеСвязи из ИнформацияОСвязях Цикл
		
		Источник = СвязиИИсточники.Получить(ДанныеСвязи.Ключ);
		
		Если ЗначениеЗаполнено(Источник) И Источник <> ДочерняяФункция Тогда
			СтруктураИнформации = Новый Структура;
			СтруктураИнформации.Вставить("СвойстваСвязи", ДанныеСвязи.Значение);
			СтруктураИнформации.Вставить("Выход", Источник);
			
			СоответствиеСвязей.Вставить(ДанныеСвязи.Ключ, СтруктураИнформации);
		КонецЕсли;
		
	КонецЦикла;
		
КонецПроцедуры

Процедура ЗаполнитьВнешниеСвязи(СтруктураСвязей, СтрокиДерева, СвойстваСвязей, ИнформацияОСвязяхИАгрегатах, Настройки)
	
	ДобавленныеВходыСАгрегатами       = Новый Массив;
	ДобавленноеУправлениеСАгрегатами  = Новый Массив;
	ДобавленныеПотребителиСАгрегатами = Новый Массив;
	
	ДобавленныеИсполнители = Новый Массив;
	
	Для Каждого СтрокаСвязи из СтрокиДерева Цикл
		
		Если НЕ ЗначениеЗаполнено(СтрокаСвязи.Связь) Тогда
			Продолжить;
		КонецЕсли;
		
		СтруктураСвойств = Новый Структура;
		СтруктураСвойств.Вставить("Ссылка", СтрокаСвязи.Связь);
		СтруктураСвойств.Вставить("Наименование", СтрокаСвязи.Наименование);
		СтруктураСвойств.Вставить("ПолныйКод", СтрокаСвязи.ПолныйКод);
		СтруктураСвойств.Вставить("ТипФункции", СтрокаСвязи.ТипФункции);
		СтруктураСвойств.Вставить("Результат", СтрокаСвязи.Результат);
		СтруктураСвойств.Вставить("РезультатПотребляемойФункции", СтрокаСвязи.РезультатПотребляемойФункции);
		
		СвойстваСвязей.Вставить(СтрокаСвязи.Связь, СтруктураСвойств);
		
		Если СтрокаСвязи.Вход Тогда
			
			ЗаполнитьВнешнююСвязьСАгрегатами(СтруктураСвязей.ВходыСАгрегатами, СтрокаСвязи.Связь,
				                             ИнформацияОСвязяхИАгрегатах, СтруктураСвойств, ДобавленныеВходыСАгрегатами);
			
		ИначеЕсли СтрокаСвязи.Управление Тогда
			
			ЗаполнитьВнешнююСвязьСАгрегатами(СтруктураСвязей.УправлениеСАгрегатами, СтрокаСвязи.Связь,
				                             ИнформацияОСвязяхИАгрегатах, СтруктураСвойств, ДобавленноеУправлениеСАгрегатами);
			
		ИначеЕсли СтрокаСвязи.Потребитель Тогда
			
			ЗаполнитьВнешнююСвязьСАгрегатами(СтруктураСвязей.ПотребителиСАгрегатами, СтрокаСвязи.Связь,
				                             ИнформацияОСвязяхИАгрегатах, СтруктураСвойств, ДобавленныеПотребителиСАгрегатами);
											
		ИначеЕсли СтрокаСвязи.Исполнитель Тогда
			
			ЗаполнитьВнешнююСвязь(СтруктураСвязей.Исполнители, СтрокаСвязи.Связь, СтруктураСвойств, ДобавленныеИсполнители);
			
		КонецЕсли;
		
	КонецЦикла;
	
	СтруктураСвязей.ВходыСАгрегатами.Сортировать("ПолныйКод");
	СтруктураСвязей.УправлениеСАгрегатами.Сортировать("ПолныйКод");
	СтруктураСвязей.ПотребителиСАгрегатами.Сортировать("ПолныйКод");
	
КонецПроцедуры

Процедура ЗаполнитьВнешнююСвязь(Связи, Связь, СтруктураСвойств, ДобавленныеСвязи)
	
	Если ДобавленныеСвязи.Найти(Связь) = Неопределено Тогда
		Связи.Добавить(СтруктураСвойств);
		ДобавленныеСвязи.Добавить(Связь);
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаполнитьВнешнююСвязьСАгрегатами(Связи, Связь, ИнформацияОСвязяхИАгрегатах, СтруктураСвойств, ДобавленныеСвязи)
	
	Если ДобавленныеСвязи.Найти(Связь) <> Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	СвязиИАгрегаты = ИнформацияОСвязяхИАгрегатах.СвязиИАгрегаты;
	СвязиИАгрегатыВерхнегоУровня = ИнформацияОСвязяхИАгрегатах.СвязиИАгрегатыВерхнегоУровня;
	
	// Если есть агрегат для связи, берется он, 
	// иначе - агрегат верхнего уровня (если связь и использующая функция не имеют общего родителя),
	// а если нет и агрегата верхнего уровня, т.е. конечная связь расположена в корне дерева,
	// то берется сама эта связь
	
	АгрегатнаяФункция = Неопределено;
	
	СвойстваАгрегата = СвязиИАгрегаты.Получить(Связь);
	
	Если СвойстваАгрегата <> Неопределено Тогда
		АгрегатнаяФункция = СвойстваАгрегата.Ссылка;
	Иначе
		СвойстваАгрегата = СвязиИАгрегатыВерхнегоУровня.Получить(Связь);
		Если СвойстваАгрегата <> Неопределено Тогда
			АгрегатнаяФункция = СвойстваАгрегата.Ссылка;
		КонецЕсли;
	КонецЕсли;
		
	Если АгрегатнаяФункция = Неопределено Тогда
		АгрегатнаяФункция  = Связь;
	КонецЕсли;
	
	СтрокаАгрегата = Связи.Найти(АгрегатнаяФункция, "Ссылка");
	
	Если СтрокаАгрегата = Неопределено Тогда
		// Если агрегата еще нет в таблице, он добавляется
		СвойстваСвязей = Новый Массив;
		СвойстваСвязей.Добавить(СтруктураСвойств);
		
		НоваяСтрока = Связи.Добавить();
		
		ДобавленныеСвязи.Добавить(Связь);
		
		Если СвойстваАгрегата = Неопределено Тогда
			// За свойства агрегата берутся свойства самой связи
			НоваяСтрока.Наименование = СтруктураСвойств.Наименование;
			НоваяСтрока.ПолныйКод = СтруктураСвойств.ПолныйКод;
			НоваяСтрока.Результат = СтруктураСвойств.Результат;
			НоваяСтрока.РезультатПотребляемойФункции = СтруктураСвойств.РезультатПотребляемойФункции;
			НоваяСтрока.ТипФункции = СтруктураСвойств.ТипФункции;
		Иначе
			// Заполняются свойства агрегата
			НоваяСтрока.Наименование = СвойстваАгрегата.Наименование;
			НоваяСтрока.ПолныйКод = СвойстваАгрегата.ПолныйКод;
			// Результат берется из первой связи
			НоваяСтрока.Результат = СтруктураСвойств.Результат;
			НоваяСтрока.РезультатПотребляемойФункции = СтруктураСвойств.РезультатПотребляемойФункции;
			// тип функция для агрегата - всегда "Функция"
			НоваяСтрока.ТипФункции = Перечисления.ТипыФункций.Функция;
		КонецЕсли;
		
		НоваяСтрока.Ссылка = АгрегатнаяФункция;
		НоваяСтрока.Связи = СвойстваСвязей;
	Иначе
		// Если агрегат уже есть в таблице, связь добавляется в коллекцию связей данного агрегата
		СтрокаАгрегата.Связи.Добавить(СтруктураСвойств);
		
		ДобавленныеСвязи.Добавить(СтруктураСвойств.Ссылка);
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаполнитьВнутренниеСвязи(ИнформацияОВходах, ИнформацияОбУправлении, ДочерняяФункция, СтрокиДерева, СвязиИИсточники)
	
	Для Каждого СтрокаДерева из СтрокиДерева Цикл
		
		Если ЗначениеЗаполнено(СтрокаДерева.Связь) Тогда
			
			Если СтрокаДерева.Вход Тогда
				ЗаполнитьИнформациюОВнутреннейСвязи(СтрокаДерева, ИнформацияОВходах);
			ИначеЕсли СтрокаДерева.Управление Тогда
				ЗаполнитьИнформациюОВнутреннейСвязи(СтрокаДерева, ИнформацияОбУправлении);
			ИначеЕсли СтрокаДерева.Потребитель Тогда
				// Для потребляемой функции находится соответствие-
				// дочерняя функция, в иерархии которой расположена потребляемая,
				// чтобы для неконечной функции правильно соотносить с ней выход
				СвязиИИсточники.Вставить(СтрокаДерева.ИспользующаяФункция, ДочерняяФункция);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьИнформациюОВнутреннейСвязи(СтрокаДерева, ИнформацияОСвязях)
	
	Если ИнформацияОСвязях.Получить(СтрокаДерева.Связь)=Неопределено Тогда
		
		СвойстваСвязи = Новый Структура;
		СвойстваСвязи.Вставить("Ссылка", СтрокаДерева.Связь);
		СвойстваСвязи.Вставить("Наименование", СтрокаДерева.Наименование);
		СвойстваСвязи.Вставить("Результат", СтрокаДерева.Результат);
		СвойстваСвязи.Вставить("ТипФункции", СтрокаДерева.ТипФункции);
		
		ИнформацияОСвязях.Вставить(СтрокаДерева.Связь, СвойстваСвязи);
		
	КонецЕсли;
					
КонецПроцедуры

Функция РасчетныеКоординатыГраницНеконечнойФункцииПоАгрегатам(КоличествоБлоковДочерних, ДанныеОКоличествеСвязей, Настройки)
	
	Границы = Новый Структура;
	
	Границы.Вставить("Левая", 0);
	Границы.Вставить("Правая", 0);
	Границы.Вставить("Верхняя", 0);
	Границы.Вставить("Нижняя", 0);
	
	// Расчет верхней границы
	Верх = Настройки.ВысотаЗаголовка
		   + Настройки.ОтступПоВертикали
		   + Настройки.ВысотаФункции
		   + Настройки.ОтступОтГраницФункции;
			
	// Расчет левой границы
	Лево = Настройки.ОтступОтГраницСхемы
		   + Настройки.ШиринаФункции
		   + Настройки.ОтступОтГраницФункции;
		   
	// Расчет правой границы
	БлоковСвязиПоГоризонтали = Мин(ДанныеОКоличествеСвязей.Управление, Настройки.МаксимумБлоковПоГоризонтали);
	БлоковДляВыводаПоГоризонтали = Макс(БлоковСвязиПоГоризонтали, КоличествоБлоковДочерних);
	
	МинимальнаяШирина = Настройки.ОтступОтГраницФункции*2 + Настройки.ШиринаФункции;
	
	Если БлоковДляВыводаПоГоризонтали>0 Тогда
		КоличествоПромежутков = БлоковДляВыводаПоГоризонтали-1;
	Иначе
		КоличествоПромежутков = 0;
	КонецЕсли;
		
	Ширина = БлоковДляВыводаПоГоризонтали*Настройки.ШиринаФункции
			 + КоличествоПромежутков*Настройки.ОтступМеждуФункциямиПоГоризонтали
			 + Настройки.ОтступОтГраницФункции*2;
						 
	Ширина = Макс(Ширина, МинимальнаяШирина);
	
	Право = Лево + Ширина;
	
	Остаток = Ширина%(Настройки.РазмерСетки*2);
	Если Остаток> 0 Тогда
		Право = Право + Настройки.РазмерСетки;
	КонецЕсли;
	
	// Расчет нижней границы
	БлоковСвязиПоВертикали = Мин(Макс(ДанныеОКоличествеСвязей.Вход, ДанныеОКоличествеСвязей.Выход),
	                             Настройки.МаксимумБлоковПоВертикали);
								 
	БлоковДляВыводаПоВертикали = Макс(БлоковСвязиПоВертикали, КоличествоБлоковДочерних);
	
	МинимальнаяВысота = Настройки.ОтступОтГраницФункции*2 + Настройки.ВысотаФункции;
	
	Если БлоковДляВыводаПоВертикали>0 Тогда
		КоличествоПромежутков = БлоковДляВыводаПоВертикали-1;
	Иначе
		КоличествоПромежутков = 0;
	КонецЕсли;
	
	Высота = БлоковДляВыводаПоВертикали*Настройки.ВысотаФункции
	         + КоличествоПромежутков*Настройки.ОтступМеждуФункциямиПоВертикали
			 + Настройки.ОтступОтГраницФункции*2;
	
	Высота = Макс(Высота, МинимальнаяВысота);
	
	Низ = Верх + Высота;
	
	Остаток = Высота%(Настройки.РазмерСетки*2);
	Если Остаток> 0 Тогда
		Низ = Низ + Настройки.РазмерСетки;
	КонецЕсли;
	
	ЦентрПоГоризонтали = Цел(Цел((Право - Лево)/2)/Настройки.РазмерСетки)*Настройки.РазмерСетки + Лево;
	ЦентрПоВертикали = Цел(Цел((Низ - Верх)/2)/Настройки.РазмерСетки)*Настройки.РазмерСетки + Верх;
	
	Границы.Вставить("Левая", Лево);
	Границы.Вставить("Правая", Право);
	Границы.Вставить("Верхняя", Верх);
	Границы.Вставить("Нижняя", Низ);
	Границы.Вставить("ЦентрПоГоризонтали", ЦентрПоГоризонтали);
	Границы.Вставить("ЦентрПоВертикали", ЦентрПоВертикали);
	
	Возврат Границы;
	
КонецФункции

Функция ДобавитьБлокиФункций(ЭлементыСхемы, ДанныеОФункцияхИСвязях, КоординатыГраницФункции, Счетчики, Настройки, ГиперссылкиСвязей)
	
	Макет = Справочники.ФункцииСистемы.ПолучитьМакет("БлокФункции");
	
	ДочерниеФункции = ДанныеОФункцияхИСвязях.ДочерниеФункции;
	СвязиФункций = ДанныеОФункцияхИСвязях.СвязиФункций;
	СвойстваФункций = ДанныеОФункцияхИСвязях.СвойстваФункций;
	
	КоординатыБлоков =
	    РасчетныеКоординатыБлоковДочернихФункций(ДочерниеФункции, КоординатыГраницФункции, Настройки);
		
	// Соответствие блоков содержит связь между блоком-элементом схемы и ссылкой функции
	СоответствиеБлоков = Новый Соответствие;
	
	Для Каждого ДочерняяФункция из ДочерниеФункции Цикл
		
		ДобавляемыеЭлементы = СписокЭлементовМакета(Макет);
		
		КоординатыБлока = КоординатыБлоков.Получить(ДочерняяФункция);
		
		СвойстваФункции = СвойстваФункций.Получить(ДочерняяФункция);
		
		ЭлементБлока = ДобавитьБлокФункции(ЭлементыСхемы, ДобавляемыеЭлементы, ДочерняяФункция, Счетчики, ГиперссылкиСвязей, СвойстваФункции);
												 
		Если ЭлементБлока <> Неопределено Тогда
			
			УстановитьКоординатыБлока(ЭлементБлока, КоординатыБлока);
			
			Если ТипЗнч(СвойстваФункции) = Тип("Структура") Тогда
				Если СвойстваФункции.ТипФункции = Перечисления.ТипыФункций.УчетныйМеханизм Тогда
					УстановитьОтображениеУчетногоМеханизма(ЭлементБлока);
				ИначеЕсли СвойстваФункции.ТипФункции = Перечисления.ТипыФункций.Отчет Тогда
					УстановитьОтображениеОтчета(ЭлементБлока);
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
		СтруктураИнформации = Новый Структура;
		СтруктураИнформации.Вставить("Элемент", ЭлементБлока);
		СтруктураИнформации.Вставить("Координаты", КоординатыБлока);
		СтруктураИнформации.Вставить("Связи", СвязиФункций.Получить(ДочерняяФункция));
		
		СоответствиеБлоков.Вставить(ДочерняяФункция, СтруктураИнформации);
		
	КонецЦикла;
	
	Возврат СоответствиеБлоков;
	
КонецФункции

Функция РасчетныеКоординатыБлоковДочернихФункций(ДочерниеФункции, КоординатыГраницФункции, Настройки)
	
	СоответствиеКоординат = Новый Соответствие;
	
	КоличествоБлоков = ДочерниеФункции.Количество();
	
	ВысотаБлоков = Настройки.ВысотаФункции*КоличествоБлоков; 
	ШиринаБлоков = Настройки.ШиринаФункции*КоличествоБлоков; 
	
	Если КоличествоБлоков>0 Тогда
		КоличествоПромежутков = КоличествоБлоков-1;
	Иначе
		КоличествоПромежутков = 0;
	КонецЕсли;
	
	ОбщаяВысота = ВысотаБлоков + КоличествоПромежутков*Настройки.ОтступМеждуФункциямиПоВертикали;
	ОбщаяШирина = ШиринаБлоков + КоличествоПромежутков*Настройки.ОтступМеждуФункциямиПоГоризонтали;
	
	НачальнаяВысота = КоординатыГраницФункции.ЦентрПоВертикали - ОбщаяВысота/2;
	НачальнаяВысота = Цел(Цел(НачальнаяВысота/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	НачальнаяШирина = КоординатыГраницФункции.ЦентрПоГоризонтали - ОбщаяШирина/2;
	НачальнаяШирина = Цел(Цел(НачальнаяШирина/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	ТекущаяВысота = НачальнаяВысота;
	ТекущаяШирина = НачальнаяШирина;
	
	Для Каждого ДочерняяФункция из ДочерниеФункции Цикл
		
		Блок = ДочерняяФункция;
		
		Верх = ТекущаяВысота;
		Низ  = ТекущаяВысота + Настройки.ВысотаФункции;
		
		Лево  = ТекущаяШирина;
		Право = ТекущаяШирина + Настройки.ШиринаФункции;
		
		ЦентрПоВертикали = (Низ - Верх)/2 + Верх;
		ЦентрПоВертикали = Цел(Цел(ЦентрПоВертикали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
		
		ЦентрПоГоризонтали = (Право - Лево)/2 + Лево;
		ЦентрПоГоризонтали = Цел(Цел(ЦентрПоГоризонтали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
		
		КоординатыБлока = Новый Структура;
		
		КоординатыБлока.Вставить("Левая", Лево);
		КоординатыБлока.Вставить("Правая", Право);
		КоординатыБлока.Вставить("Верхняя",Верх);
		КоординатыБлока.Вставить("Нижняя", Низ);
		КоординатыБлока.Вставить("ЦентрПоГоризонтали", ЦентрПоГоризонтали);
		КоординатыБлока.Вставить("ЦентрПоВертикали", ЦентрПоВертикали);
		
		СоответствиеКоординат.Вставить(Блок, КоординатыБлока);
		
		ТекущаяВысота = Низ + Настройки.ОтступМеждуФункциямиПоВертикали;
		ТекущаяШирина = Право + Настройки.ОтступМеждуФункциямиПоГоризонтали;
		
	КонецЦикла;
	
	Возврат СоответствиеКоординат;
	
КонецФункции

Функция ДобавитьБлокФункции(ЭлементыСхемы, ДобавляемыеЭлементы, ДочерняяФункция, Счетчики, ГиперссылкиСвязей, СвойстваФункции)
	
	ЭлементБлока = Неопределено;
	
	Для Каждого ЭлементСхемы из ДобавляемыеЭлементы Цикл
		
		ДобавленныйЭлемент = ЭлементыСхемы.Добавить(ЭлементСхемы);
		УстановитьСвойстваБлокаФункции(ЭлементСхемы, ДочерняяФункция, СвойстваФункции, Счетчики);
		
		Если ДобавленныйЭлемент.ItemType = 0 Тогда //Декорация
			ЭлементБлока = ДобавленныйЭлемент;
			ЭлементБлока.zOrder =1;
			ГиперссылкиСвязей.Вставить(ДобавленныйЭлемент.ItemCode, ДочерняяФункция);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ЭлементБлока;
	
КонецФункции

Процедура ДобавитьСвязиДочернихФункций(ЭлементыСхемы, ИнформацияОБлокахФункций, ДанныеОФункцияхиСвязях, КоординатыГраницФункции, Счетчики, Настройки, ГиперссылкиСвязей)
	
	МакетВхода       = Справочники.ФункцииСистемы.ПолучитьМакет("Вход");
	МакетУправления  = Справочники.ФункцииСистемы.ПолучитьМакет("Управление");
	МакетПотребителя = Справочники.ФункцииСистемы.ПолучитьМакет("Потребитель");
	МакетИсполнителя = Справочники.ФункцииСистемы.ПолучитьМакет("ИсполнительБезСвязи");
	
	МакетыЛиний = Новый Структура;
	МакетыЛиний.Вставить("Вход", Справочники.ФункцииСистемы.ПолучитьМакет("ЛинияВход"));
	МакетыЛиний.Вставить("Управление", Справочники.ФункцииСистемы.ПолучитьМакет("ЛинияУправление"));
	
	ДанныеОФункцияхИСвязях.Вставить("ИнформацияОБлокахФункций", ИнформацияОБлокахФункций);
	
	КоординатыБлоковСвязей = КоординатыБлоковАгрегатовСвязейИИсполнителей(ДанныеОФункцияхиСвязях,
		                         ИнформацияОБлокахФункций, КоординатыГраницФункции, Настройки);
	
	ДанныеОФункцияхИСвязях.Вставить("КоординатыБлоковСвязей", КоординатыБлоковСвязей);
	
	ВыведенныеСвязи = Новый Структура;
	ВыведенныеСвязи.Вставить("Вход", Новый Массив);
	ВыведенныеСвязи.Вставить("Управление", Новый Массив);
	ВыведенныеСвязи.Вставить("Выход", Новый Массив);
	
	ДанныеОФункцияхИСвязях.Вставить("ВыведенныеСвязи", ВыведенныеСвязи);
	
	Счетчики.Вставить("ВыведеноБлоковАгрегатовВходов", 0);
	Счетчики.Вставить("ВыведеноБлоковАгрегатовУправления", 0);
	Счетчики.Вставить("ВыведеноБлоковАгрегатовПотребителей", 0);
	
	Счетчики.Вставить("ОбработаноДочернихФункций", 0);
	
	СвязиИСсылки = Новый Структура;
	СвязиИСсылки.Вставить("Вход", Новый Соответствие);
	СвязиИСсылки.Вставить("Управление", Новый Соответствие);
	СвязиИСсылки.Вставить("Выход", Новый Соответствие);
	
	ДанныеОФункцияхиСвязях.Вставить("СвязиИСсылки", СвязиИСсылки);
	
	СвойстваСвязейДляВывода = Новый Структура;
	СвойстваСвязейДляВывода.Вставить("Вход", Неопределено);
	СвойстваСвязейДляВывода.Вставить("Управление", Неопределено);
	СвойстваСвязейДляВывода.Вставить("Выход", Неопределено);
	
	ДанныеОФункцияхиСвязях.Вставить("СвойстваСвязиДляВывода", СвойстваСвязейДляВывода);
	
	Для Каждого ДочерняяФункция из ДанныеОФункцияхиСвязях.ДочерниеФункции Цикл
		
		ИнформацияОБлоке = ИнформацияОБлокахФункций.Получить(ДочерняяФункция);
		
		ИнформацияОФункции = Новый Структура;
		ИнформацияОФункции.Вставить("КоординатыГраницФункции", КоординатыГраницФункции);
		ИнформацияОФункции.Вставить("ИнформацияОБлоке", ИнформацияОБлоке);
		ИнформацияОФункции.Вставить("Ссылка", ДочерняяФункция);
		
		ДанныеВхода = Новый Структура;
		ДанныеВхода.Вставить("Макет", МакетВхода);
		ДанныеВхода.Вставить("ВидСвязи", "Вход");
		
		ДанныеУправления = Новый Структура;
		ДанныеУправления.Вставить("Макет", МакетУправления);
		ДанныеУправления.Вставить("ВидСвязи", "Управление");
		
		ДанныеИсполнителей = Новый Структура;
		ДанныеИсполнителей.Вставить("Макет", МакетИсполнителя);
		ДанныеИсполнителей.Вставить("ВидСвязи", "Исполнитель");
		
		ДанныеВыхода = Новый Структура;
		ДанныеВыхода.Вставить("Макет", МакетПотребителя);
		ДанныеВыхода.Вставить("ВидСвязи", "Выход");
			
		ДобавитьАгретагыСвязейДочернейФункции(ЭлементыСхемы, ДанныеВхода, ИнформацияОФункции,
				                              ДанныеОФункцияхИСвязях, Счетчики, ГиперссылкиСвязей, Настройки);
												  
		ДобавитьАгретагыСвязейДочернейФункции(ЭлементыСхемы, ДанныеУправления, ИнформацияОФункции,
				                              ДанныеОФункцияхИСвязях, Счетчики, ГиперссылкиСвязей, Настройки);
											 
		ДобавитьАгретагыСвязейДочернейФункции(ЭлементыСхемы, ДанныеВыхода, ИнформацияОФункции,
				                              ДанныеОФункцияхИСвязях, Счетчики, ГиперссылкиСвязей, Настройки);
												  
		ДобавитьИсполнителейДочернейФункции(ЭлементыСхемы, ДанныеИсполнителей, ИнформацияОФункции,
				                            ДанныеОФункцияхИСвязях, Счетчики, ГиперссылкиСвязей, Настройки);
										 
		ДобавитьВнутренниеСвязи(ЭлементыСхемы, МакетыЛиний, ИнформацияОФункции, ИнформацияОБлокахФункций, Счетчики, Настройки);
		
		Счетчики.Вставить("ОбработаноДочернихФункций", Счетчики.ОбработаноДочернихФункций+1);
		
	КонецЦикла;
	
КонецПроцедуры

Функция КоличествоБлоковАгрегатовСвязей(ДанныеОФункцияхиСвязях)
	
	ДанныеОКоличествеСвязей = Новый Структура;
	
	КоличествоВходы = 0;
	КоличествоУправление = 0;
	КоличествоПотребители = 0;
	
	УчтенныеВходы = Новый Массив;
	УчтенноеУправление = Новый Массив;
	УчтенныеПотребители = Новый Массив;
	
	Для Каждого СвязиФункции из ДанныеОФункцияхиСвязях.СвязиФункций Цикл
		УчестьСвязь(УчтенныеВходы, КоличествоВходы, СвязиФункции.Значение.ВходыСАгрегатами);
		УчестьСвязь(УчтенноеУправление, КоличествоУправление, СвязиФункции.Значение.УправлениеСАгрегатами);
		УчестьСвязь(УчтенныеПотребители, КоличествоПотребители, СвязиФункции.Значение.ПотребителиСАгрегатами);
	КонецЦикла;
	
	ДанныеОКоличествеСвязей.Вставить("Вход", КоличествоВходы);
	ДанныеОКоличествеСвязей.Вставить("Управление", КоличествоУправление);
	ДанныеОКоличествеСвязей.Вставить("Выход", КоличествоПотребители);
	
	Возврат ДанныеОКоличествеСвязей;
	
КонецФункции

Процедура УчестьСвязь(УчтенныеСвязи, КоличествоСвязей, СвязиСАгрегатами)
	
	Для Каждого СтрокаСвязи из СвязиСАгрегатами Цикл
		Если УчтенныеСвязи.Найти(СтрокаСвязи.Ссылка) = Неопределено Тогда
			КоличествоСвязей = КоличествоСвязей + 1;
			УчтенныеСвязи.Добавить(СтрокаСвязи.Ссылка);
		КонецЕсли;
	КонецЦикла;
	
КОнецПроцедуры

Функция КоординатыБлоковАгрегатовСвязейИИсполнителей(ДанныеОФункцияхиСвязях, ИнформацияОБлокахФункций, КоординатыГраницФункции, Настройки)
	
	Координаты = Новый Структура;
	
	ДанныеОКоличествеСвязей = КоличествоБлоковАгрегатовСвязей(ДанныеОФункцияхиСвязях);
						   
	КоличествоВходы       = ДанныеОКоличествеСвязей.Вход;
	КоличествоУправление  = ДанныеОКоличествеСвязей.Управление;
	КоличествоПотребители = ДанныеОКоличествеСвязей.Выход;
	
	КоординатыВходы = КоординатыБлоковАгрегатовСвязейПоВидуСвязи(КоличествоВходы, "Вход",
	                      КоординатыГраницФункции, Настройки);
	
	КоординатыУправление = КоординатыБлоковАгрегатовСвязейПоВидуСвязи(КоличествоУправление, "Управление",
	                           КоординатыГраницФункции, Настройки);
	
	КоординатыПотребители = КоординатыБлоковАгрегатовСвязейПоВидуСвязи(КоличествоПотребители, "Выход",
	                            КоординатыГраницФункции, Настройки);
								
	КоординатыИсполнители = КоординатыБлоковИсполнителей(ДанныеОФункцияхиСвязях, ИнформацияОБлокахФункций,
	                            КоординатыГраницФункции, Настройки);
	
	Координаты.Вставить("Вход", КоординатыВходы);
	Координаты.Вставить("Управление", КоординатыУправление);
	Координаты.Вставить("Выход", КоординатыПотребители);
	Координаты.Вставить("Исполнитель", КоординатыИсполнители);
	
	Возврат Координаты;
	
КонецФункции

Функция КоординатыБлоковАгрегатовСвязейПоВидуСвязи(КоличествоБлоков, ВидСвязи, КоординатыГраницФункции, Настройки)
	
	Координаты = Новый Массив;
	
	Если ВидСвязи = "Вход" ИЛИ ВидСвязи = "Выход" Тогда
		БлоковДляВывода = Мин(КоличествоБлоков, Настройки.МаксимумБлоковПоВертикали);
	ИначеЕсли ВидСвязи = "Управление" Тогда
		БлоковДляВывода = Мин(КоличествоБлоков, Настройки.МаксимумБлоковПоГоризонтали);
	Иначе
		БлоковДляВывода = 0;
	КонецЕсли;
	
	ПоловинаБлоков = Цел(БлоковДляВывода/2);
	
	Если (БлоковДляВывода/2 - ПоловинаБлоков)>0 Тогда
		
		// При нечетном количестве связей средний блок центрируется
		
		Если БлоковДляВывода = 1 Тогда
			ОтступОтЦентраПоВертикали = (Настройки.ВысотаФункции)/2;
			ОтступОтЦентраПоГоризонтали = (Настройки.ШиринаФункции)/2;
		Иначе
			ОтступОтЦентраПоВертикали = ПоловинаБлоков*Настройки.ВысотаФункции
			+ (ПоловинаБлоков-1)*Настройки.ОтступМеждуФункциямиПоВертикали
			+ (Настройки.ВысотаФункции)/2 + Настройки.ОтступМеждуФункциямиПоВертикали;
			
			ОтступОтЦентраПоГоризонтали = ПоловинаБлоков*Настройки.ШиринаФункции
			+ (ПоловинаБлоков-1)*Настройки.ОтступМеждуФункциямиПоГоризонтали
			+ (Настройки.ШиринаФункции)/2 + Настройки.ОтступМеждуФункциямиПоГоризонтали;
		КонецЕсли;
		
	Иначе
		
		ОтступОтЦентраПоВертикали = ПоловинаБлоков*Настройки.ВысотаФункции
		+ (ПоловинаБлоков-1)*Настройки.ОтступМеждуФункциямиПоВертикали
		+ Настройки.ОтступМеждуФункциямиПоВертикали/2;
		
		ОтступОтЦентраПоГоризонтали = ПоловинаБлоков*Настройки.ШиринаФункции
		+ (ПоловинаБлоков-1)*Настройки.ОтступМеждуФункциямиПоГоризонтали
		+ Настройки.ОтступМеждуФункциямиПоГоризонтали/2;
	КонецЕсли;
	
	НачалоПоВертикали = КоординатыГраницФункции.ЦентрПоВертикали - ОтступОтЦентраПоВертикали;
	НачалоПоВертикали = Цел(Цел(НачалоПоВертикали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	НачалоПоГоризонтали = КоординатыГраницФункции.ЦентрПоГоризонтали - ОтступОтЦентраПоГоризонтали;
	НачалоПоГоризонтали = Цел(Цел(НачалоПоГоризонтали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	ТекущаяВысота = НачалоПоВертикали;
	ТекущаяШирина = НачалоПоГоризонтали;
	
	Для Сч=1 По БлоковДляВывода Цикл
		
		Если ВидСвязи = "Вход" Тогда
			
			Лево = КоординатыГраницФункции.Левая - Настройки.ОтступОтГраницФункции - Настройки.ШиринаФункции;
			Право = Лево + Настройки.ШиринаФункции;
			
			Верх = ТекущаяВысота;
			Низ = Верх + Настройки.ВысотаФункции;
			
			ТекущаяВысота = Низ + Настройки.ОтступМеждуФункциямиПоВертикали;
			
		ИначеЕсли ВидСвязи = "Управление" Тогда
			
			Лево = ТекущаяШирина;
			Право = Лево + Настройки.ШиринаФункции;;
			
			Верх = КоординатыГраницФункции.Верхняя - Настройки.ОтступОтГраницФункции - Настройки.ВысотаФункции;
			Низ = Верх + Настройки.ВысотаФункции;
			
			ТекущаяШирина = Право + Настройки.ОтступМеждуФункциямиПоГоризонтали;
			
		ИначеЕсли ВидСвязи = "Исполнитель" Тогда
			
			Верх = КоординатыГраницФункции.Нижняя + Настройки.ОтступОтГраницФункции;
			Низ = Верх + Настройки.ВысотаФункции;
			
			Лево = ТекущаяШирина;
			Право = Лево + Настройки.ШиринаФункции;
			
			ТекущаяШирина = Право + Настройки.ОтступМеждуФункциямиПоГоризонтали;
			
		ИначеЕсли ВидСвязи = "Выход" Тогда
			
			Лево = КоординатыГраницФункции.Правая + Настройки.ОтступОтГраницФункции;
			Право = Лево + Настройки.ШиринаФункции;
			
			Верх = ТекущаяВысота;
			Низ = Верх + Настройки.ВысотаФункции;
			
			ТекущаяВысота = Низ + Настройки.ОтступМеждуФункциямиПоВертикали;
			
		КонецЕсли;
		
		ЦентрПоВертикали = (Низ - Верх)/2 + Верх;
		ЦентрПоВертикали = Цел(Цел(ЦентрПоВертикали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
		
		ЦентрПоГоризонтали = (Право - Лево)/2 + Лево;
		ЦентрПоГоризонтали = Цел(Цел(ЦентрПоГоризонтали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
		
		КоординатыБлока = Новый Структура;
		
		КоординатыБлока.Вставить("Левая", Лево);
		КоординатыБлока.Вставить("Правая", Право);
		КоординатыБлока.Вставить("Верхняя",Верх);
		КоординатыБлока.Вставить("Нижняя", Низ);
		КоординатыБлока.Вставить("ЦентрПоГоризонтали", ЦентрПоГоризонтали);
		КоординатыБлока.Вставить("ЦентрПоВертикали", ЦентрПоВертикали);
		
		Координаты.Добавить(КоординатыБлока);
		
	КонецЦикла;
	
	Возврат Координаты;
	
КонецФункции

Функция КоординатыБлоковИсполнителей(ДанныеОФункцияхиСвязях, ИнформацияОБлокахФункций, КоординатыГраницФункции, Настройки)
	
	Координаты = Новый Соответствие;
	
	Для Каждого ИнформацияОБлокеФункции из ИнформацияОБлокахФункций Цикл
		
		ДочерняяФункция = ИнформацияОБлокеФункции.Ключ;
		
		ИсполнителиДочерней = ИнформацияОБлокеФункции.Значение.Связи.Исполнители;
		КоличествоИсполнителей = ИсполнителиДочерней.Количество();
		
		КоординатыБлокаФункции = ИнформацияОБлокеФункции.Значение.Координаты;
		
		КоординатыБлокаСвязи = КоординатыБлокаИсполнителейДочернейФункции(КоординатыБлокаФункции,
		                           КоординатыГраницФункции, Настройки);
							   
		Координаты.Вставить(ДочерняяФункция, КоординатыБлокаСвязи);
		
	КонецЦикла;
	
	Возврат Координаты;
	
КонецФункции

Функция КоординатыБлокаИсполнителейДочернейФункции(КоординатыБлокаФункции, КоординатыГраницФункции, Настройки)
	
	Верх  = КоординатыГраницФункции.Нижняя + Настройки.ОтступОтГраницФункции;
	Низ = Верх + Настройки.ВысотаСвязи;
	
	Лево = КоординатыБлокаФункции.ЦентрПоГоризонтали - Настройки.ШиринаФункции/2;
	Лево = Цел(Цел(Лево/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	Право = Лево + Настройки.ШиринаФункции;
	
	ЦентрПоВертикали = (Низ - Верх)/2 + Верх;
	ЦентрПоВертикали = Цел(Цел(ЦентрПоВертикали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	ЦентрПоГоризонтали = (Право - Лево)/2 + Лево;
	ЦентрПоГоризонтали = Цел(Цел(ЦентрПоГоризонтали/Настройки.РазмерСетки)*Настройки.РазмерСетки);
	
	КоординатыБлока = Новый Структура;
	
	КоординатыБлока.Вставить("Левая", Лево);
	КоординатыБлока.Вставить("Правая", Право);
	КоординатыБлока.Вставить("Верхняя",Верх);
	КоординатыБлока.Вставить("Нижняя", Низ);
	КоординатыБлока.Вставить("ЦентрПоГоризонтали", ЦентрПоГоризонтали);
	КоординатыБлока.Вставить("ЦентрПоВертикали", ЦентрПоВертикали);
	
	Возврат КоординатыБлока;
	
КонецФункции

Процедура ДобавитьАгретагыСвязейДочернейФункции(ЭлементыСхемы, ДанныеСвязей, ИнформацияОФункции, ДанныеОФункцияхИСвязях, Счетчики, ГиперссылкиСвязей, Настройки);
	
	ВидСвязи = ДанныеСвязей.ВидСвязи;
	
	КоординатыБлоковСвязей = ДанныеОФункцияхИСвязях.КоординатыБлоковСвязей[ВидСвязи];
	
	ИнформацияОБлоке = ИнформацияОФункции.ИнформацияОБлоке;
	ДочерняяФункция = ИнформацияОФункции.Ссылка;
	
	СтруктураСвязей = ИнформацияОБлоке.Связи;
	ЭлементБлокаФункции = ИнформацияОБлоке.Элемент;
	
	КоличествоДочерних = ДанныеОФункцияхИСвязях.ДочерниеФункции.Количество();
	ОбщееКоличествоАгрегатовСвязей = ДанныеОФункцияхИСвязях.ДанныеОКоличествеАгрегатовСвязей[ВидСвязи];
	
	МожноВывестиБлоков = 0;
	
	Если ВидСвязи = "Вход" Тогда
		СвязиДочерней = СтруктураСвязей["ВходыСАгрегатами"];
		КоличествоВыводимыхБлоков = Мин(Настройки.МаксимумБлоковПоВертикали, ОбщееКоличествоАгрегатовСвязей);
		МожноВывестиБлоков = КоличествоВыводимыхБлоков - Счетчики.ВыведеноБлоковАгрегатовВходов;
	ИначеЕсли ВидСвязи = "Управление" Тогда
		СвязиДочерней = СтруктураСвязей["УправлениеСАгрегатами"];
		КоличествоВыводимыхБлоков = Мин(Настройки.МаксимумБлоковПоГоризонтали, ОбщееКоличествоАгрегатовСвязей);
		МожноВывестиБлоков = КоличествоВыводимыхБлоков - Счетчики.ВыведеноБлоковАгрегатовУправления;
	ИначеЕсли ВидСвязи = "Выход" Тогда
		СвязиДочерней = СтруктураСвязей["ПотребителиСАгрегатами"];
		КоличествоВыводимыхБлоков = Мин(Настройки.МаксимумБлоковПоВертикали, ОбщееКоличествоАгрегатовСвязей);
		МожноВывестиБлоков = КоличествоВыводимыхБлоков - Счетчики.ВыведеноБлоковАгрегатовПотребителей;
	КонецЕсли;
	
	КоличествоСвязей = СвязиДочерней.Количество();
	
	Сч = 1;
	
	Для Каждого СвойстваСвязи из СвязиДочерней Цикл
		
		СвойстваТекущейСвязи = СвойстваСвязи;
		
		ЗаполнитьСвязиИСсылки(ДанныеОФункцияхИСвязях.СвязиИСсылки, СвойстваТекущейСвязи.Ссылка, ДочерняяФункция,
		                      СвойстваТекущейСвязи.Связи, ВидСвязи);
							  
		СвязьВыводилась = (ДанныеОФункцияхИСвязях.ВыведенныеСвязи[ВидСвязи].Найти(СвойстваТекущейСвязи.Ссылка)<>Неопределено);
		
		ДанныеГиперссылок = СвойстваТекущейСвязи.Ссылка;
		ДобавлятьГиперссылки = ЗначениеЗаполнено(СвойстваТекущейСвязи.Ссылка);
		
		// Если возможно вывести лишь один блок, но еще не перебраны все связи,
		// или не перебраны все дочерние функции, то вывод не осуществляется
		
		БлокВыводится = Ложь;
		БлокВключаетМножественныеСсылки = Ложь;
		КоличествоСкрытыхСвязей = 0;
		
		Если МожноВывестиБлоков = 1 Тогда
			Если КоличествоСвязей = Сч И Счетчики.ОбработаноДочернихФункций = КоличествоДочерних-1 Тогда
				
				БлокВыводится = Истина;
				
				Если ДанныеОФункцияхИСвязях.СвойстваСвязиДляВывода[ВидСвязи] <> Неопределено Тогда
					СвойстваТекущейСвязи = ДанныеОФункцияхИСвязях.СвойстваСвязиДляВывода[ВидСвязи];
				КонецЕсли;
				
				Если ОбщееКоличествоАгрегатовСвязей > КоличествоВыводимыхБлоков Тогда
					// Если количество агрегатов оказывается больше, чем количество выводимых блоков,
					// то агрегаты, которые не помещаются, отражаются в последнем блоке как "+ еще..."
					БлокВключаетМножественныеСсылки = Истина;
					КоличествоСкрытыхСвязей = ОбщееКоличествоАгрегатовСвязей - КоличествоВыводимыхБлоков;
				КонецЕсли;
			Иначе
				// Если блок для вывода- последний и связь ранее не выводилась (не является дублем),
				// она сохраняется для вывода далее
				Если Не СвязьВыводилась Тогда
					Если ДанныеОФункцияхИСвязях.СвойстваСвязиДляВывода[ВидСвязи] = Неопределено Тогда
						ДанныеОФункцияхИСвязях.СвойстваСвязиДляВывода.Вставить(ВидСвязи ,СвойстваТекущейСвязи);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		Иначе
			// Если текущая связь еще не выводилась, то она выводится,
			// в противном случае - блок не выводится и связи перебираются далее
			Если Не СвязьВыводилась Тогда
				БлокВыводится = Истина;
			КонецЕсли;
		КонецЕсли;
				
		Если БлокВыводится Тогда
			
			Если ВидСвязи = "Вход" Тогда
				ВыведеноБлоковДляВидаСвязи = Счетчики.ВыведеноБлоковАгрегатовВходов;
			ИначеЕсли ВидСвязи = "Управление" Тогда
				ВыведеноБлоковДляВидаСвязи = Счетчики.ВыведеноБлоковАгрегатовУправления;
			ИначеЕсли ВидСвязи = "Выход" Тогда
				ВыведеноБлоковДляВидаСвязи = Счетчики.ВыведеноБлоковАгрегатовПотребителей;
			КонецЕсли;
	
			ПараметрыВыводаБлока = Новый Структура;
			ПараметрыВыводаБлока.Вставить("КоординатыБлокаСвязи", КоординатыБлоковСвязей[ВыведеноБлоковДляВидаСвязи]);
			ПараметрыВыводаБлока.Вставить("ВключаетМножественныеСсылки", БлокВключаетМножественныеСсылки);
			ПараметрыВыводаБлока.Вставить("КоличествоСкрытыхСвязей", КоличествоСкрытыхСвязей);
			ПараметрыВыводаБлока.Вставить("СвязиИСсылки", ДанныеОФункцияхИСвязях.СвязиИСсылки);
			ПараметрыВыводаБлока.Вставить("ВыведенныеСвязи", ДанныеОФункцияхИСвязях.ВыведенныеСвязи[ВидСвязи]);
			
			ВывестиБлокАгрегатаСвязи(ЭлементыСхемы, ДанныеСвязей, ИнформацияОФункции, Счетчики,
			                         ГиперссылкиСвязей, СвойстваТекущейСвязи, ПараметрыВыводаБлока);
			
			Если ВидСвязи = "Вход" Тогда
				Счетчики.ВыведеноБлоковАгрегатовВходов = Счетчики.ВыведеноБлоковАгрегатовВходов + 1;
			ИначеЕсли ВидСвязи = "Управление" Тогда
				Счетчики.ВыведеноБлоковАгрегатовУправления = Счетчики.ВыведеноБлоковАгрегатовУправления + 1;
			ИначеЕсли ВидСвязи = "Выход" Тогда
				Счетчики.ВыведеноБлоковАгрегатовПотребителей = Счетчики.ВыведеноБлоковАгрегатовПотребителей + 1;
			КонецЕсли;
			
			ДанныеОФункцияхИСвязях.ВыведенныеСвязи[ВидСвязи].Добавить(СвойстваТекущейСвязи.Ссылка);
			
			МожноВывестиБлоков = МожноВывестиБлоков -1;
			
		КонецЕсли;
	
		Сч = Сч+1;
		
	КонецЦикла;
	
	// Если обработаны все функции, но блок не был выведен (в последней функции,
	// например, не было связей, а ранее связи были подготовлены для вывода),
	// то выполняется вывод блока, если есть связь для вывода.
	
	Если МожноВывестиБлоков > 0 Тогда
		Если Счетчики.ОбработаноДочернихФункций = КоличествоДочерних-1 Тогда
			СвойстваСвязиДляВывода = ДанныеОФункцияхИСвязях.СвойстваСвязиДляВывода[ВидСвязи];
			Если СвойстваСвязиДляВывода <> Неопределено Тогда
				
				Если ОбщееКоличествоАгрегатовСвязей > КоличествоВыводимыхБлоков Тогда
					БлокВключаетМножественныеСсылки = Истина;
					КоличествоСкрытыхСвязей = ОбщееКоличествоАгрегатовСвязей - КоличествоВыводимыхБлоков;
				Иначе
					БлокВключаетМножественныеСсылки = Ложь;
					КоличествоСкрытыхСвязей=0;
				КонецЕсли;
				
				ИндексБлока = КоординатыБлоковСвязей.Количество()-1;
				
				ПараметрыВыводаБлока = Новый Структура;
				ПараметрыВыводаБлока.Вставить("КоординатыБлокаСвязи", КоординатыБлоковСвязей[ИндексБлока]);
				ПараметрыВыводаБлока.Вставить("ВключаетМножественныеСсылки", БлокВключаетМножественныеСсылки);
				ПараметрыВыводаБлока.Вставить("КоличествоСкрытыхСвязей", КоличествоСкрытыхСвязей);
				ПараметрыВыводаБлока.Вставить("СвязиИСсылки", ДанныеОФункцияхИСвязях.СвязиИСсылки);
				ПараметрыВыводаБлока.Вставить("ВыведенныеСвязи", ДанныеОФункцияхИСвязях.ВыведенныеСвязи[ВидСвязи]);
				
				ВывестиБлокАгрегатаСвязи(ЭлементыСхемы, ДанныеСвязей, ИнформацияОФункции, Счетчики,
			                             ГиперссылкиСвязей, СвойстваСвязиДляВывода, ПараметрыВыводаБлока);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьИсполнителейДочернейФункции(ЭлементыСхемы, ДанныеСвязей, ИнформацияОФункции, ДанныеОФункцияхИСвязях, Счетчики, ГиперссылкиСвязей, Настройки);

	ИнформацияОБлоке = ИнформацияОФункции.ИнформацияОБлоке;
	
	Исполнители = ИнформацияОБлоке.Связи.Исполнители;
	КоличествоИсполнителей = Исполнители.Количество();
	
	Если КоличествоИсполнителей =0 Тогда
		Возврат;
	КонецЕсли;
	
	ВидСвязи = ДанныеСвязей.ВидСвязи;
	ДочерняяФункция = ИнформацияОФункции.Ссылка;
	
	КоординатыБлоковИсполнителей = ДанныеОФункцияхИСвязях.КоординатыБлоковСвязей[ВидСвязи];
	КоординатыБлокаИсполнителей = КоординатыБлоковИсполнителей.Получить(ДочерняяФункция);
	
	СтруктураСвязей = ИнформацияОБлоке.Связи;
	ЭлементБлокаФункции = ИнформацияОБлоке.Элемент;
	
	БлокВключаетМножественныеСсылки = (КоличествоИсполнителей > 1);
	КоличествоСкрытыхСвязей = ?(БлокВключаетМножественныеСсылки, КоличествоИсполнителей, 0);
	
	СвойстваСвязи = Исполнители[0];
	ДанныеГиперссылок = СвойстваСвязи.Ссылка;
	
	ПараметрыВыводаБлока = Новый Структура;
	ПараметрыВыводаБлока.Вставить("КоординатыБлокаСвязи", КоординатыБлокаИсполнителей);
	ПараметрыВыводаБлока.Вставить("ВключаетМножественныеСсылки", БлокВключаетМножественныеСсылки);
	ПараметрыВыводаБлока.Вставить("КоличествоСкрытыхСвязей", КоличествоСкрытыхСвязей);
	ПараметрыВыводаБлока.Вставить("Связи", Исполнители);
	
	ВывестиБлокИсполнителя(ЭлементыСхемы, ДанныеСвязей, ИнформацияОФункции, Счетчики,
	                       ГиперссылкиСвязей, СвойстваСвязи, ПараметрыВыводаБлока);
	
КонецПроцедуры

Процедура ВывестиБлокИсполнителя(ЭлементыСхемы, ДанныеСвязей, ИнформацияОФункции, Счетчики, ГиперссылкиСвязей, СвойстваСвязи, ПараметрыВывода)
	
	Макет = ДанныеСвязей.Макет;
	ВидСвязи = ДанныеСвязей.ВидСвязи;
	
	КоординатыГраницФункции = ИнформацияОФункции.КоординатыГраницФункции;
	
	ДобавляемыеЭлементы = СписокЭлементовМакета(Макет);
	
	ЭлементБлокаФункции = ИнформацияОФункции.ИнформацияОБлоке.Элемент;
	
	ИнформацияОСвязях = Новый Структура;
	ИнформацияОСвязях.Вставить("ВидСвязи", ВидСвязи);
	ИнформацияОСвязях.Вставить("СвойстваСвязей", ПараметрыВывода.Связи);
	
	ДобавлятьГиперссылки = ЗначениеЗаполнено(СвойстваСвязи.Ссылка);
	
	ЗаголовокБлока = СвойстваСвязи.Наименование;
	
	Если ПараметрыВывода.ВключаетМножественныеСсылки Тогда
		
		КоличествоВсего = ПараметрыВывода.КоличествоСкрытыхСвязей;
		
		ЗаголовокБлока = НСтр("ru='Исполнителей: %ВсегоИсполниетелей%'");
		ЗаголовокБлока = СтрЗаменить(ЗаголовокБлока, "%ВсегоИсполниетелей%", Строка(КоличествоВсего));
		
	КонецЕсли;
	
	ЭлементыСвязи = ДобавитьБлокСвязиДочернейФункции(ЭлементыСхемы, ДобавляемыеЭлементы, ЗаголовокБлока,
	                    ИнформацияОСвязях, Счетчики, ЭлементБлокаФункции, ДобавлятьГиперссылки);
	
	КоординатыБлокаСвязи = ПараметрыВывода.КоординатыБлокаСвязи;;
	
	Если ЭлементыСвязи.Блок <> Неопределено Тогда
		
		УстановитьКоординатыБлока(ЭлементыСвязи.Блок, КоординатыБлокаСвязи);
		
		Если ДобавлятьГиперссылки Тогда
			// Если блок включает множественные ссылки, то в данные гиперссылок помещаются
			// ссылки как по выводимому агрегату, так и по тем, которые не выведены.
			// В противном случае- помещаются ссылки только по выводимому агрегату
			Если ПараметрыВывода.ВключаетМножественныеСсылки Тогда
				ДанныеГиперссылок = Новый Массив;
				Для Каждого СвойстваСвязи из ПараметрыВывода.Связи Цикл
					ДанныеГиперссылок.Добавить(СвойстваСвязи.Ссылка);
				КонецЦИкла;
			Иначе
				ДанныеГиперссылок = СвойстваСвязи.Ссылка;
			КонецЕсли;
			
			ГиперссылкиСвязей.Вставить(ЭлементыСвязи.Блок.ItemCode, ДанныеГиперссылок);
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ВывестиБлокАгрегатаСвязи(ЭлементыСхемы, ДанныеСвязей, ИнформацияОФункции, Счетчики, ГиперссылкиСвязей, СвойстваСвязи, ПараметрыВывода)
	
	Макет = ДанныеСвязей.Макет;
	ВидСвязи = ДанныеСвязей.ВидСвязи;
	
	КоординатыГраницФункции = ИнформацияОФункции.КоординатыГраницФункции;
	
	ДобавляемыеЭлементы = СписокЭлементовМакета(Макет);
	
	ЭлементБлокаФункции = ИнформацияОФункции.ИнформацияОБлоке.Элемент;
	
	СвойстваСвязей = Новый Массив;
	СвойстваСвязей.Добавить(СвойстваСвязи);
	
	ИнформацияОСвязях = Новый Структура;
	ИнформацияОСвязях.Вставить("ВидСвязи", ВидСвязи);
	ИнформацияОСвязях.Вставить("СвойстваСвязей", СвойстваСвязей);
	
	ДобавлятьГиперссылки = ЗначениеЗаполнено(СвойстваСвязи.Ссылка);
	
	ЗаголовокБлока = СвойстваСвязи.Наименование;
	
	Если ПараметрыВывода.ВключаетМножественныеСсылки Тогда
		
		КоличествоЕще = ПараметрыВывода.КоличествоСкрытыхСвязей;
		
		СтрокаДополненияЗаголовка = НСтр("ru='(+ еще %Блоков%)'");
		СтрокаДополненияЗаголовка = СтрЗаменить(СтрокаДополненияЗаголовка, "%Блоков%", Строка(КоличествоЕще));
		ЗаголовокБлока = ЗаголовокБлока + " " + СтрокаДополненияЗаголовка;
		
	КонецЕсли;
	
	ЭлементыСвязи = ДобавитьБлокСвязиДочернейФункции(ЭлементыСхемы, ДобавляемыеЭлементы, ЗаголовокБлока,
	                    ИнформацияОСвязях, Счетчики, ЭлементБлокаФункции, ДобавлятьГиперссылки);
	
	КоординатыБлокаСвязи = ПараметрыВывода.КоординатыБлокаСвязи;;
	
	Если ЭлементыСвязи.Блок <> Неопределено Тогда
		
		УстановитьКоординатыБлока(ЭлементыСвязи.Блок, КоординатыБлокаСвязи);
		
		Если Не ПараметрыВывода.ВключаетМножественныеСсылки Тогда
			Если СвойстваСвязи.ТипФункции = Перечисления.ТипыФункций.УчетныйМеханизм Тогда
				УстановитьОтображениеУчетногоМеханизма(ЭлементыСвязи.Блок);
			ИначеЕсли СвойстваСвязи.ТипФункции = Перечисления.ТипыФункций.Отчет Тогда
				УстановитьОтображениеОтчета(ЭлементыСвязи.Блок);
			КонецЕсли;
		КонецЕсли;
		
		Если ДобавлятьГиперссылки Тогда
			// Если блок включает множественные ссылки, то в данные гиперссылок помещаются
			// ссылки как по выводимому агрегату, так и по тем, которые не выведены.
			// В противном случае- помещаются ссылки только по выводимому агрегату
			Если ПараметрыВывода.ВключаетМножественныеСсылки Тогда
				ДанныеГиперссылок = Новый Массив;
				Для Каждого ДанныеПоАгрегату из ПараметрыВывода.СвязиИСсылки[ВидСвязи] Цикл
					Если ПараметрыВывода.ВыведенныеСвязи.Найти(ДанныеПоАгрегату.Ключ) = Неопределено Тогда
						ДанныеГиперссылок.Добавить(ДанныеПоАгрегату.Ключ);
					КонецЕсли;
				КонецЦИкла;
			Иначе
				ДанныеГиперссылок = СвойстваСвязи.Ссылка;
			КонецЕсли;
			
			ГиперссылкиСвязей.Вставить(ЭлементыСвязи.Блок.ItemCode, ДанныеГиперссылок);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если ЭлементыСвязи.Линия <> Неопределено Тогда
		УстановитьКоординатыЛинииСвязиНеконечнойФункции(ЭлементыСвязи.Линия, КоординатыБлокаСвязи,
		                                                КоординатыГраницФункции, ВидСвязи);
		
		УстановитьПорядокЛинииСвязи(ЭлементыСвязи.Линия);
		
		Если ДобавлятьГиперссылки Тогда
			
			Если ПараметрыВывода.ВключаетМножественныеСсылки Тогда
				ДанныеГиперссылок = Новый Соответствие;
				Для Каждого ДанныеПоАгрегату из ПараметрыВывода.СвязиИСсылки[ВидСвязи] Цикл
					Если ПараметрыВывода.ВыведенныеСвязи.Найти(ДанныеПоАгрегату.Ключ) = Неопределено Тогда
						ДанныеГиперссылок.Вставить(ДанныеПоАгрегату.Ключ, ДанныеПоАгрегату.Значение);
					КонецЕсли;
				КонецЦИкла;
			Иначе
				ДанныеГиперссылок = ПараметрыВывода.СвязиИСсылки[ВидСвязи].Получить(СвойстваСвязи.Ссылка);
			КонецЕсли;
			
			ГиперссылкиСвязей.Вставить(ЭлементыСвязи.Линия.ItemCode, ДанныеГиперссылок);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаполнитьСвязиИСсылки(СвязиИСсылки, АгрегатнаяФункция, ДочерняяФункция, СвязиАгрегата, ВидСвязи)
	
	ДанныеСсылокПоАгрегату = СвязиИСсылки[ВидСвязи].Получить(АгрегатнаяФункция);
	
	Если ДанныеСсылокПоАгрегату = Неопределено Тогда
		ДанныеСсылокПоАгрегату = Новый Соответствие;
	КонецЕсли;
	
	ДанныеСсылокПоАгрегату.Вставить(ДочерняяФункция, СвязиАгрегата);
	
	СвязиИСсылки[ВидСвязи].Вставить(АгрегатнаяФункция, ДанныеСсылокПоАгрегату);
	
КонецПроцедуры

// Координаты стыковочного блока - координаты блока функции, или границ функции, в зависимости от того,
// с чем стыкуется линия - с границей функции, или с блоком дочерней функции.
//
Процедура УстановитьКоординатыЛинииСвязиНеконечнойФункции(Линия, КоординатыБлокаСвязи, КоординатыСтыковочногоБлока, ВидСвязи)
	
	СписокТочек = Линия.Point;
	КоличествоТочек = СписокТочек.Количество();
	
	Если КоличествоТочек<2 Тогда
		Возврат;
	КонецЕсли;
	
	// Удаление лишних точек
	Если КоличествоТочек>2 Тогда
		Для Сч=1 По КоличествоТочек-2 Цикл
			СписокТочек.Удалить(Сч);
		КонецЦикла;
	КонецЕсли;
	
	Если ВидСвязи = "Исполнитель" Тогда
		ТочкаНачала = СписокТочек[СписокТочек.Количество()-1];
		ТочкаОкончания = СписокТочек[0];
	Иначе
		ТочкаНачала = СписокТочек[0];
		ТочкаОкончания = СписокТочек[СписокТочек.Количество()-1];
	КонецЕсли;
	
	X1=0;
	Y1=0;
	X2=0;
	Y2=0;
	
	Если ВидСВязи = "Вход" Тогда
		
		X1 = КоординатыБлокаСвязи.Правая;
		Y1 = КоординатыБлокаСвязи.ЦентрПоВертикали;
		X2 = КоординатыСтыковочногоБлока.Левая;
		Y2 = КоординатыБлокаСвязи.ЦентрПоВертикали;
		
	ИначеЕсли ВидСвязи = "Выход" Тогда
		
		X1 = КоординатыСтыковочногоБлока.Правая;
		Y1 = КоординатыБлокаСвязи.ЦентрПоВертикали;
		X2 = КоординатыБлокаСвязи.Левая;
		Y2 = КоординатыБлокаСвязи.ЦентрПоВертикали;
		
	ИначеЕсли ВидСвязи = "Управление" Тогда
		
	    X1 = КоординатыБлокаСвязи.ЦентрПоГоризонтали;
		Y1 = КоординатыБлокаСвязи.Нижняя;
		X2 = КоординатыБлокаСвязи.ЦентрПоГоризонтали;
		Y2 = КоординатыСтыковочногоБлока.Верхняя;
		
	ИначеЕсли ВидСвязи = "Исполнитель" Тогда
		
		X1 = КоординатыБлокаСвязи.ЦентрПоГоризонтали;
		Y1 = КоординатыСтыковочногоБлока.Нижняя;
		X2 = КоординатыБлокаСвязи.ЦентрПоГоризонтали;
		Y2 = КоординатыБлокаСвязи.Верхняя;
		
	КонецЕсли;
	
	ТочкаНачала.X = X1;
	ТочкаНачала.Y = Y1;
	
	ТочкаОкончания.X = X2;
	ТочкаОкончания.Y = Y2;
	
КонецПроцедуры

Процедура ДобавитьВнутренниеСвязи(ЭлементыСхемы, МакетыЛиний, ИнформацияОФункции, ИнформацияОБлокахФункций, Счетчики, Настройки)
	
	ИнформацияОБлоке = ИнформацияОФункции.ИнформацияОБлоке;
	
	СтруктураСвязей = ИнформацияОБлоке.Связи;
	
	ЭлементБлокаФункции = ИнформацияОБлоке.Элемент;
	
	ВнутренниеВходы = СтруктураСвязей["ВнутренниеВходы"];
	ВнутреннееУправление = СтруктураСвязей["ВнутреннееУправление"];
	
	// Внутренние входы
	Для Каждого ЭлементСоответствия из ВнутренниеВходы Цикл
		
		СтруктураИнформации = ЭлементСоответствия.Значение;
		СвойстваСвязи = СтруктураИнформации.СвойстваСвязи;
		Выход = СтруктураИнформации.Выход;
		
		Если ЗначениеЗаполнено(Выход) Тогда
			
			ИнформацияОВыходе = ИнформацияОБлокахФункций.Получить(Выход);
			
			Если ИнформацияОВыходе <> Неопределено Тогда
				
				ИнформацияОСвязи = Новый Структура;
				ИнформацияОСвязи.Вставить("ВидСвязи", "Вход");
				ИнформацияОСвязи.Вставить("СвойстваСвязи", СвойстваСвязи);
				
				ДобавитьЛиниюВнутреннейСвязи(ЭлементыСхемы, МакетыЛиний.Вход, ИнформацияОБлоке,
				                             ИнформацияОВыходе, ИнформацияОСвязи, Счетчики, Настройки);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Внутреннее управление
	Для Каждого ЭлементСоответствия из ВнутреннееУправление Цикл
		
		СтруктураИнформации = ЭлементСоответствия.Значение;
		СвойстваСвязи = СтруктураИнформации.СвойстваСвязи;
		Выход = СтруктураИнформации.Выход;
		
		Если ЗначениеЗаполнено(Выход) Тогда
			
			ИнформацияОВыходе = ИнформацияОБлокахФункций.Получить(Выход);
			
			Если ИнформацияОВыходе <> Неопределено Тогда
				
				ИнформацияОСвязи = Новый Структура;
				ИнформацияОСвязи.Вставить("ВидСвязи", "Управление");
				ИнформацияОСвязи.Вставить("СвойстваСвязи", СвойстваСвязи);
				
				ДобавитьЛиниюВнутреннейСвязи(ЭлементыСхемы, МакетыЛиний.Управление, ИнформацияОБлоке,
				                             ИнформацияОВыходе, ИнформацияОСвязи, Счетчики, Настройки);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьЛиниюВнутреннейСвязи(ЭлементыСхемы, Макет, СтруктураДанныхОБлоке, ИнформацияОВыходе, ИнформацияОСвязи, Счетчики, Настройки)
	
	ВидСвязи = ИнформацияоСвязи.ВидСвязи;
	СвойстваСвязи = ИнформацияоСвязи.СвойстваСвязи;
	
	ДобавляемыеЭлементы = СписокЭлементовМакета(Макет);
	ДобавленныйЭлемент = Неопределено;
	
	Для Каждого ЭлементСхемы из ДобавляемыеЭлементы Цикл
		ДобавленныйЭлемент = ЭлементыСхемы.Добавить(ЭлементСхемы);
	КонецЦикла;
	
	Если ДобавленныйЭлемент <> Неопределено Тогда
		УстановитьСвойстваЛинииВнутреннейСвязи(ДобавленныйЭлемент, СтруктураДанныхОБлоке, ИнформацияОВыходе,
		                                       ВидСвязи, СвойстваСвязи, Счетчики, Настройки);
											   
		УстановитьПорядокЛинииСвязи(ДобавленныйЭлемент);
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьСвойстваЛинииВнутреннейСвязи(Линия, СтруктураДанныхОБлоке, ИнформацияОВыходе, ВидСвязи, СвойстваСвязи, Счетчики, Настройки)
	
	УстановитьСвойстваСвязиФункции(Линия, "", ВидСвязи, Счетчики);
	
	ЭлементБлокаФункции = СтруктураДанныхОБлоке.Элемент;
	ЭлементБлокаВыхода = ИнформацияОВыходе.Элемент;
	
	Линия.ConnectFromItemID = ЭлементБлокаВыхода.ItemID;
	Линия.ConnectToItemID = ЭлементБлокаФункции.ItemID;
	
	//Установка привязки линии к блоку функции
	Если ВидСвязи = "Вход" Тогда
		Линия.PortIndexTo = 1;
	ИначеЕсли ВидСвязи = "Управление" Тогда
		Линия.PortIndexTo = 2;
	КонецЕсли;
	
	Линия.PortIndexFrom = 3;
	
	УстановитьПодсказкуЛинии(Линия, СвойстваСвязи.Результат);
	
	УстановитьКоординатыЛинииВнутреннейСвязи(Линия, СтруктураДанныхОБлоке.Координаты,
	                                         ИнформацияОВыходе.Координаты, ВидСвязи, Настройки);
											 
КонецПроцедуры

Процедура УстановитьКоординатыЛинииВнутреннейСвязи(Линия, КоординатыБлокаВхода, КоординатыБлокаВыхода, ВидСвязи, Настройки)
	
	СписокТочек = Линия.Point;
	КоличествоТочек = СписокТочек.Количество();
	
	Если КоличествоТочек<2 Тогда
		Возврат;
	КонецЕсли;
	
	Если КоординатыБлокаВхода.Левая > КоординатыБлокаВыхода.Левая Тогда
		ПрямаяСвязь = Истина;
		Если ВидСвязи = "Вход" Тогда
			ВсегоТочек = 4;
		Иначе
			ВсегоТочек = 3;
		КонецЕсли;
	Иначе
		ПрямаяСвязь = Ложь;
		Если ВидСвязи = "Вход" Тогда
			ВсегоТочек = 6;
		Иначе
			ВсегоТочек = 5;
		КонецЕсли;
	КонецЕсли;
	
	// Удаление лишних точек
	Если КоличествоТочек>ВсегоТочек Тогда
		
		Сч = КоличествоТочек;
		Пока Сч>ВсегоТочек Цикл
			СписокТочек.Удалить(Сч-1);
			Сч = Сч-1;
		КонецЦикла;
		
	КонецЕсли;
	
	// Установка координато точек начала и окончания
	ТочкаНачала = СписокТочек[0];
	ТочкаОкончания = СписокТочек[СписокТочек.Количество()-1];
	
	X1=0;
	Y1=0;
	X2=0;
	Y2=0;
	
	Если ВидСВязи = "Вход" Тогда
		
		X1 = КоординатыБлокаВыхода.Правая;
		Y1 = КоординатыБлокаВыхода.ЦентрПоВертикали;
		X2 = КоординатыБлокаВхода.Левая;
		Y2 = КоординатыБлокаВхода.ЦентрПоВертикали;
		
	ИначеЕсли ВидСвязи = "Управление" Тогда
		
	    X1 = КоординатыБлокаВыхода.Правая;
		Y1 = КоординатыБлокаВыхода.ЦентрПоВертикали;
		X2 = КоординатыБлокаВхода.ЦентрПоГоризонтали;
		Y2 = КоординатыБлокаВхода.Верхняя;
		
	КонецЕсли;
	
	ТочкаНачала.X = X1;
	ТочкаНачала.Y = Y1;
	
	ТочкаОкончания.X = X2;
	ТочкаОкончания.Y = Y2;
	
	УстановитьТочкиПерегибаЛинииВнутреннейСвязи(СписокТочек, КоординатыБлокаВхода, КоординатыБлокаВыхода,
	                                  ВидСвязи, ПрямаяСвязь, Настройки);
	
КонецПроцедуры

Процедура УстановитьКоординатыЛинииСвязиСАгрегатом(Линия, ВидСвязи, КоординатыБлокаИсточника, КоординатыБлокаПриемника, Настройки)
	
	СписокТочек = Линия.Point;
	КоличествоТочек = СписокТочек.Количество();
	
	Если КоличествоТочек<2 Тогда
		Возврат;
	КонецЕсли;
	
	ПрямаяСвязь = Истина;
	ВсегоТочек = 4;
	
	// Удаление лишних точек
	Если КоличествоТочек>ВсегоТочек Тогда
		
		Сч = КоличествоТочек;
		Пока Сч>ВсегоТочек Цикл
			СписокТочек.Удалить(Сч-1);
			Сч = Сч-1;
		КонецЦикла;
		
	КонецЕсли;
	
	// Установка координато точек начала и окончания
	ТочкаНачала = СписокТочек[0];
	ТочкаОкончания = СписокТочек[СписокТочек.Количество()-1];
	
	X1=0;
	Y1=0;
	X2=0;
	Y2=0;
	
	Если ВидСвязи = "Вход" ИЛИ ВидСвязи = "Выход" Тогда
		X1 = КоординатыБлокаИсточника.Правая;
		Y1 = КоординатыБлокаИсточника.ЦентрПоВертикали;
		X2 = КоординатыБлокаПриемника.Левая;
		Y2 = КоординатыБлокаПриемника.ЦентрПоВертикали;
	Иначе // Управление
		X1 = КоординатыБлокаИсточника.ЦентрПоГоризонтали;
		Y1 = КоординатыБлокаИсточника.Нижняя;
		X2 = КоординатыБлокаПриемника.ЦентрПоГоризонтали;
		Y2 = КоординатыБлокаПриемника.Верхняя;
	КонецЕсли;
	
	ТочкаНачала.X = X1;
	ТочкаНачала.Y = Y1;
	
	ТочкаОкончания.X = X2;
	ТочкаОкончания.Y = Y2;
	
	УстановитьТочкиПерегибаЛинииСвязиСАгрегатом(СписокТочек, КоординатыБлокаИсточника, КоординатыБлокаПриемника,
	                                            ВидСвязи, Настройки);
	
КонецПроцедуры

Процедура УстановитьТочкиПерегибаЛинииВнутреннейСвязи(СписокТочек, КоординатыБлокаВхода, КоординатыБлокаВыхода, ВидСвязи, ПрямаяСвязь, Настройки)
	
	Если ПрямаяСвязь Тогда
		
		Если ВидСвязи = "Вход" Тогда
			
			Точка2 = СписокТочек[1];
			Точка2.x = КоординатыБлокаВыхода.Правая + Настройки.РазмерСетки;
			Точка2.y = КоординатыБлокаВыхода.ЦентрПоВертикали;
			
			Точка3 = СписокТочек[2];
			Точка3.x = КоординатыБлокаВыхода.Правая + Настройки.РазмерСетки;
			Точка3.y = КоординатыБлокаВхода.ЦентрПоВертикали;
			
		Иначе
			
			Точка2 = СписокТочек[1];
			Точка2.x = КоординатыБлокаВхода.ЦентрПоГоризонтали;
			Точка2.y = КоординатыБлокаВыхода.ЦентрПоВертикали;
			
		КонецЕсли;
		
	Иначе
		
		Если ВидСвязи = "Вход" Тогда
			
			Точка2 = СписокТочек[1];
			Точка2.x = КоординатыБлокаВыхода.Правая + Настройки.РазмерСетки;
			Точка2.y = КоординатыБлокаВыхода.ЦентрПоВертикали;
			
			Точка3 = СписокТочек[2];
			Точка3.x = КоординатыБлокаВыхода.Правая + Настройки.РазмерСетки;
			Точка3.y = КоординатыБлокаВыхода.Нижняя + Настройки.РазмерСетки;
			
			Точка4 = СписокТочек[3];
			Точка4.x = КоординатыБлокаВхода.Левая - Настройки.РазмерСетки;
			Точка4.y = КоординатыБлокаВхода.Нижняя + Настройки.РазмерСетки;
			
			Точка5 = СписокТочек[4];
			Точка5.x = КоординатыБлокаВхода.Левая - Настройки.РазмерСетки;
			Точка5.y = КоординатыБлокаВхода.ЦентрПоВертикали;
			
		Иначе
			
			Точка2 = СписокТочек[1];
			Точка2.x = КоординатыБлокаВыхода.Правая + Настройки.РазмерСетки;
			Точка2.y = КоординатыБлокаВыхода.ЦентрПоВертикали;
			
			Точка3 = СписокТочек[2];
			Точка3.x = КоординатыБлокаВыхода.Правая + Настройки.РазмерСетки;
			Точка3.y = КоординатыБлокаВхода.Верхняя - Настройки.РазмерСетки;
			
			Точка4 = СписокТочек[3];
			Точка4.x = КоординатыБлокаВхода.ЦентрПоГоризонтали;
			Точка4.y = КоординатыБлокаВхода.Верхняя - Настройки.РазмерСетки;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьТочкиПерегибаЛинииСвязиСАгрегатом(СписокТочек, КоординатыБлокаИсточника, КоординатыБлокаПриемника, ВидСвязи, Настройки)
	
	Если ВидСвязи = "Вход" ИЛИ ВидСвязи = "Выход" Тогда
		
		Точка2 = СписокТочек[1];
		Точка2.x = КоординатыБлокаИсточника.Правая + Настройки.РазмерСетки;
		Точка2.y = КоординатыБлокаИсточника.ЦентрПоВертикали;
		
		Точка3 = СписокТочек[2];
		Точка3.x = КоординатыБлокаИсточника.Правая + Настройки.РазмерСетки;
		Точка3.y = КоординатыБлокаПриемника.ЦентрПоВертикали;
		
	ИначеЕсли ВидСвязи = "Управление" Тогда
		
		Точка2 = СписокТочек[1];
		Точка2.x = КоординатыБлокаИсточника.ЦентрПоГоризонтали;
		Точка2.y = КоординатыБлокаИсточника.Нижняя + Настройки.РазмерСетки;
		
		Точка3 = СписокТочек[2];
		Точка3.x = КоординатыБлокаПриемника.ЦентрПоГоризонтали;
		Точка3.y = КоординатыБлокаИсточника.Нижняя + Настройки.РазмерСетки;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьПодсказкуЛинии(Линия, ТекстПодсказки)
	
	СписокЭлементовTipText = Линия.TipText.ПолучитьСписок("item");
	
	Если СписокЭлементовTipText.Количество()>0 Тогда
		ЭлементСписка = СписокЭлементовTipText[0];
		ЭлементСписка.Content = ТекстПодсказки;
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьПорядокЛинииСвязи(Линия)
	
	СписокТочек = Линия.Point;
	КоличествоТочек = СписокТочек.Количество();
	
	Если КоличествоТочек<2 Тогда
		Линия.zOrder = 2;
		Возврат;
	КонецЕсли;
	
	ТочкаНачала = СписокТочек[0];
	ТочкаОкончания = СписокТочек[КоличествоТочек-1];
	
	Если ТочкаОкончания.X = ТочкаНачала.X Тогда
		Линия.zOrder = 4;
	ИначеЕсли ТочкаОкончания.Y = ТочкаНачала.Y Тогда
		Линия.zOrder = 3;
	Иначе
		Линия.zOrder = 2;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти