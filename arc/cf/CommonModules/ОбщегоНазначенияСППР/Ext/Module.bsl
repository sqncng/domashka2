#Область ПрограммныйИнтерфейс

#Область РаботаGIT

// Проверяет, что все необходимые компоненты для работы с GIT установлены на сервере
//
// Параметры:
//
// Возвращаемое значение:
//  Версии установленных компонент
//
Функция КлиентGITНаСервереУстановлен() Экспорт
	
	ФайлКоманды = Новый ТекстовыйДокумент;
	ФайлЛогаТекстДокумент = Новый ТекстовыйДокумент;
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	ЭтоWindowsСервер = (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86
		Или СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64);
	
	Если ЭтоWindowsСервер Тогда
		ТекстКоманды = "@ECHO OFF";
		ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
	Иначе
		ТекстКоманды = "#!/bin/bash";
		ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
	КонецЕсли;
	
	ФайлЛога = ПолучитьИмяВременногоФайла("txt");
	ФайлКомандыGit = ПолучитьИмяВременногоФайла(?(ЭтоWindowsСервер, ".bat", ".sh"));
	
	ТекстКоманды = "git version >> ""%LOGFILE%""";
	ТекстКоманды = СтрЗаменить(ТекстКоманды, "%LOGFILE%", ФайлЛога);
	ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
	
	ТекстКоманды = "git lfs version >> ""%LOGFILE%""";
	ТекстКоманды = СтрЗаменить(ТекстКоманды, "%LOGFILE%", ФайлЛога);
	ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
	
	Если ЭтоWindowsСервер Тогда
		ФайлКоманды.Записать(ФайлКомандыGit, КодировкаТекста.OEM);
	Иначе
		ФайлКоманды.Записать(ФайлКомандыGit, КодировкаТекста.Системная, Символы.ПС);
	КонецЕсли;

	ЗапуститьПриложение(?(ЭтоWindowsСервер, "", "bash ") + ФайлКомандыGit, , Истина);
	
	Файл = Новый Файл(ФайлЛога);
	Если Файл.Существует() Тогда
		ФайлЛогаТекстДокумент.Прочитать(ФайлЛога);
		ВерсияGIT = ФайлЛогаТекстДокумент.ПолучитьСтроку(1);
		ВерсияGITLFS = ФайлЛогаТекстДокумент.ПолучитьСтроку(2);
	Иначе
		ВерсияGIT = "";
		ВерсияGITLFS = "";
	КонецЕсли;
	
	Попытка
		УдалитьФайлы(ФайлКомандыGit);
		УдалитьФайлы(ФайлЛога);
	Исключение
	КонецПопытки;
	
	Возврат Новый Структура("ВерсияGIT, ВерсияGITLFS", ВерсияGIT, ВерсияGITLFS);
	
КонецФункции

// Получает версии файлов из репозитория
//
// Параметры:
//  Параметры - Структура - включает ссылку на Проект или на Технический проект
//
// Возвращаемое значение:
//  Результат выполнения команды
//
Функция ПолучитьФайлыИзGIT(Параметры) Экспорт
	
	РеквизитыПроекта = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Параметры.Проект, "АдресGitСервера, КаталогGitРепозитория, Ветка.Имя");
	
	АдресGitСервера = РеквизитыПроекта.АдресGitСервера;
	КаталогGitРепозитория = РеквизитыПроекта.КаталогGitРепозитория;
	ИмяВеткиРепозитория = РеквизитыПроекта.ВеткаИмя;
	ИмяБазовойВетки = "";
	
	СоздатьВремКаталог = Ложь;
	Если НЕ ЗначениеЗаполнено(КаталогGitРепозитория) Тогда
		СоздатьВремКаталог = Истина;
	КонецЕсли;
	
	Если Параметры.Свойство("ИмяВеткиИсточника") И ЗначениеЗаполнено(Параметры.ИмяВеткиИсточника)
		И Параметры.Свойство("ИмяВеткиРепозитория") И ЗначениеЗаполнено(Параметры.ИмяВеткиРепозитория)
		Тогда
		СоздатьВремКаталог = Истина;
		ИмяВеткиРепозитория = Параметры.ИмяВеткиРепозитория;
	КонецЕсли;
	
	Если Параметры.Свойство("СоздаватьВременныйКаталог") И Параметры.СоздаватьВременныйКаталог Тогда
		СоздатьВремКаталог = Истина;
	КонецЕсли;	   
	
	Если СоздатьВремКаталог Тогда
		КаталогGitРепозитория = СоздатьВременныйКаталог();
	КонецЕсли;
	
	Параметры.Вставить("КаталогGitРепозитория", КаталогGitРепозитория);
	ЗаписьЖурналаРегистрации(НСтр("ru = 'ПолучитьФайлыИзGIT'"),УровеньЖурналаРегистрации.Информация,,,
		СтрШаблон(НСтр("ru = 'Файлы репозитория будут получены в каталог: %1'"), КаталогGitРепозитория));

	ФайлКоманды = Новый ТекстовыйДокумент;
	ФайлЛогаТекстДокумент = Новый ТекстовыйДокумент;
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	ЭтоWindowsСервер = (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86
		Или СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64);
	
	Если ЭтоWindowsСервер Тогда
		ТекстКоманды = "@ECHO OFF";
		ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
	Иначе
		ТекстКоманды = "#!/bin/bash";
		ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
	КонецЕсли;
	
	ФайлЛога = ПолучитьИмяВременногоФайла("txt");
	ФайлКомандыGit = ПолучитьИмяВременногоФайла(?(ЭтоWindowsСервер, ".bat", ".sh"));
	
	ТекстКоманды = "git config --get remote.origin.url >> ""%LOGFILE%""";
	ТекстКоманды = СтрЗаменить(ТекстКоманды, "%LOGFILE%", ФайлЛога);
	ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
	
	Если ЭтоWindowsСервер Тогда
		ФайлКоманды.Записать(ФайлКомандыGit, КодировкаТекста.OEM);
	Иначе
		ФайлКоманды.Записать(ФайлКомандыGit, КодировкаТекста.Системная);
	КонецЕсли;
	
	КодВозврата = 0;
	ЗапуститьПриложение(?(ЭтоWindowsСервер, "", "bash ") + ФайлКомандыGit, КаталогGitРепозитория, Истина, КодВозврата);
	
	Если КодВозврата <> 0 и КодВозврата <> 1 Тогда
		Возврат КодВозврата;
	КонецЕсли;
	
	Файл = Новый Файл(ФайлЛога);
	Если Файл.Существует() Тогда
		ФайлЛогаТекстДокумент.Прочитать(ФайлЛога);
	Иначе
		Возврат 1;
	КонецЕсли;
	АдресGitСервераНаСервере = ФайлЛогаТекстДокумент.ПолучитьСтроку(1);
	
	ФайлКоманды = Новый ТекстовыйДокумент;
	ФайлЛогаТекстДокумент = Новый ТекстовыйДокумент;
	
	Попытка
		УдалитьФайлы(ФайлКомандыGit);
		УдалитьФайлы(ФайлЛога);
	Исключение
	КонецПопытки;
	
	
	ФайлЛога = ПолучитьИмяВременногоФайла("txt");
	ФайлКомандыGit = ПолучитьИмяВременногоФайла(?(ЭтоWindowsСервер, ".bat", ".sh"));
	
	Если ЭтоWindowsСервер Тогда
		ТекстКоманды = "@ECHO OFF";
		ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
	Иначе
		ТекстКоманды = "#!/bin/bash";
		ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(АдресGitСервераНаСервере) и АдресGitСервера = АдресGitСервераНаСервере Тогда
		
		ТекстКоманды = "git pull >> ""%LOGFILE%""";
		ТекстКоманды = СтрЗаменить(ТекстКоманды, "%LOGFILE%", ФайлЛога);
		ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
		
	Иначе
		
		Попытка
			УдалитьФайлы(КаталогGitРепозитория, "*");
		Исключение
		КонецПопытки;
		
		// Skip smudge - We'll download binary files later in a faster batch
		ТекстКоманды = "git lfs install --skip-smudge";
		ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
		
		ТекстКоманды = "git clone -b ""%BRANCH%"" ""%GITSERVER%"" ""%FILE%"" >> ""%LOGFILE%""";
		ТекстКоманды = СтрЗаменить(ТекстКоманды, "%BRANCH%", ИмяВеткиРепозитория);
		ТекстКоманды = СтрЗаменить(ТекстКоманды, "%GITSERVER%", АдресGitСервера);
		ТекстКоманды = СтрЗаменить(ТекстКоманды, "%FILE%", КаталогGitРепозитория);
		ТекстКоманды = СтрЗаменить(ТекстКоманды, "%LOGFILE%", ФайлЛога);
		ФайлКоманды.ДобавитьСтроку(ТекстКоманды);  
		
		//Выполнение клонирования репозитория, чтобы получить информацию об ошибке, если клонирование не сработает.
		Если ЭтоWindowsСервер Тогда
			ФайлКоманды.Записать(ФайлКомандыGit, КодировкаТекста.OEM);
		Иначе
			ФайлКоманды.Записать(ФайлКомандыGit, КодировкаТекста.Системная);
		КонецЕсли;
		
		КодВозврата = 0;
		ЗапуститьПриложение(?(ЭтоWindowsСервер, "", "bash ") + ФайлКомандыGit, КаталогGitРепозитория, Истина, КодВозврата);
		Если КодВозврата <> 0 Тогда
			Файл = Новый Файл(ФайлЛога);
			Если Файл.Существует() Тогда
				Текст = Новый ЧтениеТекста;
				Текст.Открыть(ФайлЛога, "UTF-8",,,Ложь);
				ЛогКоманды = Текст.Прочитать();
				Текст.Закрыть();
				
				Параметры.Вставить("ЛогКоманды", ЛогКоманды);
			КонецЕсли;
			Возврат КодВозврата;
		КонецЕсли;
		
		Файл = Новый Файл(ФайлЛога);
		Если Файл.Существует() Тогда
			ФайлЛогаТекстДокумент.Прочитать(ФайлЛога);
			РезультатКоманды = ФайлЛогаТекстДокумент.ПолучитьСтроку(1);
		КонецЕсли;
		
		Попытка
			УдалитьФайлы(ФайлКомандыGit);
			УдалитьФайлы(ФайлЛога);
		Исключение
		КонецПопытки;
		
		ФайлКоманды = Новый ТекстовыйДокумент;
		ФайлЛогаТекстДокумент = Новый ТекстовыйДокумент;
		
		Если ЭтоWindowsСервер Тогда
			ТекстКоманды = "@ECHO OFF";
			ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
		Иначе
			ТекстКоманды = "#!/bin/bash";
			ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
		КонецЕсли;
		
		ТекстКоманды = "cd ""%FILE%""";
		ТекстКоманды = СтрЗаменить(ТекстКоманды, "%FILE%", КаталогGitРепозитория);
		ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
		
		// Fetch all the binary files in the new clone
		ТекстКоманды = "git lfs pull";
		ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
		
		// Reinstate smudge
		ТекстКоманды = "git lfs install --force";
		ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
		
	КонецЕсли;
	
	Если ЭтоWindowsСервер Тогда
		ФайлКоманды.Записать(ФайлКомандыGit, КодировкаТекста.OEM);
	Иначе
		ФайлКоманды.Записать(ФайлКомандыGit, КодировкаТекста.Системная);
	КонецЕсли;
	
	КодВозврата = 0;
	ЗапуститьПриложение(?(ЭтоWindowsСервер, "", "bash ") + ФайлКомандыGit, КаталогGitРепозитория, Истина, КодВозврата);
	Если КодВозврата <> 0 Тогда
		Возврат КодВозврата;
	КонецЕсли;
	
	Если Параметры.Свойство("ВеткаИсточник") 
		И ЗначениеЗаполнено(Параметры.ВеткаИсточник) И Параметры.Свойство("ЗаполнятьДанныеПоВеткеИсточнику")  Тогда
		
		ФайлЛогаТекстДокумент.Очистить();
		
		ИмяБазовойВетки = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Параметры.ВеткаИсточник, "Источник.Имя");
		ИмяВеткиРепозиторияБазовая = "origin/" + ИмяБазовойВетки;
											
		ФайлКоманды = Новый ТекстовыйДокумент;
		ФайлКомандыGit = ПолучитьИмяВременногоФайла(?(ЭтоWindowsСервер, ".bat", ".sh"));
		Если ЭтоWindowsСервер Тогда
			ТекстКоманды = "@ECHO OFF";
			ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
		Иначе
			ТекстКоманды = "#!/bin/bash";
			ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
		КонецЕсли;
		
		ФайлБазовыйКомит = ПолучитьИмяВременногоФайла("txt");
		
		ТекстКоманды = "git merge-base ""%BRANCH_BASE%"" ""%BRANCH%"" > ""%LOGFILE%""";
		ТекстКоманды = СтрЗаменить(ТекстКоманды, "%BRANCH_BASE%", ИмяВеткиРепозиторияБазовая);
		ТекстКоманды = СтрЗаменить(ТекстКоманды, "%BRANCH%", Параметры.ВеткаИсточник.Имя);
		ТекстКоманды = СтрЗаменить(ТекстКоманды, "%LOGFILE%", ФайлБазовыйКомит);
		ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
		
		Если ЭтоWindowsСервер Тогда
			ФайлКоманды.Записать(ФайлКомандыGit, КодировкаТекста.OEM);
		Иначе
			ФайлКоманды.Записать(ФайлКомандыGit, КодировкаТекста.Системная);
		КонецЕсли;
		
		КодВозврата = 0;
		ЗапуститьПриложение(?(ЭтоWindowsСервер, "", "bash ") + ФайлКомандыGit, КаталогGitРепозитория, Истина, КодВозврата);
		Если КодВозврата <> 0 Тогда
			Возврат КодВозврата;
		КонецЕсли;
		
		Файл = Новый Файл(ФайлБазовыйКомит);		
		Если Файл.Существует() Тогда
			ФайлЛогаТекстДокумент.Прочитать(ФайлБазовыйКомит);
			Если НЕ ЗначениеЗаполнено(ИмяБазовойВетки) Тогда
				ИмяБазовойВетки = ФайлЛогаТекстДокумент.ПолучитьСтроку(1);
			КонецЕсли;
		КонецЕсли;
					
		ФайлКоманды = Новый ТекстовыйДокумент;
		ФайлИзменений = ПолучитьИмяВременногоФайла("txt");
		ФайлКомандыGit = ПолучитьИмяВременногоФайла(?(ЭтоWindowsСервер, ".bat", ".sh"));
		Если ЭтоWindowsСервер Тогда
			ТекстКоманды = "@ECHO OFF";
			ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
		Иначе
			ТекстКоманды = "#!/bin/bash";
			ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
		КонецЕсли;
		ТекстКоманды = "git config --local core.quotepath false";
		ФайлКоманды.ДобавитьСтроку(ТекстКоманды);
		ТекстКоманды = "git diff ""%BRANCH%"" > ""%LOGFILE%""";		
		ТекстКоманды = СтрЗаменить(ТекстКоманды, "%BRANCH%", ИмяБазовойВетки);
		ТекстКоманды = СтрЗаменить(ТекстКоманды, "%LOGFILE%", ФайлИзменений);
		ФайлКоманды.ДобавитьСтроку(ТекстКоманды);    
		Если ЭтоWindowsСервер Тогда
			ФайлКоманды.Записать(ФайлКомандыGit, КодировкаТекста.OEM);
		Иначе
			ФайлКоманды.Записать(ФайлКомандыGit, КодировкаТекста.Системная);
		КонецЕсли;
		КодВозврата = 0;
		ЗапуститьПриложение(?(ЭтоWindowsСервер, "", "bash ") + ФайлКомандыGit, КаталогGitРепозитория, Истина, КодВозврата);
		Если КодВозврата <> 0 Тогда
			Возврат КодВозврата;
		КонецЕсли;
		
		Параметры.Вставить("ИмяФайлаИзменений", ФайлИзменений);
		
	КонецЕсли;
	
	Возврат РезультатКоманды;
	
КонецФункции

Функция ВыполнитьКонсольнуюКоманду(ТекстКоманды, КаталогКоманды, ИсключениеПриОшибке = Истина, Кодировка = Неопределено) Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	ЭтоWindowsСервер = (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86
	                ИЛИ СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64);
	
	ФайлЛога              = ПолучитьИмяВременногоФайла("txt");
	ФайлКонсольнойКоманды = ПолучитьИмяВременногоФайла(?(ЭтоWindowsСервер, ".bat", ".sh"));
	
	ФайлКоманды           = Новый ТекстовыйДокумент;
	ФайлЛогаТекстДокумент = Новый ТекстовыйДокумент;
	
	ТекстЗаголовка = ?(ЭтоWindowsСервер, "@ECHO OFF", "#!/bin/bash");
	ФайлКоманды.ДобавитьСтроку(ТекстЗаголовка);
	
	ТекстКонсольнойКоманды = СтрШаблон("%1 >> ""%2""" + ?(ЭтоWindowsСервер, " 2>&1", ""), ТекстКоманды, ФайлЛога);
	ФайлКоманды.ДобавитьСтроку(ТекстКонсольнойКоманды);
	ФайлКоманды.Записать(ФайлКонсольнойКоманды, ?(ЭтоWindowsСервер, КодировкаТекста.OEM, КодировкаТекста.Системная));
	ФайлКоманды = Неопределено;
	
	КодВозврата = 0;
	ЗапуститьПриложение(?(ЭтоWindowsСервер, "", "bash ") + ФайлКонсольнойКоманды, КаталогКоманды, Истина, КодВозврата);
	
	Ответ = Новый Структура;
	Ответ.Вставить("КодВозврата", КодВозврата);
	
	Файл = Новый Файл(ФайлЛога);
	Если Файл.Существует() Тогда
		Если Кодировка = Неопределено Тогда
			ФайлЛогаТекстДокумент.Прочитать(ФайлЛога);
			Лог = ФайлЛогаТекстДокумент.ПолучитьТекст();
		Иначе	
			ФайлЛогаТекстДокумент.Прочитать(ФайлЛога, Кодировка);
			Лог = ФайлЛогаТекстДокумент.ПолучитьТекст();
		КонецЕсли;	
	Иначе
		Лог = ""
	КонецЕсли;
	Ответ.Вставить("Лог", Лог);
	
	ФайлЛогаТекстДокумент = Неопределено;
	
	Попытка
		УдалитьФайлы(ФайлЛога);
		УдалитьФайлы(ФайлКонсольнойКоманды);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'ВыполнитьКонсольнуюКоманду'"), УровеньЖурналаРегистрации.Ошибка,,,ОписаниеОшибки());
	КонецПопытки;
	
	Если ИсключениеПриОшибке И КодВозврата <> 0 Тогда
		ВызватьИсключение СтрШаблон("%1
		                            |exit code: %2
		                            |log: %3", ТекстКоманды, КодВозврата, Лог);
	КонецЕсли; 
	
	Возврат Ответ;
	
КонецФункции

#КонецОбласти

#Область РаботаССКД

// Получает и возвращает макет компоновки данных для схемы компоновки
//
// Параметры:
//  СхемаКомпоновки - схема компоновки данных, для которой получается макет компоновки
//  Настройки - настройки компоновки, применяемые к схеме
//
// Возвращаемое значение:
//  Макет компоновки данных
//
Функция ПолучитьМакетКомпоновки(СхемаКомпоновки, Настройки) Экспорт

	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;

	Возврат КомпоновщикМакета.Выполнить(СхемаКомпоновки, Настройки, , , Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));

КонецФункции

// Формирует и возвращает схему компоновки данных, используя
// в качестве набора данных запрос
//
// Параметры:
//  ТекстЗапроса - строка, содержащая текст запроса
//
Функция СхемаКомпоновкиДанныхПоЗапросу(ТекстЗапроса) Экспорт

	СхемаКомпоновки = Новый СхемаКомпоновкиДанных();
	
	Источник = СхемаКомпоновки.ИсточникиДанных.Добавить();
	Источник.Имя = "Источник1";
	Источник.СтрокаСоединения="";
	Источник.ТипИсточникаДанных = "local";
	
	НаборДанных = СхемаКомпоновки.НаборыДанных.Добавить(Тип("НаборДанныхЗапросСхемыКомпоновкиДанных"));
	НаборДанных.Имя = "Запрос";
	НаборДанных.ИсточникДанных = "Источник1";
	НаборДанных.Запрос = ТекстЗапроса;
	НаборДанных.АвтоЗаполнениеДоступныхПолей = Истина;
	
	//Для Каждого Поле из МассивПолей Цикл
	//	ПолеНабораДанных = НаборДанных.Поля.Добавить(Тип("ПолеНабораДанныхСхемыКомпоновкиДанных"));
	//	ПолеНабораДанных.Поле = Поле;
	//	ПолеНабораДанных.ПутьКДанным = Поле;
	//КонецЦикла;
	
	Возврат СхемаКомпоновки;

КонецФункции

// Формирует и возвращает настройки компоновщика для переданной схемы компоновки
//
// Параметры:
//  СхемаКомпоновки - схема компоновки данных, для которой компонуются настройки
//
// Возвращаемое значение:
//  Настройки компоновщика
//
Функция СкомпоноватьНастройки(СхемаКомпоновки) Экспорт

	ИсточникНастроек = Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновки);
	КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных();
	КомпоновщикНастроек.Инициализировать(ИсточникНастроек);
	
	// Добавим выбранные поля
	Для Каждого Элемент из КомпоновщикНастроек.Настройки.Выбор.ДоступныеПоляВыбора.Элементы Цикл
		
		Если НЕ Элемент.Папка Тогда
			ВыбранноеПоле = КомпоновщикНастроек.Настройки.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
			ВыбранноеПоле.Использование = Истина;
			ВыбранноеПоле.Поле = Элемент.Поле;
		КонецЕсли;
		
	КонецЦикла;
	
	// Добавим группировку
	ГруппировкаНастроек = КомпоновщикНастроек.Настройки.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
	Поле = ГруппировкаНастроек.Выбор.Элементы.Добавить(Тип("АвтоВыбранноеПолеКомпоновкиДанных"));
	
	Возврат КомпоновщикНастроек.Настройки;

КонецФункции

// Копирует элементы отбора из одной коллекции отбора в другую
//
// Параметры:
//  Источник - ОтборКомпоновкиДанных - откуда копировать
//  Приемник - ОтборКомпоновкиДанных - куда копировать
//  ТолькоИспользуемые - Булево - копировать только используемые
//  ПоляИсключения - Структура - в ключах структуры перечислены поля которые не должны попасть в отбор приемник
//
Процедура СкопироватьОтбор(ОтборИсточник, ОтборПриемник, ТолькоИспользуемые = Ложь, Знач ПоляИсключения = Неопределено) Экспорт
	
	Если ТипЗнч(ПоляИсключения) = Тип("Строка") Тогда
		ПоляИсключения = Новый Структура(ПоляИсключения);
	КонецЕсли;
	
	Для Каждого Элемент Из ОтборИсточник.Элементы Цикл
		
		Если НЕ (ТолькоИспользуемые И Элемент.Использование ИЛИ НЕ ТолькоИспользуемые) Тогда
			Продолжить;
		КонецЕсли;
		
		Если ТипЗнч(Элемент) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			НовыйЭлемент = НовыйОтбор(ОтборПриемник,,,Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
			ЗаполнитьЗначенияСвойств(НовыйЭлемент, Элемент);
			СкопироватьОтбор(Элемент, НовыйЭлемент, ТолькоИспользуемые, ПоляИсключения);
		Иначе
			
			Если ЗначениеЗаполнено(ПоляИсключения) Тогда
				Поле = РазделитьИмяПоляИРеквизита(Строка(Элемент.ЛевоеЗначение));
				Если ПоляИсключения.Свойство(Поле.Имя) Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			НовыйЭлемент = НовыйОтбор(ОтборПриемник,,,Тип("ЭлементОтбораКомпоновкиДанных"));
			ЗаполнитьЗначенияСвойств(НовыйЭлемент, Элемент);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает ссылку на новый элемент отбора в переданном отборе схемы компоновки данных.
//
// Параметры:
//  Отбор - ОтборКомпоновкиДанных - отбор схемы компоновки, в который необходимо добавить новый элемент
//  ЛевоеЗначение - Строка, ПолеКомпоновкиДанных - поле компоновки, по которому необходимо установить отбор (необязательное)
//  ПравоеЗначение  - Произвольный, Строка, ПолеКомпоновкиДанных - значение отбора (необязательное) или поле компоновки
//  ТипОтбора  - ЭлементОтбораКомпоновкиДанных, ГруппаЭлементовОтбораКомпоновкиДанных - тип нового элемента отбора (необязательное)
//  ВидСравнения  - ВидСравненияКомпоновкиДанных - вид сравнения левого и правого значения
//  ПравоеЗначениеПоле  - Булево - указывает использовать ли в качестве правого значения поле компоновки данных.
//
// Возвращаемое значение:
//  ЭлементОтбораКомпоновкиДанных - ссылка на новый элемент отбора схемы компоновки данных.
//
Функция НовыйОтбор(Отбор, ЛевоеЗначение, ПравоеЗначение = Неопределено, ТипОтбора = Неопределено, ВидСравнения = Неопределено, ПравоеЗначениеПоле = Ложь) Экспорт
	
	Если ТипОтбора = Неопределено Тогда
		ТипОтбора = Тип("ЭлементОтбораКомпоновкиДанных");
	КонецЕсли;
	
	НовыйОтбор = Отбор.Элементы.Добавить(ТипОтбора);
	Если ЛевоеЗначение <> Неопределено Тогда
		Если ТипЗнч(ЛевоеЗначение) = Тип("ПолеКомпоновкиДанных") Тогда
			НовыйОтбор.ЛевоеЗначение = ЛевоеЗначение;
		Иначе
			НовыйОтбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ЛевоеЗначение);
		КонецЕсли;
	КонецЕсли;
	
	Если ПравоеЗначение <> Неопределено Тогда
		Если ПравоеЗначениеПоле Тогда
			Если ТипЗнч(ПравоеЗначение) = Тип("ПолеКомпоновкиДанных") Тогда
				НовыйОтбор.ПравоеЗначение = ПравоеЗначение;
			Иначе
				НовыйОтбор.ПравоеЗначение = Новый ПолеКомпоновкиДанных(ПравоеЗначение);
			КонецЕсли;
		Иначе
			НовыйОтбор.ПравоеЗначение = ПравоеЗначение;
		КонецЕсли;
	КонецЕсли;
	
	Если ТипОтбора = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Если ВидСравнения = Неопределено Тогда
			НовыйОтбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
			Если ТипЗнч(ПравоеЗначение) = Тип("Массив") ИЛИ ТипЗнч(ПравоеЗначение) = Тип("СписокЗначений") Тогда
				НовыйОтбор.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке;
			КонецЕсли;
		Иначе
			НовыйОтбор.ВидСравнения = ВидСравнения;
		КонецЕсли;
	КонецЕсли;
	
	Возврат НовыйОтбор;
	
КонецФункции

#КонецОбласти

#Область НастройкиФорм

// Процедура выполняет поиск элемента - параметра контекстной функциональной опции,
// по заданным параметрам.
//
// Параметры:
//	Форма (УправляемаяФорма) - форма элемента,
//	ПараметрыНастройки (Структура) - параметры настройки формы.
//
Процедура НастроитьФормуПоПараметрам(Форма, ПараметрыНастройки) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Сформировать текст запроса для получения ссылка на КФО.
	Запрос = Новый Запрос;
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	НастройкиФорм.Ссылка
	|ИЗ
	|	Справочник.ПараметрыКонтекстныхФункциональныхОпций КАК НастройкиФорм
	|ГДЕ
	|	ИСТИНА";
	
	Для каждого ПараметрНастройки Из ПараметрыНастройки Цикл
		
		СтрокаПараметраНастройки = "
		|	И НастройкиФорм.%1 = &%1";
		
		СтрокаПараметраНастройки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаПараметраНастройки, ПараметрНастройки.Ключ);
		
		ТекстЗапроса = ТекстЗапроса + СтрокаПараметраНастройки;
		
		Запрос.УстановитьПараметр(ПараметрНастройки.Ключ, ПараметрНастройки.Значение);
		
	КонецЦикла;
	
	Запрос.Текст = ТекстЗапроса;
	
	// Получить нужный элемент, если элемента с такими значениями полей не существует, то создать его.
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		
		Настройка = Выборка.Ссылка;
		
	Иначе
		
		СправочникОбъект = Справочники.ПараметрыКонтекстныхФункциональныхОпций.СоздатьЭлемент();
		
		ЗаполнитьЗначенияСвойств(СправочникОбъект, ПараметрыНастройки);
		
		СправочникОбъект.Записать();
		
		Настройка = СправочникОбъект.Ссылка;
		
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Форма.УстановитьПараметрыФункциональныхОпцийФормы(Новый Структура("НастройкаФормы", Настройка));
	
КонецПроцедуры

// Установить параметры выбора для указанного поля формы.
//
// Параметры:
//  Элемент - РасширениеПоляВвода - элемент формы, имеющий свойство ПараметрыВыбора.
//  ПараметрыВыбора - ФиксированныйМассив - массив элементов ПараметрВыбора;
//                  - ПараметрВыбора - один параметр выбора.
//
Процедура УстановитьПараметрыВыбораЭлементаФормы(Элемент, ПараметрыВыбора) Экспорт
	
	ТипЗначения = ТипЗнч(ПараметрыВыбора);
	
	Если ТипЗначения = Тип("ПараметрВыбора") Тогда
		Массив = Новый Массив;
		Массив.Добавить(ПараметрыВыбора);
		Параметры = Новый ФиксированныйМассив(Массив);
	ИначеЕсли ТипЗначения = Тип("ФиксированныйМассив") Тогда
		Параметры = ПараметрыВыбора;
	Иначе
		ШаблонСообщения = НСтр("ru = 'Неизвестный тип ""%1"" параметра выбора поля ввода.'");
		ВызватьИсключение СтрШаблон(ШаблонСообщения, ТипЗначения);
	КонецЕсли;
	
	Элемент.ПараметрыВыбора = Параметры;
	
КонецПроцедуры

// Функция возвращает структуру параметров настройки формы.
//
// Параметры:
//	Форма (УправляемаяФорма) - форма элемента объекта.
//
// Возвращаемое значение:
//	Структура. Параметры настройки формы.
//
Функция ПараметрыНастройкиФормы(Форма) Экспорт
	
	Ссылка = Форма.Объект.Ссылка;
	
	// Сформировать структуру параметров настроек, по-умолчанию, все КФО включены,
	// значения полей структуры устанавливаются в <Истина>.
	ПараметрыНастройки = Новый Структура;
	
	Для Каждого Реквизит Из Метаданные.Справочники.ПараметрыКонтекстныхФункциональныхОпций.Реквизиты Цикл
		ПараметрыНастройки.Вставить(Реквизит.Имя, Истина);
	КонецЦикла;
	
	Если ТипЗнч(Ссылка) = Тип("СправочникСсылка.ОбъектыМетаданных") Тогда
		
		ОбъектМетаданныхСсылка = Ссылка;
		ОбъектМетаданных = Форма.РеквизитФормыВЗначение("Объект");
		
		Если ОбъектМетаданных.ЭтоНовый() Тогда
			Если Форма.Параметры.ЗначениеКопирования <> Справочники.ОбъектыМетаданных.ПустаяСсылка() Тогда
				ОбъектКопирования = Форма.Параметры.ЗначениеКопирования;
				Родитель = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ОбъектКопирования, "Родитель");
			Иначе
				Если Форма.Параметры.ЗначенияЗаполнения.Свойство("Родитель") Тогда
					Родитель = Форма.Параметры.ЗначенияЗаполнения.Родитель;
				Иначе
					Родитель = Справочники.ОбъектыМетаданных.ПустаяСсылка();
				КонецЕсли;
			КонецЕсли;	
		Иначе
			Родитель = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ОбъектМетаданныхСсылка, "Родитель");
		КонецЕсли;
		
		ИмяКласса = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Родитель, "Имя");
		
		// Установить значения параметров настроек.
		ПараметрыНастройки.ИспользоватьРеквизиты = Родитель.ЕстьРеквизиты;
		ПараметрыНастройки.ИспользоватьФормы = Родитель.ЕстьФормы;
		Если ИмяКласса = "ОбщиеФормы" Тогда
			ПараметрыНастройки.ИспользоватьФормы = Ложь;
		КонецЕсли;
		ПараметрыНастройки.ИспользоватьМакеты = Родитель.ЕстьМакеты;
		Если ИмяКласса = "ОбщиеМакеты" Тогда
			ПараметрыНастройки.ИспользоватьМакеты = Ложь;
		КонецЕсли;
		ПараметрыНастройки.ИспользоватьДвиженияДокумента = Родитель.ЕстьДвиженияДокумента;
		ПараметрыНастройки.ИспользоватьПредопределенныеДанные = Родитель.ЕстьПредопределенныеДанные;
		ПараметрыНастройки.ИспользоватьСсылкиИзОбъектовМетаданных = Родитель.ЕстьСсылкиИзОбъектовМетаданных;
		ПараметрыНастройки.ИспользоватьКомандыОбъектаМетаданных = ИспользоватьКомандыОбъектаМетаданных(ИмяКласса);
		
		// ... использовать права доступа (для роли)
		Если НЕ ИмяКласса = "Роли" Тогда
			ПараметрыНастройки.ИспользоватьПраваДоступаРоли = Ложь;
		КонецЕсли;
		
		// ... использовать права доступа (для объекта метаданных)
		ПараметрыНастройки.ИспользоватьПраваДоступаОбъектаМетаданных = ИспользоватьПраваДоступаОбъектаМетаданных(ИмяКласса);
		
		// ... использовать расширенное хранение
		Если НЕ РаботаСОбъектамиМетаданных.ЭтоЭлементРасширенногоХранения(ИмяКласса) Тогда
			ПараметрыНастройки.ИспользоватьРасширенноеХранение = Ложь;
		КонецЕсли;
		
		// ... использовать подписки на события
		ПараметрыНастройки.ИспользоватьПодпискиНаСобытия = ИспользоватьПодпискиНаСобытияОбъектаМетаданных(ИмяКласса);
		
		// ... использовать элементы справки
		ПараметрыНастройки.ИспользоватьЭлементыСправки = ИспользоватьЭлементыСправкиОбъектаМетаданных(ИмяКласса);
		
	ИначеЕсли ТипЗнч(Ссылка) = Тип("СправочникСсылка.Ошибки") Тогда
		ПараметрыНастройки.ИспользоватьИнтеграциюСАПК = 
			ПолучитьФункциональнуюОпцию("ИспользоватьИнтеграциюСАПК") И Форма.Объект.ЗарегистрированаИзАПК;
	КонецЕсли;
	
	Возврат ПараметрыНастройки;
	
КонецФункции

// Функция возвращает структуру параметров настройки формы.
//
// Параметры:
//	Форма (УправляемаяФорма) - форма элемента объекта.
//
// Возвращаемое значение:
//	Структура. Параметры настройки формы.
//
Функция ПараметрыВидимостиЭлемнтовФормы(Форма) Экспорт
	
	Ссылка = Форма.Объект.Ссылка;
	
	Если ТипЗнч(Ссылка) = Тип("СправочникСсылка.ОбъектыМетаданных") Тогда
		
		ОбъектМетаданныхСсылка = Ссылка;
		ОбъектМетаданных = Форма.РеквизитФормыВЗначение("Объект");
		
		Если ОбъектМетаданных.ЭтоНовый() Тогда
			Если Форма.Параметры.ЗначениеКопирования <> Справочники.ОбъектыМетаданных.ПустаяСсылка() Тогда
				ОбъектКпирования = Форма.Параметры.ЗначениеКопирования;
				Родитель = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ОбъектКпирования, "Родитель");
			Иначе
				Если Форма.Параметры.ЗначенияЗаполнения.Свойство("Родитель") Тогда
					Родитель = Форма.Параметры.ЗначенияЗаполнения.Родитель;
				Иначе
					Родитель = Справочники.ОбъектыМетаданных.ПустаяСсылка();
				КонецЕсли;
			КонецЕсли;	
		Иначе
			Родитель = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ОбъектМетаданныхСсылка, "Родитель");			
		КонецЕсли;
		
		ИмяКласса = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Родитель, "Имя");
		
		// Сформировать структуру параметров настроек, по-умолчанию
		
		ПараметрыНастройки = Новый Структура;
	 	ПараметрыНастройки.Вставить("ПредставлениеОбъекта", Истина);
		ПараметрыНастройки.Вставить("РасширенноеПредставлениеОбъекта", Истина);
		ПараметрыНастройки.Вставить("ПредставлениеСписка", Истина);
				
		ПараметрыНастройки.ПредставлениеОбъекта = ИспользоватьПредставлениеОбъектаОбъектаМетаданных(ИмяКласса);
		ПараметрыНастройки.РасширенноеПредставлениеОбъекта = ИспользоватьРасширенноеПредставлениеОбъектаОбъектаМетаданных(ИмяКласса);
		ПараметрыНастройки.ПредставлениеСписка = ИспользоватьПредставлениеСпискаОбъектаМетаданных(ИмяКласса);
		
	КонецЕсли;
	
	Возврат ПараметрыНастройки;
	
КонецФункции

#КонецОбласти

#Область Прочее

// Функция возвращает ссылку на объект в котором хранятся "расширенные"
// сведения о объекте метаданных.
//
// Параметры:
//	ОбъектМетаданных (СправочникСсылка.ОбъектыМетаданных) - объект метаданных.
//
// Возвращаемое значение:
//	СправочникСсылка. Ссылка на элемент справочника в котором хранятся
//	"расширенные" сведения.
//
Функция СвойстваОбъектаРасширенногоХранения(ОбъектМетаданных) Экспорт
	
	// Сформировать текст запроса.
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапросаПолученияСвойствРасширенногоХранения(ОбъектМетаданных);
	
	Запрос.УстановитьПараметр("ОбъектМетаданных", ОбъектМетаданных);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	
	Возврат Выборка.Ссылка;
	
КонецФункции

// Функция возвращает строку - имя справочника в котором хранятся "расширенные"
// сведения о объекте метаданных.
//
// Параметры:
//	ОбъектМетаданных (СправочникСсылка.ОбъектыМетаданных) - объект метаданных.
//
// Возвращаемое значение:
//	Строка. Имя справочника в котором хранятся расширенные сведения.
//
Функция ИмяСправочникаРасширенныхСвойств(ОбъектМетаданных) Экспорт
	
	ИмяКласса = РаботаСОбъектамиМетаданных.ИмяКлассаОбъектаМетаданных(ОбъектМетаданных);
	
	Если ИмяКласса = "ОбщиеМодули" Тогда
		Возврат "ОбщиеМодулиСвойства";
	КонецЕсли;
	
	Если ИмяКласса = "ОбщиеРеквизиты" Тогда
		Возврат "ОбщиеРеквизитыСвойства";
	КонецЕсли;
	
	Если ИмяКласса = "ПодпискиНаСобытия" Тогда
		Возврат "ПодпискиНаСобытияСвойства";
	КонецЕсли;
	
	Если ИмяКласса = "РегламентныеЗадания" Тогда
		Возврат "РегламентныеЗаданияСвойства";
	КонецЕсли;
	
	Если ИмяКласса = "ФункциональныеОпции" Тогда
		Возврат "ФункциональныеОпцииСвойства";
	КонецЕсли;
	
	Если ИмяКласса = "ПакетыXDTO" Тогда
		Возврат "ПакетыXDTOСвойства";
	КонецЕсли;
	
	Если ИмяКласса = "КритерииОтбора" Тогда
		Возврат "КритерииОтбораСвойства";
	КонецЕсли;
	
	Если ИмяКласса = "WebСервисы" Тогда
		Возврат "WebСервисыСвойства";
	КонецЕсли;
	
	Если ИмяКласса = "ОбщиеКоманды" Тогда
		Возврат "ОбщиеКомандыСвойства";
	КонецЕсли;
	
	Если ИмяКласса = "ГруппыКоманд" Тогда
		Возврат "ГруппыКомандСвойства";
	КонецЕсли;
	
	Если ИмяКласса = "WSСсылки" Тогда
		Возврат "WSСсылкиСвойства";
	КонецЕсли;
	
	Если ИмяКласса = "ОбщиеМакеты" Тогда
		Возврат "ОбщиеМакетыСвойства";
	КонецЕсли;
	
	Если ИмяКласса = "Последовательности" Тогда
		Возврат "ПоследовательностиСвойства";
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Функция возвращает строку - полное имя формы которую надо открыть для
// отображения "расширенных" свойств объекта метаданных
//
// Параметры:
//	ОбъектМетаданных (СправочникСсылка.ОбъектыМетаданных) - объект метаданных.
//
// Возвращаемое значение:
//	Строка. Имя формы объекта.
//
Функция ИмяФормыОбъектаРасширенногоХранения(ОбъектМетаданных) Экспорт
	
	ИмяСправочника = ИмяСправочникаРасширенныхСвойств(ОбъектМетаданных);
	
	ИмяФормы = "Справочник.%1.ФормаОбъекта";
	ИмяФормы = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ИмяФормы, ИмяСправочника);
	
	Возврат ИмяФормы;
	
КонецФункции

// Устанавливает значение переданного реквизита типа "ФорматированныйДокумент", получая данные из указанного
// хранилища значения
//
// Параметры:
//  Описание - форматированныйДокумент, который надо заполнить данными из хранилища значения
//  ХранилищеЗначения - хранилище значения, содержащее описание форматированного документа
//
Процедура УстановитьФорматированноеОписаниеИзХранилища(Описание, ХранилищеЗначения) Экспорт
	
	ДанныеХранилища = ХранилищеЗначения.Получить();
	Если ТипЗнч(ДанныеХранилища) = Тип("ФорматированныйДокумент") Тогда
		Описание = ДанныеХранилища;
	Иначе
		Описание = Новый ФорматированныйДокумент;
	КонецЕсли;
	
КонецПроцедуры

// Помещает указанное описание типа "ФорматированныйДокумент", в указанное хранилище значения
//
// Параметры:
//  Описание - форматированныйДокумент, который надо поместить в хранилище значения
//  ХранилищеЗначения - хранилище значения, в которое нужно поместить форматированное описание
//
Процедура ПоместитьФорматированноеОписаниеВХранилище(Описание, ХранилищеЗначения) Экспорт
	
	ХранилищеЗначения = Новый ХранилищеЗначения(Описание);
	
КонецПроцедуры

// Формирует список зарегистрированных баз с учетом групп
//
// Параметры:
//  Параметры   - Структура - параметры формирования списка баз
//  	АдресФайлаСоСпискомИБ  - Строка - адрес хранилища в котором размещен файл со списком баз
//  	ФайловыйРежим		   - Булево - Истина, если нужно получить только "файловые базы"
//  	БазыДоступныеПоВебСсылке -  Булево - Истина, если нужно включать в список базы, которые начинаются ws=
//
// Возвращаемое значение:
//   ДеревоЗначений   - список зарегистрированных баз
//
Функция СформироватьСписокЗарегистрированныхБаз(Параметры) Экспорт

	АдресФайлаСоСпискомИБ    = Параметры.АдресФайлаСоСпискомИБ;
	ТолькоФайловыеБазы       = Параметры.ФайловыйРежим;
	БазыДоступныеПоВебСсылке = Ложь;
	Если Параметры.Свойство("БазыДоступныеПоВебСсылке") Тогда
		БазыДоступныеПоВебСсылке = Параметры.БазыДоступныеПоВебСсылке;
	КонецЕсли;	 
	
	ДанныеФайлаСоСпискомБаз = ПолучитьИзВременногоХранилища(АдресФайлаСоСпискомИБ);
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
	ДанныеФайлаСоСпискомБаз.Записать(ИмяВременногоФайла);
	
	Текст = Новый ТекстовыйДокумент;
	Текст.Прочитать(ИмяВременногоФайла);
	
	СписокИБДерево = Новый ДеревоЗначений;
	СписокИБДерево.Колонки.Добавить("ИнформационнаяБаза", Новый ОписаниеТипов("Строка"));
	СписокИБДерево.Колонки.Добавить("СтрокаСоединения", Новый ОписаниеТипов("Строка"));
	СписокИБДерево.Колонки.Добавить("ID", Новый ОписаниеТипов("Строка"));
	СписокИБДерево.Колонки.Добавить("OrderInTree", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(10, 3)));
	СписокИБДерево.Колонки.Добавить("Folder", Новый ОписаниеТипов("Булево"));
	СписокИБДерево.Колонки.Добавить("НомерКартинки", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(10, 0)));
	СписокИБДерево.Колонки.Добавить("ФайловыйРежим", Новый ОписаниеТипов("Булево"));
	СписокИБДерево.Колонки.Добавить("ИмяСервера", Новый ОписаниеТипов("Строка"));
	СписокИБДерево.Колонки.Добавить("КаталогИБ", Новый ОписаниеТипов("Строка"));
	СписокИБДерево.Колонки.Добавить("ИмяИБ", Новый ОписаниеТипов("Строка"));
	СписокИБДерево.Колонки.Добавить("НаименованиеБазы", Новый ОписаниеТипов("Строка"));
	СписокИБДерево.Колонки.Добавить("Version", Новый ОписаниеТипов("Строка"));
	
	КореньИБ = СписокИБДерево.Строки.Добавить();
	КореньИБ.ИнформационнаяБаза = "Информационные базы";
	КореньИБ.Folder = Истина;
	КореньИБ.ID = "/";
	КореньИБ.СтрокаСоединения = "0";
	КореньИБ.НомерКартинки = 1;
	
	Folder = "";
	НоваяИБ = Неопределено;
	СтрокаСоединения = "";
	ID = "";
	OrderInTree = 0;
	Version = "";
	ИнформационнаяБаза = "";
	
	Для Сч = 1 По Текст.КоличествоСтрок() Цикл
		
		ТекСтр = Текст.ПолучитьСтроку(Сч);
		
		Если Лев(ТекСтр,1) = "[" Тогда
			
			Если ID <> "" Тогда
				РодительИБ = ПолучитьРодителяИБ(Folder, КореньИБ);
				НоваяИБ = Неопределено;
				Если СтрокаСоединения = "" Тогда
					// Группа баз
					ID = Folder + ?(Folder = "/", "", "/") + ИнформационнаяБаза;
					НоваяИБ = РодительИБ.Строки.Найти(ID, "ID");
					Если НоваяИБ = Неопределено Тогда
						НоваяИБ = РодительИБ.Строки.Добавить();
						НоваяИБ.ID = ID;
						НоваяИБ.Folder = Истина;
						НоваяИБ.НомерКартинки = 1;
					КонецЕсли; 
				Иначе
					Если НСтр(СтрокаСоединения,"File") <> ""
						ИЛИ (Не ТолькоФайловыеБазы И НСтр(СтрокаСоединения,"Srvr") <> "")
						ИЛИ (БазыДоступныеПоВебСсылке И НСтр(СтрокаСоединения,"ws") <> "")Тогда
						НоваяИБ = РодительИБ.Строки.Добавить();
						НоваяИБ.ID = ID;
						НоваяИБ.СтрокаСоединения = СтрокаСоединения;
						НоваяИБ.Version          = Version;
						ЗаполнитьЗначенияСвойств(НоваяИБ, РазобратьСтрокуСоединения(СтрокаСоединения));
					КонецЕсли; 
				КонецЕсли; 
				
				Если НоваяИБ <> Неопределено Тогда
					НоваяИБ.ИнформационнаяБаза = ИнформационнаяБаза;
					НоваяИБ.OrderInTree = OrderInTree;
				КонецЕсли;
				
				СтрокаСоединения = "";
				ID = "";
			КонецЕсли;
			
			ИнформационнаяБаза = Сред(ТекСтр, 2, СтрДлина(ТекСтр) - 2);
		Иначе
			Поз = Найти(ТекСтр,"=");
			
			СвойствоИБ = СокрП(Лев(ТекСтр, Поз - 1));
			ЗначениеСвойства = Сред(ТекСтр, Поз + 1);
			
			Если СвойствоИБ = "Connect" Тогда
				СтрокаСоединения = Лев(ЗначениеСвойства,СтрДлина(ЗначениеСвойства)-1);
			ИначеЕсли СвойствоИБ = "Folder" Тогда
				Folder = ЗначениеСвойства;
			ИначеЕсли СвойствоИБ = "ID" Тогда
				ID = ЗначениеСвойства;
			ИначеЕсли СвойствоИБ = "OrderInTree" Тогда
				OrderInTree = Число(ЗначениеСвойства);
			ИначеЕсли СвойствоИБ = "Version" Тогда
				Version = ЗначениеСвойства;
			КонецЕсли;			
		КонецЕсли;
		
	КонецЦикла;
	
	Если ID <> "" Тогда
		РодительИБ = ПолучитьРодителяИБ(Folder, КореньИБ);
		НоваяИБ = Неопределено;
		Если СтрокаСоединения = "" Тогда
			// Группа баз
			ID = Folder + ?(Folder = "/", "", "/") + ИнформационнаяБаза;
			НоваяИБ = РодительИБ.Строки.Найти(ID, "ID");
			Если НоваяИБ = Неопределено Тогда
				НоваяИБ = РодительИБ.Строки.Добавить();
				НоваяИБ.ID = ID;
				НоваяИБ.Folder = Истина;
				НоваяИБ.НомерКартинки = 1;
			КонецЕсли; 
		Иначе
			Если НСтр(СтрокаСоединения,"File") <> ""
					ИЛИ (Не ТолькоФайловыеБазы И НСтр(СтрокаСоединения,"Srvr") <> "")
					ИЛИ (БазыДоступныеПоВебСсылке И НСтр(СтрокаСоединения,"ws") <> "")Тогда
				НоваяИБ = РодительИБ.Строки.Добавить();
				НоваяИБ.ID = ID;
				НоваяИБ.СтрокаСоединения = СтрокаСоединения;
				НоваяИБ.Version          = Version;
				ЗаполнитьЗначенияСвойств(НоваяИБ, РазобратьСтрокуСоединения(СтрокаСоединения));
			КонецЕсли; 
		КонецЕсли; 
		
		Если НоваяИБ <> Неопределено Тогда
			НоваяИБ.ИнформационнаяБаза = ИнформационнаяБаза;
			НоваяИБ.OrderInTree = OrderInTree;
		КонецЕсли; 
		
		СтрокаСоединения = "";
		ID = "";
	КонецЕсли;
	
	УдалитьПустыеГруппыБаз(КореньИБ.Строки);
	
	СписокИБДерево.Строки.Сортировать("OrderInTree", Истина);
	
	Возврат СписокИБДерево;
	
КонецФункции

Функция СписокДоступныхВерсийПлатформы(ПутьКВерсиямПлатформыНаСервере = "") Экспорт 
	
	СписокВерсий = Новый Массив;
	
	Если Не ЗначениеЗаполнено(ПутьКВерсиямПлатформыНаСервере) Тогда
	
		ПутьКВерсиямПлатформыНаСервере = Константы.ПутьКВерсиямПлатформыНаСервере.Получить();
	
	КонецЕсли; 
	
	СистемнаяИнфо = Новый СистемнаяИнформация;
	ТипПлатформыСервера = СистемнаяИнфо.ТипПлатформы;
	
	Если ТипПлатформыСервера = ТипПлатформы.Windows_x86
		ИЛИ ТипПлатформыСервера = ТипПлатформы.Windows_x86_64 Тогда
		ИмяИсполняемогоФайлаКонфигуратора = "1cv8.exe";
	Иначе
		ИмяИсполняемогоФайлаКонфигуратора = "1cv8";
	КонецЕсли;
	
	
	Если Найти(ПутьКВерсиямПлатформыНаСервере, "%ВерсияПлатформы%") > 0 Тогда
	
		НачалоПутиКВерсиямПлатформыНаСервере = Лев(ПутьКВерсиямПлатформыНаСервере, Найти(ПутьКВерсиямПлатформыНаСервере, "%ВерсияПлатформы%")-1);
		ОкончаниеПутиКВерсиямПлатформыНаСервере = СтрЗаменить(ПутьКВерсиямПлатформыНаСервере, НачалоПутиКВерсиямПлатформыНаСервере, "");
		ОкончаниеПутиКВерсиямПлатформыНаСервере = СтрЗаменить(ОкончаниеПутиКВерсиямПлатформыНаСервере, "%ВерсияПлатформы%", "");
		
		Для каждого Файл Из НайтиФайлы(НачалоПутиКВерсиямПлатформыНаСервере, "*") Цикл
		
			Если Файл.ЭтоКаталог() Тогда
			
				ПолныйПуть = СтрЗаменить(ПутьКВерсиямПлатформыНаСервере, "%ВерсияПлатформы%", Файл.Имя);
				ФайлКонфигуратора = Новый Файл(ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ПолныйПуть) + ИмяИсполняемогоФайлаКонфигуратора);
				Если ФайлКонфигуратора.Существует() И ФайлКонфигуратора.ЭтоФайл() Тогда
				
					СписокВерсий.Добавить(Файл.Имя);
				
				КонецЕсли; 
			
			КонецЕсли; 
		
		КонецЦикла; 
	
	КонецЕсли;
	
	Возврат СписокВерсий;
	
КонецФункции

// Функция возвращает Каталог исполняемого файла на сервере
//
// Параметры:
//  ВерсияПлатформы	 - Строка	 - Требуемая версия платформы
// 
// Возвращаемое значение:
//  Строка - Путь к каталогу исполняемого файла
//
Функция КаталогИсполняемогоФайлаНаСервере(ВерсияПлатформы = "") Экспорт 

	КаталогИсполняемогоФайла = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(КаталогПрограммы());
	ПутьКВерсиямПлатформыНаСервере = Константы.ПутьКВерсиямПлатформыНаСервере.Получить();
	Если ЗначениеЗаполнено(ПутьКВерсиямПлатформыНаСервере) Тогда
		
		Если НЕ ЗначениеЗаполнено(ВерсияПлатформы) Тогда
			СисИнфо = Новый  СистемнаяИнформация;
			ВерсияПлатформы = СисИнфо.ВерсияПриложения;
		КонецЕсли; 
		ПутьКВерсиямПлатформыНаСервере = СтрЗаменить(ПутьКВерсиямПлатформыНаСервере, "%ВерсияПлатформы%", ВерсияПлатформы);
		Файл = Новый Файл(ПутьКВерсиямПлатформыНаСервере);
		Если Файл.Существует() Тогда
			КаталогИсполняемогоФайла = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ПутьКВерсиямПлатформыНаСервере);
		Иначе
			ТекстОшибки = НСтр("ru = 'Не найдена указанная версия платформы: %ВерсияПлатформы% на сервере: %ИмяСервера%.
				|Путь к 1С:Конфигуратору на сервере: %Путь%.'");
			ТекстОшибки = СтрЗаменить(ТекстОшибки, "%ВерсияПлатформы%", ВерсияПлатформы);
			ТекстОшибки = СтрЗаменить(ТекстОшибки, "%ИмяСервера%", ИмяКомпьютера());
			ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Путь%", ПутьКВерсиямПлатформыНаСервере);
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат КаталогИсполняемогоФайла;
	
КонецФункции

// Процедура проверяет дубли строк в табличной части
// Параметры:
//	Объект - проверяемый ДокументОбъект
//	ИмяТЧ - имя проверяемой табличной части
//	КлючевыеРеквизиты - массив имен реквизитов, по которым определяется уникальность строки
//	Отказ - отказ продолжения операции
Процедура ПроверитьНаличиеДублейСтрокТЧ(Объект,ИмяТЧ,КлючевыеРеквизиты,Отказ, ПредставлениеТЧ = "", УказыватьНомераСтрок = Истина) Экспорт
	
	КлючДанных = КлючДанныхДляСообщенияПользователю(Объект);
	
	МетаданныеОбъекта = Объект.Метаданные();
	Если ПустаяСтрока(ПредставлениеТЧ) Тогда
		ПредставлениеТЧ   = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Синоним;
	КонецЕсли;
	
	ТекстПоляВыборки = "";
	ТекстПоляСоединения = "";	
    ТекстПоляВыгрузки = "";
	ТекстДляСообщенияОДублях = "";
	Для Каждого СтрМас из КлючевыеРеквизиты Цикл
		ТекстПоляВыборки = ТекстПоляВыборки + "
	|	ТаблицаПроверки." + СтрМас + ",";
		ТекстПоляСоединения = ТекстПоляСоединения + "
	|	И ТаблицаПроверки." + СтрМас + " = ДублирующиесяСтроки."+ СтрМас;
		ТекстПоляВыгрузки = ТекстПоляВыгрузки + СтрМас + ",";
		
		ПредставлениеРеквизита = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Реквизиты[СтрМас].Синоним;
		
		ТекстДляСообщенияОДублях = ТекстДляСообщенияОДублях + """"  + ПредставлениеРеквизита  + """, "
	КонецЦикла;	
	
	ТекстДляСообщенияОДублях = Лев(ТекстДляСообщенияОДублях, СтрДлина(ТекстДляСообщенияОДублях) - 2);
	
	СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(ТекстПоляВыборки,1);
	СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(ТекстПоляВыгрузки,1);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ 
	|	ТаблицаПроверки.НомерСтроки, " +
		ТекстПоляВыборки + "
	|ПОМЕСТИТЬ ТаблицаПроверки
	|ИЗ
	|	&ТаблицаПроверки КАК ТаблицаПроверки
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	МИНИМУМ(ТаблицаПроверки.НомерСтроки) КАК НомерСтроки,
	|	СУММА(1) КАК КоличествоДублей,"+
		ТекстПоляВыборки + "
	|ПОМЕСТИТЬ ДублирующиесяСтроки
	|ИЗ
	|	ТаблицаПроверки КАК ТаблицаПроверки
	|
	|СГРУППИРОВАТЬ ПО " +
		ТекстПоляВыборки + "
	|
	|ИМЕЮЩИЕ
	|	СУММА(1) > 1
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаПроверки.НомерСтроки,
	|	ДублирующиесяСтроки.НомерСтроки КАК ПерваяСтрока,"+
		ТекстПоляВыборки + "
	|ИЗ
	|	ТаблицаПроверки КАК ТаблицаПроверки
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ДублирующиесяСтроки КАК ДублирующиесяСтроки
	|		ПО ТаблицаПроверки.НомерСтроки <> ДублирующиесяСтроки.НомерСтроки " +
	     		ТекстПоляСоединения;
	Запрос.УстановитьПараметр("ТаблицаПроверки",Объект[ИмяТЧ].Выгрузить(,"НомерСтроки," + ТекстПоляВыгрузки));
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если УказыватьНомераСтрок Тогда
		Если КлючевыеРеквизиты.Количество() = 1 Тогда
			ШаблонСообщения = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" по сравнению со строкой %ПерваяСтрока% повторяется значение ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.'");
		Иначе
			ШаблонСообщения = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" по сравнению со строкой %ПерваяСтрока% повторяется сочетание значений ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.'");
		КонецЕсли;	
	Иначе
		Если КлючевыеРеквизиты.Количество() = 1 Тогда
			ШаблонСообщения = НСтр("ru = 'В списке ""%ПредставлениеТЧ%"" повторяется значение ""%ПовторяемоеЗначение%"" в поле %НазванияПолей%.'");
		Иначе
			ШаблонСообщения = НСтр("ru = 'В списке ""%ПредставлениеТЧ%"" повторяется сочетание значений ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.'");
		КонецЕсли;	
	КонецЕсли;
	Пока Выборка.Следующий() Цикл
		
		ТекстСообщения =  СтрЗаменить(ШаблонСообщения, "%ПредставлениеТЧ%", ПредставлениеТЧ);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%НомерСтроки%", Выборка.НомерСтроки);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%ПерваяСтрока%", Выборка.ПерваяСтрока);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%НазванияПолей%", ТекстДляСообщенияОДублях);
		
		ПовторяемоеЗначение = "";
		
		Для Каждого СтрМас из КлючевыеРеквизиты Цикл
			ПредставлениеЗначения = СокрЛП(Строка(Выборка[СтрМас]));
			Если ЗначениеЗаполнено(ПредставлениеЗначения) Тогда
				ПовторяемоеЗначение = ПовторяемоеЗначение + Выборка[СтрМас] + "/";
			КонецЕсли;
		КонецЦикла;
		ПовторяемоеЗначение = Лев(ПовторяемоеЗначение, СтрДлина(ПовторяемоеЗначение) - 1);
		
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%ПовторяемоеЗначение%", ПовторяемоеЗначение);
		
		Если УказыватьНомераСтрок Тогда
			Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, Выборка.НомерСтроки, "НомерСтроки");
		Иначе
			Поле = ИмяТЧ;
		КонецЕсли;
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,"Объект",Отказ);
		
	КонецЦикла;
КонецПроцедуры

// Возвращает ключ данных для подстановки в сообщение пользователю
// Ключ данных нужен при групповой обработке объектов - если он установлен, то при нажатии пользователем на сообщение
// будет открываться форма объекта
//
//	Параметры:
//		Объект - Произвольный - объект, для которого нужно получить ключ данных
//	
//	Возвращаемое значение
//		Ссылка - ссылка на объект информационной базы
//
Функция КлючДанныхДляСообщенияПользователю(Объект) Экспорт
	
	КлючДанных = Неопределено;
	XMLТипЗнч = XMLТипЗнч(Объект); 
	
	Если XMLТипЗнч <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч.ИмяТипа;
		Если СтрНайти(ТипЗначенияСтрокой, "Object.") > 0 Тогда
			КлючДанных = Объект.Ссылка;
		КонецЕсли;
	КонецЕсли;
	
	Возврат КлючДанных;
	
КонецФункции

// Возвращает дату, следующую за текущей, по основному календарю, определенному в настройках системы
//
// Возвращаемое значение:
//  ДатаЗавтра - тип - Дата - дата по календарю
//
Функция СледующаяДатаПоОсновномуКалендарю() Экспорт
	
	Календарь = Константы.ОсновнойКалендарь.Получить();
	
	ТекущаяДата = НачалоДня(ТекущаяДата());
	
	ДатаЗавтра = Неопределено;
		
	Если ЗначениеЗаполнено(Календарь) Тогда
		ПроизводственныйКалендарь = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Календарь, "ПроизводственныйКалендарь"); 
		ДатаЗавтра = КалендарныеГрафики.ДатаПоКалендарю(ПроизводственныйКалендарь, ТекущаяДата, 1, Ложь);
	КонецЕсли;
		
	Если ДатаЗавтра = Неопределено Тогда
		ДатаЗавтра = ТекущаяДата + 86400;
	КонецЕсли;
	
	Возврат ДатаЗавтра;
	
КонецФункции

// Возвращает ссылку на производственный календарь, указанный в основном календаре, определенном в настройках системы
//
// Возвращаемое значение:
//  Календарь - тип - СправочникСсылка.ПроизводственныеКалендари - производственный календарь
//
Функция ОсновнойПроизводственныйКалендарь() Экспорт
	
	Календарь = Константы.ОсновнойКалендарь.Получить();
		
	Если ЗначениеЗаполнено(Календарь) Тогда
		Возврат ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Календарь, "ПроизводственныйКалендарь"); 
	Иначе
		Возврат Справочники.ПроизводственныеКалендари.ПустаяСсылка();
	КонецЕсли;
	
КонецФункции

// Рассчитывает и возвращает срок отработки поручения от переданной даты,
// С учетом нормы длительности отработки поручений, определяемых в проекте,
// и используемого календаря.
//
// Параметры:
//  ДатаНаправленияПоручения - Тип- Дата. Дата, от которой требуется рассчитать срок.
//  Проект -Тип- СправочникСсылка.Проекты. Проект, в рамках которого требуется рассчитать срок.
//
// Возвращаемое значение:
//  Срок -Тип-дата. Рассчитанный срок отработки поручения
//
Функция СрокОтработкиПоручения(ДатаНаправленияПоручения, Проект) Экспорт
	
	НормаДлительностиОтработки = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Проект, "НормаДлительностиОтработкиПоручений");
	
	Календарь = Константы.ОсновнойКалендарь.Получить();
	
	НачальнаяДата = ДатаНаправленияПоручения;
	
	Если НЕ ЗначениеЗаполнено(НачальнаяДата) Тогда
		НачальнаяДата = ТекущаяДата();
	КонецЕсли;
	
	ДатаПоКалендарю =
		КалендарныеГрафики.ДатаПоКалендарю(Календарь, НачальнаяДата, НормаДлительностиОтработки, Ложь);
		
	Если ДатаПоКалендарю = Неопределено Тогда
		ДатаПоКалендарю = НачальнаяДата + НормаДлительностиОтработки*86400 ;
	КонецЕсли;
	
	Возврат ДатаПоКалендарю;
	
КонецФункции

Процедура УстановитьУсловноеОформлениеСпискаОтветственный(УсловноеОформлениеСписка) Экспорт
	
	// Выделение жирным шрифтом поля Ответственный, соответствующего пользователю
	
	ЭлементОформления = УсловноеОформлениеСписка.Элементы.Добавить();
	ЭлементОформления.Представление = НСтр("ru='Выделение шрифтом ответственного-текущего пользователя'");
	
	ТипЭлементОтбора  = Тип("ЭлементОтбораКомпоновкиДанных");
	
	ЭлементОтбора = ЭлементОформления.Отбор.Элементы.Добавить(ТипЭлементОтбора);
	
	ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Ответственный");
	ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ЭлементОтбора.ПравоеЗначение = Пользователи.ТекущийПользователь();
	ЭлементОтбора.Использование = Истина;
	
	ЭлементШрифта = ЭлементОформления.Оформление.Элементы.Найти("Шрифт");
	ЭлементШрифта.Значение = Новый Шрифт(,, Истина);
	ЭлементШрифта.Использование = Истина;
	
	ЭлементОбласти = ЭлементОформления.Поля.Элементы.Добавить();
	ЭлементОбласти.Поле = Новый ПолеКомпоновкиДанных("Ответственный");
	ЭлементОбласти.Использование = Истина;
	
КонецПроцедуры

// Формирует представление найденного текста - выделяет цветом текст, который ввел пользователь.
//
// Параметры:
//  Текст			 - Строка	 - Искомый текст.
//  Представление1	 - Строка	 - Найденный текст.
//  Представление2	 - Строка	 - Найденный текст.
// 
// Возвращаемое значение:
//  ФорматированнаяСтрока - Представление найденного текста.
//
Функция ПредставлениеНайденногоТекста(Текст, Представление1, Представление2 = "") Экспорт
	
	ПозНачало = Найти(ВРег(Представление2), ВРег(Текст));
	Если ПозНачало <> 0 Тогда
		ПозНачалоИмя = Найти(ВРег(Представление1), ВРег(Представление2));
		Если ПозНачалоИмя <> 0 Тогда
			ПозНачало = ПозНачало + ПозНачалоИмя - 1;
		Иначе
			ПозНачало = 0;
		КонецЕсли; 
	КонецЕсли; 
	
	Если ПозНачало = 0 Тогда
		ПозНачало = Найти(ВРег(Представление1), ВРег(Текст));
	КонецЕсли; 
	
	Если ПозНачало <> 0 Тогда
		
		ДлинаТекста = СтрДлина(Текст);
		ДлинаПредставления = СтрДлина(Представление1);
		
		ПредставлениеСсылки = Новый ФорматированнаяСтрока(
				?(ПозНачало <> 1, Лев(Представление1, ПозНачало - 1), ""),
				Новый ФорматированнаяСтрока(Сред(Представление1, ПозНачало, ДлинаТекста), Новый Шрифт(,, Истина), WebЦвета.ЦветМорскойВолны),
				?(ДлинаПредставления > (ПозНачало + ДлинаТекста - 1) , Сред(Представление1, ПозНачало + ДлинаТекста), ""));
		
		
	Иначе
		
		ПредставлениеСсылки = Представление1;
		
	КонецЕсли;
	
	Возврат ПредставлениеСсылки;

КонецФункции

//Метод для переопределения генирации имени ветки по параметрам.
//
// Параметры:
//  РазрабатываемыйОбъект - СправочникСсылка.Проекты            - Проект, для которого создается основная ветка.
//                        - СправочникСсылка.ВерсииПроектов     - Версия, для которой создается ветка.
//                        - СправочникСсылка.ТехническиеПроекты - Технический проект, для которого создается ветка.
//                        - СправочникСсылка.Ошибки             - Ошибка, для которой создается ветка исправления.
//                        - СправочникСсылка.Ветки              - Ветка источник, для которой подчиненная ветка.
//  Ответственный         - СправочникСсылка.Пользователи       - Ответственный за ветку.
//  Источник              - СправочникСсылка.Ветки              - Ветка источник.
//  Тип                   - ПеречислениеСсылка.ТипыВеток        - Тип ветки.
//  ДатаСоздания          - ДатаВремя                           - Дата создания ветки.
//  ДанныеЗаполнения      - Структура                           - Прочие параметры для генерации имени ветки.
//
// Возвращаемое значение:
//  Строка - Сгенерированное имя ветки.
Процедура ИмяВеткиРепозиторияПоРазрабатываемомуОбъекту(РазрабатываемыйОбъект, ИмяВетки, Ответственный = Неопределено, Источник = Неопределено, ТипВетки = Неопределено, ДатаСоздания = Неопределено, ДанныеЗаполнения = Неопределено) Экспорт
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Построить индекс по колонке дерева для ускорения поиска по ней.
//
// Параметры:
//  Дерево - ДеревоЗначений - индексируемое дерево.
//  Колонка - Строка - имя индексируемой колонки.
//  Индекс - Соответствие - передавать не нужно, используется самой функцией.
//
// Возвращаемое значение:
//  Соответствие - индекс в котором ключ - это искомое значение в колонке, а значение - найденная строка.
//
Функция ИндексироватьДерево(Дерево, Колонка, Индекс = Неопределено) Экспорт
	
	Если Индекс = Неопределено Тогда
		Индекс = Новый Соответствие;
	КонецЕсли;
	
	Для каждого Строка Из Дерево.Строки Цикл
		Индекс[Строка[Колонка]] = Строка;
		
		Если Строка.Строки.Количество() > 0 Тогда
			ИндексироватьДерево(Строка, Колонка, Индекс);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Индекс;
	
КонецФункции

// Разделить массив по типам значений в нем, получая на выходе соответствие, где ключ - это тип,
// а значение массив, содержащий элементы этого типа.
//
// Параметры:
//  РазделяемоеЗначение - Массив из Произвольный - массив элементов различных типов.
//  ОжидаемыеТипы - Строка - типы, которые ожидается найти в переданном массиве, перечисленные через запятую.
//                  Если указанного типа нет в массиве, то для этого типа будет создан пустой массив.
//
// Возвращаемое значение:
//  Соответствие - где ключ - это тип, а значение - это новый массив элементов этого типа из исходного массива.
//
Функция РазделитьМассивПоТипам(РазделяемоеЗначение, ОжидаемыеТипы = "") Экспорт
	
	Если ТипЗнч(РазделяемоеЗначение) = Тип("Массив") Тогда
		РазделяемыйМассив = РазделяемоеЗначение;
	Иначе
		РазделяемыйМассив = Новый Массив;
		РазделяемыйМассив.Добавить(РазделяемоеЗначение);
	КонецЕсли;
	
	МассивыПоТипам = Новый Соответствие;
	МассивОжидаемыхТипов = СтрРазделить(ОжидаемыеТипы, ",");
	
	Для каждого ОжидаемыйТип Из МассивОжидаемыхТипов Цикл
		МассивыПоТипам[Тип(СокрЛП(ОжидаемыйТип))] = Новый Массив;
	КонецЦикла;
	
	Для каждого Элемент Из РазделяемыйМассив Цикл
		Тип = ТипЗнч(Элемент);
		МассивТипа = МассивыПоТипам[Тип];
		
		Если МассивТипа = Неопределено Тогда
			МассивТипа = Новый Массив;
			МассивыПоТипам[Тип] = МассивТипа;
		КонецЕсли;
		
		МассивТипа.Добавить(Элемент);
	КонецЦикла;
	
	Возврат МассивыПоТипам;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Функция проверяет, используются ли для объекта метаданных права доступа,
// (например, для общих модулей права доступа не устанавливаются).
//
// Параметры:
//	ИмяКласса (Строка) - имя класса объекта метаданных.
//
// Возвращаемое значение:
//	Булево. 
//	Истина - для объекта метаданных используются права доступа,
//	Ложь - нет.
//
Функция ИспользоватьПраваДоступаОбъектаМетаданных(ИмяКласса)
		
	Если ИмяКласса = "Роли" 
		ИЛИ ИмяКласса = "ОбщиеМодули" 
		ИЛИ ИмяКласса = "ПодпискиНаСобытия" 
		ИЛИ ИмяКласса = "РегламентныеЗадания" 
		ИЛИ ИмяКласса = "ФункциональныеОпции" 
		ИЛИ ИмяКласса = "ХранилищаНастроек" 
		ИЛИ ИмяКласса = "ГруппыКоманд" 
		ИЛИ ИмяКласса = "ПакетыXDTO" 
		ИЛИ ИмяКласса = "WebСервисы" 
		ИЛИ ИмяКласса = "WSСсылки"
		ИЛИ ИмяКласса = "ОбщиеМакеты"
		ИЛИ ИмяКласса = "ОбщиеКартинки"
		ИЛИ ИмяКласса = "HTTPСервисы"
		ИЛИ ИмяКласса = "ПараметрыФункциональныхОпций"
		ИЛИ ИмяКласса = "ОпределяемыеТипы"
		ИЛИ ИмяКласса = "Нумераторы"
		ИЛИ ИмяКласса = "Стили"
		ИЛИ ИмяКласса = "ЭлементыСтиля"
		ИЛИ ИмяКласса = "Языки"
		
		Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Функция проверяет, используются ли для объекта метаданных подписки на события,
// (например, для общих модулей права доступа не устанавливаются).
//
// Параметры:
//	ИмяКласса (Строка) - имя класса объекта метаданных.
//
// Возвращаемое значение:
//	Булево. 
//	Истина - для объекта метаданных используются права доступа,
//	Ложь - нет.
//
Функция ИспользоватьПодпискиНаСобытияОбъектаМетаданных(ИмяКласса)
		
	Если ИмяКласса = "Роли" 
		ИЛИ ИмяКласса = "ОбщиеМодули" 
		ИЛИ ИмяКласса = "ПодпискиНаСобытия" 
		ИЛИ ИмяКласса = "РегламентныеЗадания"
		ИЛИ ИмяКласса = "ФункциональныеОпции"  
		ИЛИ ИмяКласса = "ГруппыКоманд" 
		ИЛИ ИмяКласса = "ПакетыXDTO" 
		ИЛИ ИмяКласса = "ОбщиеКоманды" 
		ИЛИ ИмяКласса = "WebСервисы" 
		ИЛИ ИмяКласса = "HTTPСервисы" 
		ИЛИ ИмяКласса = "WSСсылки"
		ИЛИ ИмяКласса = "ОбщиеФормы" 
		ИЛИ ИмяКласса = "ПараметрыСеанса" 
		ИЛИ ИмяКласса = "ОбщиеРеквизиты"
		ИЛИ ИмяКласса = "ПараметрыФункциональныхОпций"
		ИЛИ ИмяКласса = "ОбщиеМакеты"
		ИЛИ ИмяКласса = "ЭлементыСтиля"
		ИЛИ ИмяКласса = "Стили"
		ИЛИ ИмяКласса = "Языки"
		ИЛИ ИмяКласса = "ОбщиеКартинки"
		ИЛИ ИмяКласса = "Нумераторы"
		ИЛИ ИмяКласса = "ВнешниеИсточникиДанных"
		
		Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Функция проверяет, используются ли для объекта метаданных команды,
// (например, для общих модулей права доступа не устанавливаются).
//
// Параметры:
//	ИмяКласса (Строка) - имя класса объекта метаданных.
//
// Возвращаемое значение:
//	Булево. 
//	Истина - для объекта метаданных используются команды,
//	Ложь - нет.
//
Функция ИспользоватьКомандыОбъектаМетаданных(ИмяКласса)
	
	Если ИмяКласса = "Справочники" 
		ИЛИ ИмяКласса = "Документы" 
		ИЛИ ИмяКласса = "ЖурналыДокументов" 
		ИЛИ ИмяКласса = "Отчеты"
		ИЛИ ИмяКласса = "Обработки"  
		ИЛИ ИмяКласса = "ПланыВидовХарактеристик" 
		ИЛИ ИмяКласса = "ПланыСчетов" 
		ИЛИ ИмяКласса = "ПланыВидовРасчета" 
		ИЛИ ИмяКласса = "РегистрыСведений" 
		ИЛИ ИмяКласса = "РегистрыНакопления"
		ИЛИ ИмяКласса = "РегистрыБухгалтерии"
		ИЛИ ИмяКласса = "РегистрыРасчета"
		ИЛИ ИмяКласса = "БизнесПроцессы"
		ИЛИ ИмяКласса = "Задачи"
		
		Тогда
		
		Возврат Истина;
		
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Функция проверяет, используются ли для объекта метаданных элементы справки,
// (например, для общих модулей права доступа не устанавливаются).
//
// Параметры:
//	ИмяКласса (Строка) - имя класса объекта метаданных.
//
// Возвращаемое значение:
//	Булево. 
//	Истина - для объекта метаданных используются права доступа,
//	Ложь - нет.
//
Функция ИспользоватьЭлементыСправкиОбъектаМетаданных(ИмяКласса)
		
	Если ИмяКласса = "Роли" 
		ИЛИ ИмяКласса = "ОбщиеМодули" 
		ИЛИ ИмяКласса = "КритерииОтбора" 
		ИЛИ ИмяКласса = "ПодпискиНаСобытия"
		ИЛИ ИмяКласса = "РегламентныеЗадания"
		ИЛИ ИмяКласса = "ФункциональныеОпции"
		ИЛИ ИмяКласса = "ХранилищаНастроек"
		ИЛИ ИмяКласса = "ГруппыКоманд"
		ИЛИ ИмяКласса = "Перечисления"
		ИЛИ ИмяКласса = "Константы" 
		ИЛИ ИмяКласса = "ПакетыXDTO" 
		ИЛИ ИмяКласса = "WebСервисы" 
		ИЛИ ИмяКласса = "WSСсылки"
		ИЛИ ИмяКласса = "ПараметрыСеанса"  
		ИЛИ ИмяКласса = "Последовательности"
		ИЛИ ИмяКласса = "ОбщиеРеквизиты"
		ИЛИ ИмяКласса = "ОбщиеМакеты"
		ИЛИ ИмяКласса = "ОбщиеКартинки"
		ИЛИ ИмяКласса = "HTTPСервисы"
		ИЛИ ИмяКласса = "ПараметрыФункциональныхОпций"
		ИЛИ ИмяКласса = "ОпределяемыеТипы"
		ИЛИ ИмяКласса = "Нумераторы"
		ИЛИ ИмяКласса = "ВнешниеИсточникиДанных"
		ИЛИ ИмяКласса = "Стили"
		ИЛИ ИмяКласса = "ЭлементыСтиля"
		ИЛИ ИмяКласса = "Языки"
		
		Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Функция проверяет, используются ли для объекта метаданных представление объекта,
//
// Параметры:
//	ИмяКласса (Строка) - имя класса объекта метаданных.
//
// Возвращаемое значение:
//	Булево. 
//	Истина - для объекта метаданных используются права доступа,
//	Ложь - нет.
//
Функция ИспользоватьПредставлениеОбъектаОбъектаМетаданных(ИмяКласса)
		
	Если ИмяКласса = "ОбщиеМодули" 
		ИЛИ ИмяКласса = "Роли" 
		ИЛИ ИмяКласса = "КритерииОтбора" 
		ИЛИ ИмяКласса = "ПодпискиНаСобытия"  
		ИЛИ ИмяКласса = "РегламентныеЗадания" 
		ИЛИ ИмяКласса = "ФункциональныеОпции" 
		ИЛИ ИмяКласса = "ХранилищаНастроек"
		ИЛИ ИмяКласса = "ОбщиеКоманды"
		ИЛИ ИмяКласса = "ГруппыКоманд"
		ИЛИ ИмяКласса = "ПакетыXDTO" 
		ИЛИ ИмяКласса = "WebСервисы"
		ИЛИ ИмяКласса = "WSСсылки" 
		ИЛИ ИмяКласса = "Константы"
		ИЛИ ИмяКласса = "ОбщиеФормы"
		ИЛИ ИмяКласса = "ПараметрыСеанса"  
		ИЛИ ИмяКласса = "Последовательности"  
		ИЛИ ИмяКласса = "ОбщиеРеквизиты"
		ИЛИ ИмяКласса = "ОбщиеМакеты"
		ИЛИ ИмяКласса = "ОбщиеКартинки"
		ИЛИ ИмяКласса = "HTTPСервисы"
		ИЛИ ИмяКласса = "ПараметрыФункциональныхОпций"
		ИЛИ ИмяКласса = "ОпределяемыеТипы"
		ИЛИ ИмяКласса = "Нумераторы"
		ИЛИ ИмяКласса = "ВнешниеИсточникиДанных"
		ИЛИ ИмяКласса = "Стили"
		ИЛИ ИмяКласса = "ЭлементыСтиля"
		ИЛИ ИмяКласса = "Языки"
		
		Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Функция проверяет, используются ли для объекта метаданных расширенное представление объекта,
//
// Параметры:
//	ИмяКласса (Строка) - имя класса объекта метаданных.
//
// Возвращаемое значение:
//	Булево. 
//	Истина - для объекта метаданных используются права доступа,
//	Ложь - нет.
//
Функция ИспользоватьРасширенноеПредставлениеОбъектаОбъектаМетаданных(ИмяКласса)
		
	Если ИмяКласса = "ОбщиеМодули" 
		ИЛИ ИмяКласса = "Роли" 
		ИЛИ ИмяКласса = "КритерииОтбора" 
		ИЛИ ИмяКласса = "ПодпискиНаСобытия"  
		ИЛИ ИмяКласса = "РегламентныеЗадания" 
		ИЛИ ИмяКласса = "ФункциональныеОпции" 
		ИЛИ ИмяКласса = "ХранилищаНастроек"
		ИЛИ ИмяКласса = "ОбщиеКоманды"
		ИЛИ ИмяКласса = "ГруппыКоманд"
		ИЛИ ИмяКласса = "ПакетыXDTO" 
		ИЛИ ИмяКласса = "WebСервисы"
		ИЛИ ИмяКласса = "WSСсылки" 
		ИЛИ ИмяКласса = "ПараметрыСеанса"  
		ИЛИ ИмяКласса = "Последовательности"  
		ИЛИ ИмяКласса = "ОбщиеРеквизиты"
		ИЛИ ИмяКласса = "ОбщиеМакеты"
		ИЛИ ИмяКласса = "ОбщиеКартинки"
		ИЛИ ИмяКласса = "HTTPСервисы"
		ИЛИ ИмяКласса = "ПараметрыФункциональныхОпций"
		ИЛИ ИмяКласса = "ОпределяемыеТипы"
		ИЛИ ИмяКласса = "Нумераторы"
		ИЛИ ИмяКласса = "ВнешниеИсточникиДанных"
		ИЛИ ИмяКласса = "Стили"
		ИЛИ ИмяКласса = "ЭлементыСтиля"
		ИЛИ ИмяКласса = "Языки"
		
		Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Функция проверяет, используются ли для объекта метаданных представление списка,
// (например, для общих модулей права доступа не устанавливаются).
//
// Параметры:
//	ИмяКласса (Строка) - имя класса объекта метаданных.
//
// Возвращаемое значение:
//	Булево. 
//	Истина - для объекта метаданных используются права доступа,
//	Ложь - нет.
//
Функция ИспользоватьПредставлениеСпискаОбъектаМетаданных(ИмяКласса)
		
	Если ИмяКласса = "ОбщиеМодули" 
		ИЛИ ИмяКласса = "Роли" 
		ИЛИ ИмяКласса = "ПодпискиНаСобытия" 
		ИЛИ ИмяКласса = "РегламентныеЗадания"
		ИЛИ ИмяКласса = "ФункциональныеОпции" 
		ИЛИ ИмяКласса = "ХранилищаНастроек" 
		ИЛИ ИмяКласса = "ОбщиеМодули" 
		ИЛИ ИмяКласса = "ОбщиеКоманды"
		ИЛИ ИмяКласса = "ГруппыКоманд"
		ИЛИ ИмяКласса = "ПакетыXDTO"
		ИЛИ ИмяКласса = "WebСервисы" 
		ИЛИ ИмяКласса = "WSСсылки"
		ИЛИ ИмяКласса = "Константы"
		ИЛИ ИмяКласса = "ОбщиеФормы"
		ИЛИ ИмяКласса = "ПараметрыСеанса"  
		ИЛИ ИмяКласса = "Последовательности"  
		ИЛИ ИмяКласса = "ОбщиеРеквизиты"
		ИЛИ ИмяКласса = "ОбщиеМакеты"
		ИЛИ ИмяКласса = "ОбщиеКартинки"
		ИЛИ ИмяКласса = "HTTPСервисы"
		ИЛИ ИмяКласса = "ПараметрыФункциональныхОпций"
		ИЛИ ИмяКласса = "ОпределяемыеТипы"
		ИЛИ ИмяКласса = "Нумераторы"
		ИЛИ ИмяКласса = "ВнешниеИсточникиДанных"
		ИЛИ ИмяКласса = "Стили"
		ИЛИ ИмяКласса = "ЭлементыСтиля"
		ИЛИ ИмяКласса = "Языки"

		Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Функция возвращает текст запроса для получения ссылки на "расширенные"
// сведения о объекте метаданных.
//
// Параметры:
//	ОбъектМетаданных (СправочникСсылка.ОбъектыМетаданных) - объект метаданных.
//
// Возвращаемое значение:
//	Строка. Текст запроса.
//
Функция ТекстЗапросаПолученияСвойствРасширенногоХранения(ОбъектМетаданных)
	
	ТекстЗапроса = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	РасширенныеСвойства.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.%1 КАК РасширенныеСвойства
	|ГДЕ
	|	РасширенныеСвойства.Владелец = &ОбъектМетаданных";
	
	ИмяСправочника = ИмяСправочникаРасширенныхСвойств(ОбъектМетаданных);
	
	ТекстЗапроса = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстЗапроса, ИмяСправочника);
	
	Возврат ТекстЗапроса;
	
КонецФункции

Функция ПолучитьРодителяИБ(IDРодителя, КореньИБ)
	
	Если IDРодителя = "/" Тогда
		Возврат КореньИБ;
	КонецЕсли;
	
	РодительИБ = КореньИБ.Строки.Найти(IDРодителя, "ID", Истина);
	Если РодительИБ = Неопределено Тогда 
		IDРодителяНовый = Сред(IDРодителя,2);
		
		МассивРодителей = ПолучитьМассивИзСтрокиСРазделителем(IDРодителяНовый, "/");
		IDРодителяНовый = "";
		РодительИБ = КореньИБ;
		Для каждого ЭлРодитель Из МассивРодителей Цикл
			IDРодителяНовый = IDРодителяНовый + "/" + ЭлРодитель;
			
			РодительСтрока = РодительИБ.Строки.Найти(IDРодителяНовый, "ID", Ложь);
			Если РодительСтрока = Неопределено Тогда 
				РодительСтрока = РодительИБ.Строки.Добавить();
				РодительСтрока.ID = IDРодителяНовый;
				РодительСтрока.Folder = Истина;
				РодительСтрока.ИнформационнаяБаза = ЭлРодитель;
				РодительСтрока.НомерКартинки = 1;
			КонецЕсли;
			РодительИБ = РодительСтрока;
		КонецЦикла; 
	КонецЕсли;
	
	Возврат РодительИБ;
	
КонецФункции

Функция ПолучитьМассивИзСтрокиСРазделителем(Знач СтрокаСРазделитем, Разделитель)
	
	Результат = Новый Массив;
	
	Поз = Найти(СтрокаСРазделитем, Разделитель);
	Пока Поз <> 0 Цикл
		Результат.Добавить(Лев(СтрокаСРазделитем, Поз - 1));
		
		СтрокаСРазделитем = Сред(СтрокаСРазделитем, Поз + 1);
		Поз = Найти(СтрокаСРазделитем, Разделитель);
	КонецЦикла;
	
	Результат.Добавить(СтрокаСРазделитем);
	
	Возврат Результат;
	
КонецФункции

Функция РазобратьСтрокуСоединения(СтрокаСоединения)

	Результат = Новый Структура;
	
	Если НСтр(СтрокаСоединения,"File") <> "" Тогда
		
		ФайловыйРежим = Истина;
		
		КаталогИБ = НСтр(СтрокаСоединения,"File");
		Если ЗначениеЗаполнено(КаталогИБ) Тогда
			КаталогИБ = КаталогИБ + ?(Прав(КаталогИБ, 1) = "\", "", "\");
		КонецЕсли; 
	Иначе
		
		ФайловыйРежим = Ложь;
		
		ИмяСервера = НСтр(СтрокаСоединения,"Srvr");
		ИмяИБ = НСтр(СтрокаСоединения,"Ref");
		
	КонецЕсли;
	
	Результат.Вставить("ФайловыйРежим", ФайловыйРежим);
	Результат.Вставить("ИмяСервера", ИмяСервера);
	Результат.Вставить("КаталогИБ", КаталогИБ);
	Результат.Вставить("ИмяИБ", ИмяИБ);
	
	Возврат Результат;
	
КонецФункции

Процедура УдалитьПустыеГруппыБаз(КоллекцияСтрок)

	СтрокиКУдалению = Новый Массив;
	
	Для каждого ДанныеСтроки Из КоллекцияСтрок Цикл
		Если НЕ ДанныеСтроки.Folder Тогда
			Продолжить;
		КонецЕсли; 
		
		СтруктураПоиска = Новый Структура("Folder", Ложь);
  		СписокСтрок = ДанныеСтроки.Строки.НайтиСтроки(СтруктураПоиска, Истина);
		Если СписокСтрок.Количество() <> 0 Тогда
			УдалитьПустыеГруппыБаз(ДанныеСтроки.Строки);
		Иначе
			СтрокиКУдалению.Добавить(ДанныеСтроки);
		КонецЕсли; 
	КонецЦикла; 

	Для каждого ДанныеСтроки Из СтрокиКУдалению Цикл
		КоллекцияСтрок.Удалить(ДанныеСтроки);
	КонецЦикла; 
	
КонецПроцедуры

Функция РазделитьИмяПоляИРеквизита(ИмяПоля)
	
	Результат = Новый Структура("Имя,Реквизит", "", "");
	МассивИмен = СтрРазделить(ИмяПоля, ".");
	Если МассивИмен.Количество() > 0 Тогда
		Результат.Имя = МассивИмен[0];
	КонецЕсли;
	
	Если МассивИмен.Количество() > 1 Тогда
		МассивИмен.Удалить(0);
		Результат.Реквизит = СтрСоединить(МассивИмен,".");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция СоздатьВременныйКаталог()
	
	ВременныйКаталог = ПолучитьИмяВременногоФайла() 
	                 + ПолучитьРазделительПути() 
	                 + Строка(Новый УникальныйИдентификатор);
	СоздатьКаталог(ВременныйКаталог);
	
	Возврат ВременныйКаталог;
	
КонецФункции

#КонецОбласти
